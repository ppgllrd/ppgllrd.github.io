<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weight-Biased Leftist Min-Heap Visualizer</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: #f5f5f5;
            --border-color: #ddd;

            /* UI Colors */
            --btn-insert: #2E7D32;
            --btn-delete: #c62828;
            --btn-search: #1668BD;
            --btn-undo: #6A1B9A;
            --btn-gray: #546E7A;
            --btn-merge: #EF6C00;
            --btn-build: #7B1FA2;
            --btn-merges: #00838F;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            user-select: none;
        }

        header {
            padding: 10px 20px;
            background-color: var(--panel-bg);
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .gui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            color: #222;
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .sub-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 0.9rem;
            color: #555;
            vertical-align: middle;
        }

        input[type="number"] {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #999;
            background: #fff;
            color: #000;
            width: 60px;
            text-align: center;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100px;
            cursor: pointer;
        }

        button {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            color: white;
            transition: filter 0.2s, transform 0.1s;
            font-size: 0.85rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-insert {
            background-color: var(--btn-insert);
        }

        .btn-delete {
            background-color: var(--btn-delete);
        }

        .btn-search {
            background-color: var(--btn-search);
        }

        .btn-undo {
            background-color: var(--btn-undo);
        }

        .btn-clear {
            background-color: var(--btn-gray);
        }

        .btn-merge {
            background-color: var(--btn-merge);
        }

        .btn-build {
            background-color: var(--btn-build);
        }

        .btn-merges {
            background-color: var(--btn-merges);
        }

        .btn-pause {
            background-color: #455A64;
            width: 80px;
        }

        .btn-help {
            background-color: #607D8B;
            font-size: 1.1rem;
            padding: 4px 10px;
            border-radius: 50%;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--bg-color);
            cursor: default;
            min-height: 0;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.8rem;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            color: #333;
        }

        .dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        .line-icon {
            width: 15px;
            height: 3px;
            border-radius: 2px;
        }

        .arrow-icon {
            font-size: 16px;
            font-weight: bold;
            color: #cc0000;
        }

        #status-bar {
            padding: 8px 2px 0px 0px;
            background-color: var(--panel-bg);
            font-size: 0.85rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            color: #555;
            flex-shrink: 0;
        }

        #status-text {
            font-weight: bold;
            color: #222;
        }

        #author {
            width: 100%;
            background: #f4f7f6;
            font-size: 0.75em;
            color: #777;
            text-align: center;
            line-height: 2.5;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        h2 {
            color: #2E7D32;
            margin-top: 0;
        }

        h3 {
            color: #1668BD;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-top: 15px;
        }

        p,
        li {
            font-size: 0.95rem;
            line-height: 1.5;
            color: #333;
        }

        .complexity {
            font-family: monospace;
            background: #eee;
            padding: 2px 5px;
            border-radius: 4px;
            color: #c62828;
        }

        .node-sample {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #B0F9B0;
            border: 1px solid #B0F9B0;
            text-align: center;
            line-height: 30px;
            position: relative;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }

        .node-val {
            color: #D50000;
            font-size: 12px;
        }

        .node-weight {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 10px;
            color: #1565C0;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            padding: 1px 3px;
        }
    </style>
</head>

<body>

    <header>
        <div class="header-top">
            <h1>Weight-Biased Leftist Min-Heap Visualizer</h1>
            <button class="btn-help" onclick="app.toggleModal()" title="Help / Algorithms">?</button>
        </div>
        <div class="gui">
            <div class="controls">
                <input type="number" id="inputValue" title="Enter a number" placeholder="#"
                    onkeydown="if(event.key==='Enter') app.handleInsert()">
                <button class="btn-insert" title="Insert a value" onclick="app.handleInsert()">Insert</button>
                <button class="btn-delete" title="Delete the minimum element (Root)"
                    onclick="app.handleDeleteMin()">Delete Minimum</button>
                <button class="btn-search" title="Show minimum element" onclick="app.handleGetMin()">Minimum</button>

                <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

                <button class="btn-merge" title="Merge two random leftist heaps"
                    onclick="app.handleMergeScenario()">Merge</button>

                <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

                <button class="btn-build" title="Sequential Insertion (O(n log n))"
                    onclick="app.handleRandomBuild()">Build Random</button>
                <button class="btn-merges" title="Pairwise Merge (O(n))" onclick="app.handleBottomUpBuild()">Build
                    Bottom-Up</button>

                <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

                <button class="btn-undo" title="Undo last action" onclick="app.handleUndo()" id="btnUndo"
                    disabled>Undo</button>
                <button class="btn-clear" title="Clear tree" onclick="app.handleClear()">Clear</button>
            </div>
            <div class="sub-controls">
                <label for="speedSlider">Slowdown:</label>
                <label title="Slide right to slow down the animation">
                    <input type="range" id="speedSlider" min="1" max="5" step="0.1" value="1" oninput="app.updateSpeed()">
                </label>
                <button class="btn-pause" title="Pause/Resume" onclick="app.togglePause()" id="btnPause">Pause</button>
            </div>
        </div>
        <div id="status-bar">
            <span id="status-text">Ready. Use Mouse/Touch to Pan & Zoom.</span>
        </div>
    </header>

    <div id="canvas-container">
        <canvas id="treeCanvas"></canvas>
        <div id="legend">
            <div class="legend-item">
                <div class="node-sample"><span class="node-val">V</span><span class="node-weight">w</span></div>&nbsp;
                Value / Height
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#B0F9B0; border:2px solid #B0F9B0"></div>&nbsp; Tree 1 (Left)
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#99FFFF; border:2px solid #99FFFF"></div>&nbsp; Tree 2 (Right)
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#CC99FF; border:2px solid #CC99FF"></div>&nbsp; Comparing/Selected
            </div>
            <div class="legend-item">
                <div class="dot" style="width:10px; height:10px; background:#F44336; border:1px solid #F44336"></div>
                &nbsp; Max Weight (Left)
            </div>
            <div class="legend-item">
                <div class="line-icon" style="background:#1668BD;"></div>&nbsp; Null Link
            </div>
        </div>
    </div>

    <div id="author">Pepe Gallardo. Dpto. Lenguajes y Ciencias de la Computación. Universidad de Málaga</div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="app.toggleModal()">&times;</span>
            <h2>Algorithm Details</h2>

            <h3>Weight-Biased Leftist Heap (WBLH)</h3>
            <p>A binary tree where each node satisfies the <strong>Min-Heap property</strong> (the key of the parent is
                less than or equal to the key of the children) and
                the <strong>Leftist property</strong> (the weight of the left child is greater than or equal to the
                weight of the right child).
                The <strong>weight</strong> is the number of nodes in the subtree.</p>

            <h3>Merge Operation</h3>
            <p>The fundamental operation. Merges two heaps by traversing the <strong>rightmost path</strong> of the heap
                with the smaller root. After merging, if the Leftist property is violated, children are swapped.</p>
            <ul>
                <li>Complexity: <span class="complexity">O(log n)</span></li>
            </ul>

            <h3>Minimum / Delete Minimum</h3>
            <p>The minimum is at the root <span class="complexity">O(1)</span>. Deleting it involves merging its left
                and right subtrees (<span class="complexity">O(log n)</span>).</p>

            <h3>Build Algorithms</h3>
            <p><strong>Build Random (Sequential):</strong> Inserts n elements one by one into an empty heap.<br>
                Complexity: <span class="complexity">O(n log n)</span></p>

            <p><strong>Build Bottom-Up (Pairwise):</strong> Places n single-node heaps in a queue. Repeatedly merges the
                first two heaps and places the result at the end, until one remains.<br>
                Complexity: <span class="complexity">O(n)</span> (More efficient!)</p>
        </div>
    </div>

    <script>
        const COLORS = {
            // Colors
            FILL1: '#99FFFF', STROKE1: '#99FFFF',
            FILL2: '#B0F9B0', STROKE2: '#B0F9B0',
            COMPARE_FILL: '#CC99FF', COMPARE_STROKE: '#CC99FF',
            MINIMUM: '#CC99FF',
            DELETE: '#D32F2F',
            TEXT_VAL: '#CC0000', // Red
            EDGE: '#1668BD',
            WEIGHT_TEXT: '#1668BD',
            WEIGHT_STROKE: '#1668BD',
            WEIGHT_HIGHLIGHT: '#F44336', // Red
            ARROW: '#D50000'
        };

        class Node {
            constructor(val, origin) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.val = val;
                this.weight = 1;
                this.left = null;
                this.right = null;
                this.origin = origin;
                this.x = 0; this.y = 0;
                this.highlight = false;
                this.highlightWeights = false;
            }
            clone() {
                const n = new Node(this.val, this.origin);
                n.id = this.id;
                n.weight = this.weight;
                n.highlight = this.highlight;
                n.highlightWeights = this.highlightWeights;
                n.x = this.x; n.y = this.y;
                if (this.left) n.left = this.left.clone();
                if (this.right) n.right = this.right.clone();
                return n;
            }
        }

        const WBLT = {
            getWeight: (n) => n ? n.weight : 0,
            updateWeight: (n) => { if (n) n.weight = 1 + WBLT.getWeight(n.left) + WBLT.getWeight(n.right); },

            recordMerge: (rootList, h1Original, h2Original) => {
                const steps = [];
                let worldRoots = rootList.map(r => r ? r.clone() : null).filter(r => r);

                const snapshot = (msg, highlightIds = [], highlightWeights = []) => {
                    const frames = worldRoots.map(r => r.clone());
                    const mark = (n) => {
                        if (!n) return;
                        n.highlight = highlightIds.includes(n.id) ? 'compare' : false;
                        n.highlightWeights = highlightWeights.includes(n.id);
                        mark(n.left); mark(n.right);
                    };
                    frames.forEach(mark);
                    steps.push({ msg, roots: frames });
                };

                function mergeRec(t1, t2, parent) {
                    if (t1 && t2) snapshot(`Comparing roots: ${t1.val} vs ${t2.val}`, [t1.id, t2.id]);

                    if (!t1) {
                        if (parent) {
                            const idx = worldRoots.findIndex(n => n.id === t2.id);
                            if (idx !== -1) worldRoots.splice(idx, 1);
                            parent.right = t2;
                            snapshot(`Node ${t2.val} attached`, [t2.id, parent.id]);
                        }
                        return t2;
                    }
                    if (!t2) return t1;

                    if (t1.val > t2.val) {
                        let temp = t1; t1 = t2; t2 = temp;

                        if (parent) parent.right = t1;
                        else {
                            const i1 = worldRoots.findIndex(n => n.id === t2.id);
                            const i2 = worldRoots.findIndex(n => n.id === t1.id);
                            if (i1 !== -1) worldRoots[i1] = t1;
                            if (i2 !== -1) worldRoots[i2] = t2;
                        }

                        if (!worldRoots.some(n => n.id === t2.id)) worldRoots.push(t2);
                        if (parent) {
                            const idxT1 = worldRoots.findIndex(n => n.id === t1.id);
                            if (idxT1 !== -1) worldRoots.splice(idxT1, 1);
                        }
                        snapshot(`Swap: ${t1.val} < ${t2.val}`, [t1.id, t2.id]);
                    }

                    snapshot(`Descending right of ${t1.val}`, [t1.id]);

                    t1.right = mergeRec(t1.right, t2, t1);

                    if (t1.right) {
                        const idx = worldRoots.findIndex(n => n.id === t1.right.id);
                        if (idx !== -1) worldRoots.splice(idx, 1);
                    }

                    WBLT.updateWeight(t1);
                    snapshot(`Back at ${t1.val}. Weight: ${t1.weight}`, [t1.id]);

                    let wL = WBLT.getWeight(t1.left);
                    let wR = WBLT.getWeight(t1.right);

                    if (wL < wR) {
                        let highlightWeights = t1.right ? [t1.right.id] : [];
                        snapshot(`Leftist Violation (${wL} < ${wR}). Swapping children.`, [t1.id], highlightWeights);
                        let temp = t1.left; t1.left = t1.right; t1.right = temp;
                        snapshot(`Children swapped at ${t1.val}.`, [t1.id], highlightWeights);
                    }

                    return t1;
                }

                snapshot("Merge Start", []);

                let t1 = null;
                let t2 = null;

                if (h1Original && h2Original) {
                    t1 = worldRoots.find(n => n.id === h1Original.id);
                    t2 = worldRoots.find(n => n.id === h2Original.id);
                }

                if (!t1 && worldRoots.length > 0) t1 = worldRoots[0];
                if (!t2 && worldRoots.length > 1) t2 = worldRoots[1];

                const res = mergeRec(t1, t2, null);

                snapshot("Merge Complete", []);
                return steps;
            }
        };

        const app = {
            mainTree: null, history: [], steps: [], currentStep: 0, isPlaying: false, transition: 1,
            canvas: null, ctx: null,

            // Camera & Navigation
            currentSpeedFactor: 1.0,
            baseMorphSpeed: 3.0,  // 3.0 units/second (~0.05 per frame at 60fps)
            camera: { scale: 1, x: 0, y: 0, targetScale: 1, targetX: 0, targetY: 0 },
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            initialCamera: { x: 0, y: 0 },
            initialPinchDist: 0,
            initialScale: 1,
            hoveredNode: null,

            nodeRadius: 28, levelGap: 70,

            init: function () {
                this.canvas = document.getElementById('treeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());

                // Unified Events
                this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', e => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', e => this.onMouseUp(e));
                this.canvas.addEventListener('mouseleave', e => this.onMouseUp(e));
                this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });
                this.canvas.addEventListener('touchstart', e => this.onTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', e => this.onTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', e => this.onTouchEnd(e));

                window.onclick = (e) => {
                    if (e.target == document.getElementById('helpModal')) app.toggleModal();
                }

                this.updateUI();
                this.lastTime = 0;
                requestAnimationFrame(t => this.loop(t));
            },

            resize: function () {
                this.canvas.width = document.getElementById('canvas-container').offsetWidth;
                this.canvas.height = document.getElementById('canvas-container').offsetHeight;
            },

            toggleModal: function () {
                const m = document.getElementById('helpModal');
                m.style.display = (m.style.display === 'block') ? 'none' : 'block';
            },

            saveState: function () {
                if (this.mainTree) this.history.push(this.mainTree.clone());
                else this.history.push(null);
                if (this.history.length > 20) this.history.shift();
                this.updateUI();
            },

            // --- INPUT HANDLING ---

            checkNodeHit: function (mx, my) {
                if (!this.vizNodes) return null;
                const w = this.canvas.width; const h = this.canvas.height;
                for (let n of this.vizNodes) {
                    // Camera Transform Logic reverse mapping not needed if we project node to screen
                    // But here we interact in screen space
                    const sx = w / 2 + (n.x - this.camera.x) * this.camera.scale;
                    const sy = h / 2 + (n.y - this.camera.y) * this.camera.scale;
                    const r = this.nodeRadius * this.camera.scale;
                    if (Math.hypot(mx - sx, my - sy) < r) return n;
                }
                return null;
            },

            onMouseDown: function (e) {
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left; const my = e.clientY - rect.top;

                const node = this.checkNodeHit(mx, my);
                if (node) {
                    document.getElementById('inputValue').value = node.val;
                    document.getElementById('inputValue').focus();
                    return;
                }

                this.isDragging = true;
                this.dragStart = { x: mx, y: my };
                this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };
                this.canvas.style.cursor = 'grabbing';
            },

            onMouseMove: function (e) {
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left; const my = e.clientY - rect.top;

                this.hoveredNode = this.checkNodeHit(mx, my);
                if (this.isDragging) this.canvas.style.cursor = 'grabbing';
                else if (this.hoveredNode) this.canvas.style.cursor = 'pointer';
                else this.canvas.style.cursor = 'default';

                if (!this.isDragging) return;

                const dx = mx - this.dragStart.x;
                const dy = my - this.dragStart.y;

                this.camera.targetX = this.initialCamera.x - (dx / this.camera.scale);
                this.camera.targetY = this.initialCamera.y - (dy / this.camera.scale);
            },

            onMouseUp: function () {
                this.isDragging = false;
                this.canvas.style.cursor = this.hoveredNode ? 'pointer' : 'default';
            },

            onWheel: function (e) {
                e.preventDefault();
                const zoomIntensity = 0.001;
                const scroll = e.deltaY;
                let newScale = this.camera.targetScale * (1 - scroll * zoomIntensity);
                newScale = Math.min(Math.max(0.2, newScale), 5);

                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
                const w = this.canvas.width; const h = this.canvas.height;

                // World coordinates under mouse
                const worldX = this.camera.targetX + (mx - w / 2) / this.camera.targetScale;
                const worldY = this.camera.targetY + (my - h / 2) / this.camera.targetScale;

                this.camera.targetScale = newScale;
                // Adjust translation to keep world point under mouse
                this.camera.targetX = worldX - (mx - w / 2) / newScale;
                this.camera.targetY = worldY - (my - h / 2) / newScale;
            },

            getTouchDist: function (touches) {
                return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            },

            onTouchStart: function (e) {
                if (e.touches.length === 1) {
                    const t = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = t.clientX - rect.left; const my = t.clientY - rect.top;

                    const node = this.checkNodeHit(mx, my);
                    if (node) {
                        document.getElementById('inputValue').value = node.val;
                        document.getElementById('inputValue').focus();
                        return;
                    }
                    this.isDragging = true;
                    this.dragStart = { x: mx, y: my };
                    this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };
                } else if (e.touches.length === 2) {
                    this.isDragging = false;
                    this.initialPinchDist = this.getTouchDist(e.touches);
                    this.initialScale = this.camera.targetScale;
                }
            },

            onTouchMove: function (e) {
                e.preventDefault();
                if (e.touches.length === 1 && this.isDragging) {
                    const t = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = t.clientX - rect.left; const my = t.clientY - rect.top;
                    const dx = mx - this.dragStart.x; const dy = my - this.dragStart.y;
                    this.camera.targetX = this.initialCamera.x - (dx / this.camera.scale);
                    this.camera.targetY = this.initialCamera.y - (dy / this.camera.scale);
                } else if (e.touches.length === 2) {
                    const dist = this.getTouchDist(e.touches);
                    if (this.initialPinchDist > 0) {
                        const scaleFactor = dist / this.initialPinchDist;
                        this.camera.targetScale = Math.min(Math.max(0.2, this.initialScale * scaleFactor), 5);
                    }
                }
            },

            onTouchEnd: function () {
                this.isDragging = false;
                this.initialPinchDist = 0;
            },

            // --- ACTIONS ---

            handleInsert: function () {
                const val = parseInt(document.getElementById('inputValue').value);
                if (isNaN(val)) return;
                this.saveState();
                const newNode = new Node(val, 2);
                const h1 = this.mainTree ? this.mainTree.clone() : null;
                const h2 = newNode.clone();
                this.steps = WBLT.recordMerge([h1, h2].filter(x => x), h1, h2);
                this.mainTree = this.performMerge(this.mainTree, newNode);
                this.startAnimation();
                document.getElementById('inputValue').value = '';
            },

            handleDeleteMin: function () {
                if (!this.mainTree) return;
                this.saveState();

                const rootToDelete = this.mainTree.clone();
                rootToDelete.highlight = 'delete-target';

                const left = this.mainTree.left;
                const right = this.mainTree.right;

                const h1 = left ? left.clone() : null;
                const h2 = right ? right.clone() : null;

                const childrenRoots = [h1, h2].filter(x => x);

                let mergeSteps = [];
                let finalTree = null;

                if (childrenRoots.length === 0) {
                    mergeSteps = [{ msg: "Heap empty", roots: [] }];
                    finalTree = null;
                } else if (childrenRoots.length === 1) {
                    mergeSteps = [{ msg: "Root removed. Single child remains.", roots: [childrenRoots[0]] }];
                    finalTree = childrenRoots[0];
                } else {
                    mergeSteps = WBLT.recordMerge(childrenRoots, h1, h2);
                    finalTree = this.performMerge(this.mainTree.left, this.mainTree.right);
                }

                this.steps = [
                    { msg: "Selected Minimum for Deletion", roots: [rootToDelete] },
                    { msg: "Removing root...", roots: childrenRoots },
                    ...mergeSteps
                ];

                this.mainTree = finalTree;
                this.startAnimation();
            },

            handleGetMin: function () {
                if (!this.mainTree) return;
                const root = this.mainTree.clone(); root.highlight = 'minimum';
                this.steps = [{ msg: `Minimum: ${root.val}`, roots: [root] }, { msg: "Ready", roots: [this.mainTree.clone()] }];
                this.startAnimation();
            },

            handleMergeScenario: function () {
                this.saveState();
                const h1 = this.createRandomTree(6, 1);
                const h2 = this.createRandomTree(5, 2);
                this.steps = WBLT.recordMerge([h1, h2], h1, h2);
                this.mainTree = this.performMerge(h1.clone(), h2.clone());
                this.startAnimation();
            },

            // Build 1: Random Sequential
            handleRandomBuild: function () {
                this.handleClear();
                const vals = Array.from({ length: 8 }, () => Math.floor(Math.random() * 99) + 1);
                let tempTree = null;
                let allSteps = [{ msg: "Start Random Build (O(n log n))", roots: [] }];

                for (let val of vals) {
                    const newNode = new Node(val, 2);
                    const h1 = tempTree ? tempTree.clone() : null;
                    const h2 = newNode.clone();
                    const mergeSteps = WBLT.recordMerge([h1, h2].filter(x => x), h1, h2);
                    mergeSteps.forEach(s => s.msg = `Insert ${val}: ${s.msg}`);
                    allSteps.push(...mergeSteps);
                    tempTree = this.performMerge(tempTree, newNode);
                }
                this.steps = allSteps;
                this.mainTree = tempTree;
                this.startAnimation();
            },

            // Build 2: Bottom-Up
            handleBottomUpBuild: function () {
                this.handleClear();
                const count = 12;
                // Create Queue of single node trees
                let queue = Array.from({ length: count }, (_, i) => new Node(Math.floor(Math.random() * 99) + 1, (i % 2) + 1));
                let allSteps = [{ msg: "Initial Queue of Trees (O(n))", roots: queue.map(r => r.clone()) }];

                while (queue.length > 1) {
                    const h1 = queue.shift();
                    const h2 = queue.shift();

                    const contextRoots = [h1, h2, ...queue];
                    const mergeSteps = WBLT.recordMerge(contextRoots, h1, h2);
                    mergeSteps.forEach(s => s.msg = `Merging Pair: ${s.msg}`);
                    allSteps.push(...mergeSteps);

                    const merged = this.performMerge(h1, h2);
                    queue.push(merged);

                    allSteps.push({
                        msg: "Pair merged. Next...",
                        roots: queue.map(r => r.clone())
                    });
                }

                this.mainTree = queue[0];
                this.steps = allSteps;
                this.startAnimation();
            },

            handleUndo: function () {
                if (this.history.length > 0) {
                    this.mainTree = this.history.pop();
                    this.steps = [{ msg: "Undo successful", roots: this.mainTree ? [this.mainTree] : [] }];
                    this.startAnimation();
                    this.isPlaying = false; this.transition = 1; this.updateUI();
                }
            },

            handleClear: function () {
                this.saveState();
                this.mainTree = null;
                this.steps = [{ msg: "Cleared", roots: [] }];
                this.startAnimation();
            },

            createRandomTree: function (n, origin) {
                let t = null;
                for (let i = 0; i < n; i++) {
                    const val = Math.floor(Math.random() * 100);
                    t = this.performMerge(t, new Node(val, origin));
                }
                return t;
            },

            performMerge: function (h1, h2) {
                if (!h1) return h2;
                if (!h2) return h1;
                if (h1.val > h2.val) { let temp = h1; h1 = h2; h2 = temp; }
                h1.right = this.performMerge(h1.right, h2);
                WBLT.updateWeight(h1);
                if (WBLT.getWeight(h1.left) < WBLT.getWeight(h1.right)) {
                    let temp = h1.left; h1.left = h1.right; h1.right = temp;
                }
                return h1;
            },

            startAnimation: function () {
                this.currentStep = 0; this.transition = 0; this.isPlaying = true; this.updateUI();

                // Auto-fit ONLY at start of operation
                this.fitToAllSteps();
            },

            fitToAllSteps: function () {
                if (this.steps.length === 0) return;
                // Sample first and last steps to define bounds
                const frames = [this.steps[0]];
                if (this.steps.length > 1) frames.push(this.steps[this.steps.length - 1]);

                let allNodes = [];
                frames.forEach(frame => {
                    const layout = this.layoutInOrder(frame.roots);
                    allNodes.push(...this.flatten(layout));
                });

                const w = this.canvas.width; const h = this.canvas.height;
                if (allNodes.length === 0) {
                    this.camera.targetScale = 1; this.camera.targetX = 0; this.camera.targetY = 0;
                    return;
                }

                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                allNodes.forEach(n => {
                    minX = Math.min(minX, n.x - 40); maxX = Math.max(maxX, n.x + 40);
                    minY = Math.min(minY, n.y - 40); maxY = Math.max(maxY, n.y + 40);
                });

                const sc = Math.min(w / (maxX - minX + 100), h / (maxY - minY + 150), 1.1);
                this.camera.targetScale = sc;
                this.camera.targetX = (minX + maxX) / 2;
                this.camera.targetY = minY + (maxY - minY) / 2;
            },

            updateUI: function () {
                document.getElementById('status-text').innerText = this.steps[this.currentStep]?.msg || "Ready.";
                document.getElementById('btnUndo').disabled = this.history.length === 0;
                document.getElementById('btnPause').innerText = (this.currentStep === this.steps.length - 1 && !this.isPlaying && this.steps.length > 1) ? "Restart" : (this.isPlaying ? "Pause" : "Resume");
            },
            togglePause: function () {
                if (this.currentStep === this.steps.length - 1) { this.currentStep = 0; this.transition = 0; }
                this.isPlaying = !this.isPlaying; this.updateUI();
            },
            updateSpeed: function () { 
                this.currentSpeedFactor = 1.0 / parseFloat(document.getElementById('speedSlider').value);
            },

            loop: function (ts) {
                if (!this.lastTime) this.lastTime = ts;
                let dt = (ts - this.lastTime) / 1000;
                dt = Math.min(dt, 0.1)
                this.lastTime = ts;

                // const currentSpeedFactor = 5 / parseFloat(document.getElementById('speedSlider').value);

                // Smooth Camera Movement (Time-based)
                const camFactor = 1 - Math.exp(-10 * dt);
                this.camera.x += (this.camera.targetX - this.camera.x) * camFactor;
                this.camera.y += (this.camera.targetY - this.camera.y) * camFactor;
                this.camera.scale += (this.camera.targetScale - this.camera.scale) * camFactor;

                if (this.isPlaying) {
                    this.transition += dt * this.currentSpeedFactor * this.baseMorphSpeed; // Base speed ~0.5 transitions/sec
                    if (this.transition >= 1.3) {
                        this.transition = 0;
                        if (this.currentStep < this.steps.length - 1) { this.currentStep++; this.updateUI(); }
                        else { this.isPlaying = false; this.transition = 1; this.updateUI(); }
                    }
                } else {
                    if (this.transition < 1) this.transition += dt * this.currentSpeedFactor * this.baseMorphSpeed * 2; else this.transition = 1;
                }
                this.draw(); requestAnimationFrame((t) => this.loop(t));
            },

            draw: function () {
                const ctx = this.ctx; const w = this.canvas.width; const h = this.canvas.height;
                ctx.clearRect(0, 0, w, h);
                if (this.steps.length === 0) return;

                const curSnap = this.steps[this.currentStep];
                const prevSnap = this.currentStep > 0 ? this.steps[this.currentStep - 1] : curSnap;
                const layoutCur = this.layoutInOrder(curSnap.roots);
                const layoutPrev = this.layoutInOrder(prevSnap.roots);

                // Removed auto-fit from draw loop to allow manual pan/zoom

                let t = Math.min(Math.max(this.transition, 0), 1);
                const easeT = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                const prevMap = new Map();
                this.flatten(layoutPrev).forEach(n => prevMap.set(n.id, { x: n.x, y: n.y }));

                ctx.save();
                ctx.translate(w / 2, h / 2); ctx.scale(this.camera.scale, this.camera.scale); ctx.translate(-this.camera.x, -this.camera.y);

                layoutCur.forEach(r => this.drawLinksRec(r, prevMap, easeT));
                this.vizNodes = [];
                layoutCur.forEach(r => this.drawNodesRec(r, prevMap, easeT));
                ctx.restore();
            },

            layoutInOrder: function (roots) {
                const clones = roots.map(r => r.clone());
                let counter = 0; const X_SPACING = 70;
                const traverse = (n, depth) => {
                    if (!n) return;
                    traverse(n.left, depth + 1);
                    n.x = counter * X_SPACING; n.y = 50 + depth * this.levelGap;
                    counter++;
                    traverse(n.right, depth + 1);
                };
                clones.forEach(root => { traverse(root, 0); counter += 1; });
                return clones;
            },

            drawLinksRec: function (node, prevMap, t) {
                if (!node) return;
                let cx = node.x, cy = node.y;
                const p = prevMap.get(node.id);
                if (p) { cx = p.x + (node.x - p.x) * t; cy = p.y + (node.y - p.y) * t; }

                if (!node.left) this.drawNull(cx, cy, 'L');
                if (!node.right) this.drawNull(cx, cy, 'R');

                const line = (child) => {
                    let chx = child.x, chy = child.y;
                    const cp = prevMap.get(child.id);
                    if (cp) { chx = cp.x + (child.x - cp.x) * t; chy = cp.y + (child.y - cp.y) * t; }
                    this.ctx.beginPath(); this.ctx.moveTo(cx, cy); this.ctx.lineTo(chx, chy);
                    this.ctx.strokeStyle = COLORS.EDGE; this.ctx.lineWidth = 3; this.ctx.stroke();
                };
                if (node.left) { line(node.left); this.drawLinksRec(node.left, prevMap, t); }
                if (node.right) { line(node.right); this.drawLinksRec(node.right, prevMap, t); }
            },

            drawNull: function (x, y, dir) {
                const dx = dir === 'L' ? -15 : 15; const dy = 25;
                this.ctx.beginPath(); this.ctx.moveTo(x, y + this.nodeRadius / 2); this.ctx.lineTo(x + dx, y + this.nodeRadius + dy);
                this.ctx.strokeStyle = COLORS.EDGE; this.ctx.lineWidth = 3; this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(x + dx - 5, y + this.nodeRadius + dy); this.ctx.lineTo(x + dx + 5, y + this.nodeRadius + dy); this.ctx.stroke();
            },

            drawNodesRec: function (n, prevMap, t) {
                if (!n) return;
                let cx = n.x, cy = n.y;
                const p = prevMap.get(n.id);
                if (p) { cx = p.x + (n.x - p.x) * t; cy = p.y + (n.y - p.y) * t; } /* else this.ctx.globalAlpha = t; */

                this.vizNodes.push({ x: cx, y: cy, val: n.val });

                const ctx = this.ctx;
                let fill = n.origin === 1 ? COLORS.FILL1 : COLORS.FILL2;
                let stroke = n.origin === 1 ? COLORS.STROKE1 : COLORS.STROKE2;

                let textColor = COLORS.TEXT_VAL;

                if (n.highlight === 'compare') {
                    fill = COLORS.COMPARE_FILL;
                    stroke = COLORS.COMPARE_STROKE;
                }
                else if (n.highlight === 'minimum') {
                    fill = COLORS.MINIMUM;
                    stroke = COLORS.MINIMUM;
                }
                else if (n.highlight === 'delete-target') {
                    fill = COLORS.DELETE;
                    stroke = COLORS.DELETE;
                    textColor = '#FFFFFF';
                }

                ctx.beginPath(); ctx.arc(cx, cy, this.nodeRadius, 0, 2 * Math.PI);
                ctx.fillStyle = fill; ctx.fill(); ctx.strokeStyle = stroke; ctx.lineWidth = 3; ctx.stroke();

                if (n.highlight === 'compare' && this.steps[this.currentStep].msg.includes('Swapping children')) {
                    this.drawRotationArrow(cx, cy);
                }

                ctx.fillStyle = textColor;
                ctx.font = '22px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(n.val, cx, cy + 1);

                const bx = cx + this.nodeRadius - 5; const by = cy - this.nodeRadius + 5;
                ctx.beginPath(); ctx.arc(bx, by, 10, 0, 2 * Math.PI);
                ctx.fillStyle = n.highlightWeights ? COLORS.WEIGHT_HIGHLIGHT : '#ffffff';
                ctx.fill();
                ctx.strokeStyle = n.highlightWeights ? COLORS.WEIGHT_HIGHLIGHT : COLORS.WEIGHT_STROKE;
                ctx.lineWidth = 1; ctx.stroke();
                ctx.fillStyle = n.highlightWeights ? '#ffffff' : COLORS.WEIGHT_TEXT;
                ctx.font = 'bold 11px Arial'; ctx.fillText(n.weight, bx, by + 1);

                ctx.globalAlpha = 1;
                this.drawNodesRec(n.left, prevMap, t); this.drawNodesRec(n.right, prevMap, t);
            },

            drawRotationArrow: function (x, y) {
                const ctx = this.ctx;
                const r = this.nodeRadius + 15;
                const startX = x - r; const startY = y + 10;
                const endX = x + r; const endY = y + 10;
                const cpX = x; const cpY = y + 10 + 60;

                ctx.beginPath();
                ctx.strokeStyle = COLORS.ARROW; ctx.lineWidth = 3;
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                ctx.stroke();

                const size = 14;
                // End Arrow
                const vecEndX = endX - cpX; const vecEndY = endY - cpY;
                const angleEnd = Math.atan2(vecEndY, vecEndX);
                ctx.save(); ctx.translate(endX, endY); ctx.rotate(angleEnd);
                ctx.beginPath(); ctx.fillStyle = COLORS.ARROW;
                ctx.moveTo(0, 0); ctx.lineTo(-size, -size / 2.5); ctx.lineTo(-size, size / 2.5); ctx.fill();
                ctx.restore();

                // Start Arrow
                const vecStartX = startX - cpX; const vecStartY = startY - cpY;
                const angleStart = Math.atan2(vecStartY, vecStartX);
                ctx.save(); ctx.translate(startX, startY); ctx.rotate(angleStart);
                ctx.beginPath(); ctx.fillStyle = COLORS.ARROW;
                ctx.moveTo(0, 0); ctx.lineTo(-size, -size / 2.5); ctx.lineTo(-size, size / 2.5); ctx.fill();
                ctx.restore();
            },

            flatten: function (roots) {
                let list = [];
                const t = (n) => { if (!n) return; list.push(n); t(n.left); t(n.right); };
                roots.forEach(t);
                return list;
            }
        };
        app.init();
    </script>
</body>

</html>