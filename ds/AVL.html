<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Visualizer</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: #f5f5f5;
            --border-color: #ddd;

            /* UI Colors */
            --btn-insert: #2E7D32;
            --btn-delete: #c62828;
            --btn-search: #1668BD;
            --btn-undo: #6A1B9A;
            --btn-gray: #546E7A;
            --btn-random: #EF6C00;
            --btn-demo: #7B1FA2;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            user-select: none;
        }

        header {
            padding: 10px 20px;
            background-color: var(--panel-bg);
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .gui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            color: #222;
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .sub-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 0.9rem;
            color: #555;
            vertical-align: middle;
        }

        input[type="number"] {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #999;
            background: #fff;
            color: #000;
            width: 60px;
            text-align: center;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100px;
            cursor: pointer;
        }

        button {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: default;
            font-weight: 600;
            color: white;
            transition: filter 0.2s, transform 0.1s;
            font-size: 0.85rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-insert {
            background-color: var(--btn-insert);
        }

        .btn-delete {
            background-color: var(--btn-delete);
        }

        .btn-search {
            background-color: var(--btn-search);
        }

        .btn-undo {
            background-color: var(--btn-undo);
        }

        .btn-clear {
            background-color: var(--btn-gray);
        }

        .btn-random {
            background-color: var(--btn-random);
        }

        .btn-demo {
            background-color: var(--btn-demo);
        }

        .btn-pause {
            background-color: #455A64;
            width: 80px;
        }

        .btn-help {
            background-color: #607D8B;
            font-size: 1.1rem;
            padding: 4px 10px;
            border-radius: 50%;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--bg-color);
            cursor: default;
            min-height: 0;
        }

        #canvas-container:active {
            cursor: default;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            -webkit-tap-highlight-color: transparent;
        }

        #legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.8rem;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            color: #333;
        }

        .dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        .line-icon {
            width: 15px;
            height: 3px;
            border-radius: 2px;
        }

        .arrow-icon {
            font-size: 16px;
            font-weight: bold;
            color: #D50000;
        }

        #status-bar {
            padding: 8px 2px 0px 0px;
            background-color: var(--panel-bg);
            font-size: 0.85rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            color: #555;
            flex-shrink: 0;
        }

        #status-text {
            font-weight: bold;
            color: #222;
        }

        #author {
            width: 100%;
            background: #f4f7f6;
            font-size: 0.75em;
            color: #777;
            text-align: center;
            line-height: 2.5;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        h2 {
            color: #2E7D32;
            margin-top: 0;
        }

        h3 {
            color: #1668BD;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-top: 15px;
        }

        p,
        li {
            font-size: 0.95rem;
            line-height: 1.5;
            color: #333;
        }

        .complexity {
            font-family: monospace;
            background: #eee;
            padding: 2px 5px;
            border-radius: 4px;
            color: #c62828;
        }

        .node-sample {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #B0F9B0;
            border: 1px solid #B0F9B0;
            text-align: center;
            line-height: 30px;
            position: relative;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }

        .node-val {
            color: #D50000;
            font-size: 12px;
        }

        .node-weight {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 10px;
            color: #1565C0;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            padding: 1px 3px;
        }
    </style>
</head>

<body>

    <header>
        <div class="header-top">
            <h1>Adelson-Velskii & Landis (AVL) Tree Visualizer</h1>
            <button class="btn-help" onclick="app.toggleModal()" title="Help / Algorithms">?</button>
        </div>
        <div class="gui">
            <div class="controls">
                <input type="number" id="inputValue" placeholder="#" title="Enter a number"
                    onkeydown="if(event.key==='Enter') app.handleInsert()">
                <button class="btn-insert" title="Insert value" onclick="app.handleInsert()">Insert</button>
                <button class="btn-delete" title="Delete value" onclick="app.handleDelete()">Delete</button>
                <button class="btn-search" title="Search value" onclick="app.handleSearch()">Search</button>

                <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

                <button class="btn-demo" title="Demo: Right Rotation (Line)"
                    onclick="app.handleDemoSimpleRight()">Right</button>
                <button class="btn-demo" title="Demo: Double Left-Right Rotation (Zig-Zag)"
                    onclick="app.handleDemoDoubleLeftRight()">Left-Right</button>
                <button class="btn-demo" title="Demo: Left Rotation (Line)"
                    onclick="app.handleDemoSimpleLeft()">Left</button>
                <button class="btn-demo" title="Demo: Double Right-Left Rotation (Zig-Zag)"
                    onclick="app.handleDemoDoubleRightLeft()">Right-Left</button>

                <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

                <button class="btn-random" title="Generate random tree" onclick="app.handleRandomTree()">Build
                    Random</button>

                <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

                <button class="btn-undo" title="Undo last action" onclick="app.handleUndo()" id="btnUndo"
                    disabled>Undo</button>
                <button class="btn-clear" title="Clear the tree" onclick="app.handleClear()">Clear</button>
            </div>
            <div class="sub-controls">
                <label for="speedSlider">Slowdown:</label>
                <label title="Slide right to slow down the animation">
                    <input type="range" id="speedSlider" min="1" max="5" step="0.1" value="1"
                        oninput="app.updateSpeed()">
                </label>
                <button class="btn-pause" title="Pause animation" onclick="app.togglePause()"
                    id="btnPause">Pause</button>
            </div>
        </div>
        <div id="status-bar">
            <span id="status-text">Ready. Use Mouse Wheel to Zoom, Click & Drag to Pan.</span>
        </div>
    </header>

    <div id="canvas-container">
        <canvas id="treeCanvas"></canvas>
        <div id="legend">
            <div class="legend-item">
                <div class="node-sample"><span class="node-val">V</span><span class="node-weight">H</span></div>&nbsp;
                Value / Height
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#B0F9B0; border:2px solid #B0F9B0"></div>&nbsp; Balanced Node
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#CC99FF; border:1px solid #fff"></div>&nbsp; Checking Balance
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#4CAF50; border:1px solid #fff"></div>&nbsp; New Node
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#FF5722; border:1px solid #fff"></div>&nbsp; Pivot (Orange)
            </div>
            <div class="legend-item">
                <div class="dot" style="background:#FFC107; border:1px solid #fff"></div>&nbsp; Child (Yellow)
            </div>
            <div class="legend-item">
                <div class="arrow-icon">&#8635;</div>&nbsp; Rotation
            </div>
            <div class="legend-item">
                <div class="line-icon" style="background:#1668BD;"></div>&nbsp; Null Link
            </div>
        </div>
    </div>

    <div id="author">Pepe Gallardo. Dpto. Lenguajes y Ciencias de la Computación. Universidad de Málaga</div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="app.toggleModal()">&times;</span>
            <h2>AVL Tree Algorithms</h2>

            <h3>AVL Property</h3>
            <p>An AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and
                right subtrees cannot be more than 1 for all nodes.</p>
            <p><strong>Balance Factor</strong> = Height(Left) - Height(Right). Must be in {-1, 0, 1}.</p>

            <h3>Complexity</h3>
            <p>Since the tree is always balanced, operations are guaranteed to be logarithmic.</p>
            <ul>
                <li>Search: <span class="complexity">O(log n)</span></li>
                <li>Insert: <span class="complexity">O(log n)</span></li>
                <li>Delete: <span class="complexity">O(log n)</span></li>
            </ul>

            <h3>Rotations</h3>
            <p>Used to restore balance after insertion or deletion. There are 4 cases:</p>
            <ul>
                <li><strong>Left Rotation (L):</strong> Right child moves up.</li>
                <li><strong>Right Rotation (R):</strong> Left child moves up.</li>
                <li><strong>Left-Right (LR):</strong> Left child rotates left, then node rotates right.</li>
                <li><strong>Right-Left (RL):</strong> Right child rotates right, then node rotates left.</li>
            </ul>
        </div>
    </div>

    <script>
        const COLORS = {
            DEFAULT: '#B0F9B0',
            STROKE: '#B0F9B0',
            TEXT: '#CC0000',
            EDGE: '#1668BD',
            NEW: '#4CAF50',
            VISIT: '#2196F3',
            PIVOT: '#FF5722',
            CHILD: '#FFC107',
            FOUND: '#00E676',
            DELETE: '#F44336',
            NULL_LINK: '#1668BD',
            ARROW: '#D50000',
            PATH_HIGHLIGHT: '#AA00FF', // Violet for balance checking
            CHECK: '#CC99FF' // Violet for balance checking
        };

        class Node {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.height = 1;
                this.id = Node.nextId++;
                this.color = COLORS.DEFAULT;
                this.x = 0; this.y = 0;
            }
            clone() {
                const newNode = new Node(this.value);
                newNode.height = this.height; newNode.id = this.id; newNode.color = this.color;
                newNode.x = this.x; newNode.y = this.y;
                if (this.left) newNode.left = this.left.clone();
                if (this.right) newNode.right = this.right.clone();
                return newNode;
            }
        }
        Node.nextId = 0;

        class AVLTree {
            constructor() { this.root = null; this.history = []; }
            saveToHistory() {
                const state = this.root ? this.root.clone() : null;
                this.history.push(state);
                if (this.history.length > 25) this.history.shift();
            }
            restoreFromHistory() {
                if (this.history.length === 0) return null;
                this.root = this.history.pop(); return this.root;
            }
            resetVisuals(node) {
                if (!node) return;
                node.color = COLORS.DEFAULT;
                this.resetVisuals(node.left); this.resetVisuals(node.right);
            }
            cleanUp(recordSnapshot) {
                this.resetVisuals(this.root);
                recordSnapshot(this.root, null, { text: 'Ready.' });
            }
            getHeight(node) { return node ? node.height : 0; }
            updateHeight(node) { node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right)); }
            getBalance(node) { return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0; }

            rightRotate(y, record) {
                const x = y.left; const T2 = x.right;
                const pY = y.color; const pX = x.color;
                y.color = COLORS.PIVOT; x.color = COLORS.CHILD;
                record(this.root, null, {
                    pause: true,
                    text: `Right Rotation: ${y.value} moves down, ${x.value} moves up.`,
                    rotation: { id: y.id, dir: 'CW' }
                });
                x.right = y; y.left = T2;
                this.updateHeight(y); this.updateHeight(x);
                y.color = pY; x.color = pX;
                return x;
            }
            leftRotate(x, record) {
                const y = x.right; const T2 = y.left;
                const pX = x.color; const pY = y.color;
                x.color = COLORS.PIVOT; y.color = COLORS.CHILD;
                record(this.root, null, {
                    pause: true,
                    text: `Left Rotation: ${x.value} moves down, ${y.value} moves up.`,
                    rotation: { id: x.id, dir: 'CCW' }
                });
                y.left = x; x.right = T2;
                this.updateHeight(x); this.updateHeight(y);
                x.color = pX; y.color = pY;
                return y;
            }
            insert(value, recordSnapshot) {
                this.saveToHistory();
                const _insert = (node) => {
                    if (node) recordSnapshot(this.root, { val: value, targetId: node.id }, { text: `Finding place for ${value}...` });
                    if (!node) { const nn = new Node(value); nn.color = COLORS.NEW; return nn; }
                    if (value < node.value) {
                        if (!node.left) recordSnapshot(this.root, null, { text: `Reached null link (Left of ${node.value})`, activeNull: { nodeId: node.id, side: 'L', color: COLORS.VISIT } });
                        node.left = _insert(node.left);
                    } else if (value > node.value) {
                        if (!node.right) recordSnapshot(this.root, null, { text: `Reached null link (Right of ${node.value})`, activeNull: { nodeId: node.id, side: 'R', color: COLORS.VISIT } });
                        node.right = _insert(node.right);
                    } else return node;

                    this.updateHeight(node);
                    const balance = this.getBalance(node);

                    // --- Highlight Check Phase ---
                    const prevColor = node.color;
                    node.color = COLORS.CHECK;
                    recordSnapshot(this.root, null, { text: `Backtracking: Checking balance of ${node.value} (BF: ${balance})` });
                    // -----------------------------

                    if (balance > 1 && value < node.left.value) {
                        recordSnapshot(this.root, null, { pause: true, text: "Unbalanced: Left-Left Case (Straight Line)", path: [node.id, node.left.id, node.left.left.id] });
                        node.color = prevColor;
                        return this.rightRotate(node, recordSnapshot);
                    }
                    if (balance < -1 && value > node.right.value) {
                        recordSnapshot(this.root, null, { pause: true, text: "Unbalanced: Right-Right Case (Straight Line)", path: [node.id, node.right.id, node.right.right.id] });
                        node.color = prevColor;
                        return this.leftRotate(node, recordSnapshot);
                    }
                    if (balance > 1 && value > node.left.value) {
                        recordSnapshot(this.root, null, { pause: true, text: "Unbalanced: Left-Right Case (Zig-Zag)", path: [node.id, node.left.id, node.left.right.id] });
                        node.color = prevColor;
                        node.left = this.leftRotate(node.left, recordSnapshot);
                        return this.rightRotate(node, recordSnapshot);
                    }
                    if (balance < -1 && value < node.right.value) {
                        recordSnapshot(this.root, null, { pause: true, text: "Unbalanced: Right-Left Case (Zig-Zag)", path: [node.id, node.right.id, node.right.left.id] });
                        node.color = prevColor;
                        node.right = this.rightRotate(node.right, recordSnapshot);
                        return this.leftRotate(node, recordSnapshot);
                    }
                    node.color = prevColor;
                    return node;
                };
                this.root = _insert(this.root);
                recordSnapshot(this.root, null, { text: `Inserted ${value}` });
                this.cleanUp(recordSnapshot);
            }
            delete(value, recordSnapshot) {
                this.saveToHistory();
                let found = false;
                const _delete = (node, val, showSearch = true) => {
                    if (!node) return node;
                    if (showSearch) {
                        node.color = COLORS.VISIT;
                        recordSnapshot(this.root, null, { text: `Searching ${val}...` });
                        node.color = COLORS.DEFAULT;
                    }
                    if (val < node.value) {
                        if (showSearch && !node.left) recordSnapshot(this.root, null, { text: `${val} not found (Left of ${node.value})`, activeNull: { nodeId: node.id, side: 'L', color: COLORS.DELETE } });
                        node.left = _delete(node.left, val, showSearch);
                    } else if (val > node.value) {
                        if (showSearch && !node.right) recordSnapshot(this.root, null, { text: `${val} not found (Right of ${node.value})`, activeNull: { nodeId: node.id, side: 'R', color: COLORS.DELETE } });
                        node.right = _delete(node.right, val, showSearch);
                    } else {
                        found = true;
                        if (!node.left || !node.right) {
                            node.color = COLORS.DELETE;
                            recordSnapshot(this.root, null, { pause: true, text: `Deleting ${node.value}` });
                            const temp = node.left ? node.left : node.right;
                            node = temp ? temp : null;
                        } else {
                            let temp = node.right;
                            recordSnapshot(this.root, null, { text: "Finding successor (right side)..." });
                            while (temp.left) {
                                temp.color = COLORS.VISIT;
                                recordSnapshot(this.root, null, { text: `Visiting: ${temp.value}` });
                                temp.color = COLORS.DEFAULT;
                                temp = temp.left;
                            }
                            recordSnapshot(this.root, null, { text: `Successor found (Left of ${temp.value} is null)`, activeNull: { nodeId: temp.id, side: 'L', color: COLORS.VISIT } });
                            node.color = COLORS.DELETE; temp.color = COLORS.PIVOT;
                            recordSnapshot(this.root, null, { pause: true, text: `Successor ${temp.value} replaces ${node.value}`, arrows: [{ from: temp.id, to: node.id }] });
                            node.value = temp.value;
                            node.color = COLORS.NEW; temp.color = COLORS.DEFAULT;
                            recordSnapshot(this.root, null, { text: `Value replaced` });
                            node.right = _delete(node.right, temp.value, false);
                        }
                    }
                    if (!node) return node;

                    this.updateHeight(node);
                    const balance = this.getBalance(node);

                    // --- Highlight Check Phase ---
                    const prevColor = node.color;
                    node.color = COLORS.CHECK;
                    recordSnapshot(this.root, null, { text: `Backtracking: Checking balance of ${node.value} (BF: ${balance})` });
                    // -----------------------------

                    if (balance > 1 && this.getBalance(node.left) >= 0) {
                        // Left Left Case
                        const grandchild = node.left.left ? node.left.left : node.left.right; // Visual fallback
                        recordSnapshot(this.root, null, { pause: true, text: "Unbalanced: Left-Left Case (Straight Line)", path: [node.id, node.left.id, grandchild ? grandchild.id : node.left.id] });
                        node.color = prevColor;
                        return this.rightRotate(node, recordSnapshot);
                    }
                    if (balance > 1 && this.getBalance(node.left) < 0) {
                        // Left Right Case
                        recordSnapshot(this.root, null, { pause: true, text: "Unbalanced: Left-Right Case (Zig-Zag)", path: [node.id, node.left.id, node.left.right.id] });
                        node.left = this.leftRotate(node.left, recordSnapshot);
                        node.color = prevColor;
                        return this.rightRotate(node, recordSnapshot);
                    }
                    if (balance < -1 && this.getBalance(node.right) <= 0) {
                        // Right Right Case
                        const grandchild = node.right.right ? node.right.right : node.right.left; // Visual fallback
                        recordSnapshot(this.root, null, { pause: true, text: "Unbalanced: Right-Right Case (Straight Line)", path: [node.id, node.right.id, grandchild ? grandchild.id : node.right.id] });
                        node.color = prevColor;
                        return this.leftRotate(node, recordSnapshot);
                    }
                    if (balance < -1 && this.getBalance(node.right) > 0) {
                        // Right Left Case
                        recordSnapshot(this.root, null, { pause: true, text: "Unbalanced: Right-Left Case (Zig-Zag)", path: [node.id, node.right.id, node.right.left.id] });
                        node.right = this.rightRotate(node.right, recordSnapshot);
                        node.color = prevColor;
                        return this.leftRotate(node, recordSnapshot);
                    }
                    node.color = prevColor;
                    return node;
                };
                this.root = _delete(this.root, value);
                if (found) recordSnapshot(this.root, null, { text: `Finished` }); else recordSnapshot(this.root, null, { text: `Value ${value} not found` });
                this.cleanUp(recordSnapshot);
            }
            search(value, recordSnapshot) {
                let current = this.root;
                let found = false;
                if (!current) { recordSnapshot(null, null, { text: "Tree is empty" }); return; }
                while (current) {
                    current.color = (current.value === value) ? COLORS.FOUND : COLORS.VISIT;
                    const txt = current.value === value ? `Found!` : `Visiting ${current.value}...`;
                    recordSnapshot(this.root, null, { text: txt, pause: (current.value === value) });
                    if (current.value === value) { found = true; break; }
                    else if (value < current.value) {
                        if (!current.left) recordSnapshot(this.root, null, { text: `${value} not found (Left of ${current.value})`, pause: true, activeNull: { nodeId: current.id, side: 'L', color: COLORS.DELETE } });
                        current = current.left;
                    } else {
                        if (!current.right) recordSnapshot(this.root, null, { text: `${value} not found (Right of ${current.value})`, pause: true, activeNull: { nodeId: current.id, side: 'R', color: COLORS.DELETE } });
                        current = current.right;
                    }
                }
                if (!found) recordSnapshot(this.root, null, { text: "Not found." });
                this.cleanUp(recordSnapshot);
            }
        }

        class Visualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.camera = { scale: 1, targetScale: 1, x: 0, targetX: 0, y: 0, targetY: 0 };
                this.nodeRadius = 28;
                this.levelHeight = 70;
                this.snapshots = [];
                this.currentSnapshotIndex = -1;
                this.lastDrawnNodes = [];
                this.hoveredNode = null;
                this.state = 'IDLE';
                this.isPaused = false;
                this.morphProgress = 0;
                this.baseMorphSpeed = 3.0; // 3.0 units/second (~0.05 per frame at 60fps)
                this.currentSpeedFactor = 1;
                this.pauseTimer = 0;

                // --- Navigation State (Zoom/Pan) ---
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.initialCamera = { x: 0, y: 0 };
                // ------------------------------------

                this.resize();

                // --- Event Listeners ---
                window.addEventListener('resize', () => this.resize());

                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.onMouseUp());
                this.canvas.addEventListener('mouseleave', () => this.onMouseLeave());
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
                this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.onTouchEnd(e));

                // ...

                window.onclick = (e) => {
                    if (e.target == document.getElementById('helpModal')) app.toggleModal();
                }

                this.lastTime = 0;
                requestAnimationFrame(t => this.loop(t));
            }

            // --- Mouse Event Handlers for Navigation ---

            onMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                // 1. Check if user clicked on a node
                for (let n of this.lastDrawnNodes) {
                    const sx = (n.x * this.camera.scale) + this.camera.x;
                    const sy = (n.y * this.camera.scale) + this.camera.y;
                    const r = this.nodeRadius * this.camera.scale;
                    if (Math.hypot(mx - sx, my - sy) < r) {
                        document.getElementById('inputValue').value = n.value;
                        // document.getElementById('inputValue').focus();
                        return;
                    }
                }

                // 2. Start Pan
                this.isDragging = true;
                this.dragStart = { x: mx, y: my };
                this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };
                this.canvas.style.cursor = 'grabbing'; // Solo aquí aparece la mano cerrada
            }

            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                this.checkNodeHover(mx, my);

                if (this.isDragging) {
                    this.canvas.style.cursor = 'grabbing';
                } else if (this.hoveredNode) {
                    this.canvas.style.cursor = 'pointer';
                } else {
                    this.canvas.style.cursor = 'default';
                }

                if (!this.isDragging) return;

                const dx = mx - this.dragStart.x;
                const dy = my - this.dragStart.y;

                this.camera.targetX = this.initialCamera.x + dx;
                this.camera.targetY = this.initialCamera.y + dy;
            }

            onMouseUp() {
                this.isDragging = false;
                this.canvas.style.cursor = this.hoveredNode ? 'pointer' : 'default';
            }

            onMouseLeave() {
                this.isDragging = false;
                this.canvas.style.cursor = 'default';
            }

            onWheel(e) {
                e.preventDefault();
                const zoomIntensity = 0.001;
                const scroll = e.deltaY;
                let newScale = this.camera.targetScale * (1 - scroll * zoomIntensity);
                newScale = Math.min(Math.max(0.2, newScale), 5);

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldX = (mouseX - this.camera.targetX) / this.camera.targetScale;
                const worldY = (mouseY - this.camera.targetY) / this.camera.targetScale;

                this.camera.targetScale = newScale;
                this.camera.targetX = mouseX - worldX * newScale;
                this.camera.targetY = mouseY - worldY * newScale;
            }

            // --- Touch Event Handlers for Mobile ---

            getTouchDistance(touches) {
                return Math.hypot(
                    touches[0].clientX - touches[1].clientX,
                    touches[0].clientY - touches[1].clientY
                );
            }

            onTouchStart(e) {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = touch.clientX - rect.left;
                    const my = touch.clientY - rect.top;

                    for (let n of this.lastDrawnNodes) {
                        const sx = (n.x * this.camera.scale) + this.camera.x;
                        const sy = (n.y * this.camera.scale) + this.camera.y;
                        const r = this.nodeRadius * this.camera.scale;
                        if (Math.hypot(mx - sx, my - sy) < r) {
                            document.getElementById('inputValue').value = n.value;
                            // document.getElementById('inputValue').focus();
                            return;
                        }
                    }

                    this.isDragging = true;
                    this.dragStart = { x: mx, y: my };
                    this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };

                } else if (e.touches.length === 2) {
                    this.isDragging = false;
                    this.initialPinchDist = this.getTouchDistance(e.touches);
                    this.initialScale = this.camera.targetScale;
                }
            }

            onTouchMove(e) {
                e.preventDefault();

                if (e.touches.length === 1 && this.isDragging) {
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = touch.clientX - rect.left;
                    const my = touch.clientY - rect.top;

                    const dx = mx - this.dragStart.x;
                    const dy = my - this.dragStart.y;

                    this.camera.targetX = this.initialCamera.x + dx;
                    this.camera.targetY = this.initialCamera.y + dy;

                } else if (e.touches.length === 2) {
                    const currentDist = this.getTouchDistance(e.touches);

                    if (this.initialPinchDist > 0) {
                        const scaleFactor = currentDist / this.initialPinchDist;

                        let newScale = this.initialScale * scaleFactor;
                        newScale = Math.min(Math.max(0.2, newScale), 5); // Límites

                        const rect = this.canvas.getBoundingClientRect();
                        const centerX = rect.width / 2;
                        const centerY = rect.height / 2;

                        const worldCenterX = (centerX - this.camera.targetX) / this.camera.targetScale;
                        const worldCenterY = (centerY - this.camera.targetY) / this.camera.targetScale;

                        this.camera.targetScale = newScale;
                        this.camera.targetX = centerX - worldCenterX * newScale;
                        this.camera.targetY = centerY - worldCenterY * newScale;
                    }
                }
            }

            onTouchEnd(e) {
                this.isDragging = false;
                this.initialPinchDist = 0;
                this.hoveredNode = null; 
            }

            checkNodeHover(mx, my) {
                let found = null;
                for (let n of this.lastDrawnNodes) {
                    const sx = (n.x * this.camera.scale) + this.camera.x;
                    const sy = (n.y * this.camera.scale) + this.camera.y;
                    const r = this.nodeRadius * this.camera.scale;

                    if (Math.hypot(mx - sx, my - sy) < r) {
                        found = n;
                        break;
                    }
                }
                this.hoveredNode = found;
            }

            resize() {
                this.canvas.width = document.getElementById('canvas-container').offsetWidth;
                this.canvas.height = document.getElementById('canvas-container').offsetHeight;
                if (this.snapshots.length > 0) {
                    const snap = this.snapshots[this.currentSnapshotIndex >= 0 ? this.currentSnapshotIndex : 0];
                    if (snap && snap.root) {
                        this.fitTreeBounds(snap.root);
                        this.camera.scale = this.camera.targetScale;
                        this.camera.x = this.camera.targetX;
                        this.camera.y = this.camera.targetY;
                    }
                }
            }
            getTreeBounds(root) {
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                let hasNodes = false;
                const traverse = (n) => {
                    if (!n) return;
                    hasNodes = true;
                    minX = Math.min(minX, n.x - this.nodeRadius);
                    maxX = Math.max(maxX, n.x + this.nodeRadius);
                    minY = Math.min(minY, n.y - this.nodeRadius);
                    maxY = Math.max(maxY, n.y + this.nodeRadius);
                    traverse(n.left); traverse(n.right);
                };
                traverse(root);
                return { minX, maxX, minY, maxY, hasNodes };
            }
            fitTreeBounds(root) {
                const bounds = this.getTreeBounds(root);
                this.fitBoundsToScreen(bounds);
            }
            fitBoundsToScreen(bounds) {
                if (!bounds.hasNodes) {
                    this.camera.targetScale = 1; this.camera.targetX = this.canvas.width / 2; this.camera.targetY = 100;
                    return;
                }
                const padding = 150;
                const treeW = bounds.maxX - bounds.minX + padding;
                const treeH = bounds.maxY - bounds.minY + padding;
                const scale = Math.min(1.3, Math.min(this.canvas.width / treeW, this.canvas.height / treeH));
                const treeCX = (bounds.minX + bounds.maxX) / 2;
                const treeCY = (bounds.minY + bounds.maxY) / 2;
                this.camera.targetScale = scale;
                this.camera.targetX = (this.canvas.width / 2) - (treeCX * scale);
                this.camera.targetY = (this.canvas.height / 2) - (treeCY * scale);
                if (treeH * scale < this.canvas.height * 0.7) this.camera.targetY = 100;
            }
            setSpeed(val) { this.currentSpeedFactor = 1 / val; }
            togglePause() { this.isPaused = !this.isPaused; return this.isPaused; }

            calculateLayout(root) {
                if (!root) return;
                let order = 0;
                const traverse = (node, depth) => {
                    if (!node) return;
                    traverse(node.left, depth + 1);
                    node.x = order * (this.nodeRadius * 2.5);
                    node.y = depth * this.levelHeight + 80;
                    order++;
                    traverse(node.right, depth + 1);
                };
                traverse(root, 0);
                const width = (order > 0 ? order - 1 : 0) * (this.nodeRadius * 2.5);
                const offset = width / 2;
                const centerTree = (node) => { if (!node) return; node.x -= offset; centerTree(node.left); centerTree(node.right); };
                centerTree(root);
            }
            enqueueOperation(snapshots) {
                if (snapshots.length === 0) return;
                snapshots.forEach(s => this.calculateLayout(s.root));
                let gMinX = Infinity, gMaxX = -Infinity, gMinY = Infinity, gMaxY = -Infinity;
                let hasNodes = false;
                const allFrames = (this.snapshots.length > 0) ? [this.snapshots[this.snapshots.length - 1], ...snapshots] : snapshots;
                allFrames.forEach(s => {
                    const b = this.getTreeBounds(s.root);
                    if (b.hasNodes) {
                        hasNodes = true;
                        gMinX = Math.min(gMinX, b.minX); gMaxX = Math.max(gMaxX, b.maxX);
                        gMinY = Math.min(gMinY, b.minY); gMaxY = Math.max(gMaxY, b.maxY);
                    }
                });
                this.fitBoundsToScreen({ minX: gMinX, maxX: gMaxX, minY: gMinY, maxY: gMaxY, hasNodes: hasNodes });
                if (this.snapshots.length === 0) {
                    this.snapshots.push(snapshots[0]); this.currentSnapshotIndex = 0; snapshots.shift();
                }
                if (snapshots.length > 0) { this.pendingSnapshots = snapshots; this.state = 'CAMERA'; }
            }
            loop(timestamp) {
                if (!this.lastTime) this.lastTime = timestamp;

                const dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;

                if (!this.isPaused) {
                    this.update(Math.min(dt, 0.1));
                }

                this.draw();
                requestAnimationFrame(t => this.loop(t));
            }
            update(dt) {
                const camSpeed = 10.0;

                const factor = 1 - Math.exp(-camSpeed * dt);

                this.camera.scale += (this.camera.targetScale - this.camera.scale) * factor;
                this.camera.x += (this.camera.targetX - this.camera.x) * factor;
                this.camera.y += (this.camera.targetY - this.camera.y) * factor;

                if (this.state === 'CAMERA') {
                    const dist = Math.hypot(this.camera.x - this.camera.targetX, this.camera.y - this.camera.targetY);
                    if (dist < 5 && Math.abs(this.camera.scale - this.camera.targetScale) < 0.01) {
                        if (this.pendingSnapshots.length > 0) this.loadNextSnapshot();
                        else this.state = 'IDLE';
                    }

                } else if (this.state === 'MORPH') {
                    this.morphProgress += this.baseMorphSpeed * this.currentSpeedFactor * dt;

                    if (this.morphProgress >= 1) {
                        this.morphProgress = 1;
                        if (this.pauseAfterMorph) {
                            this.state = 'WAITING';
                            this.pauseTimer = 0.8 / this.currentSpeedFactor;
                        } else {
                            this.finalizeStep();
                        }
                    }

                } else if (this.state === 'WAITING') {
                    this.pauseTimer -= dt;
                    if (this.pauseTimer <= 0) this.finalizeStep();
                }
            }

            loadNextSnapshot() {
                const next = this.pendingSnapshots.shift();
                this.snapshots.push(next);
                if (next.meta && next.meta.text) document.getElementById('status-text').innerText = next.meta.text;
                this.state = 'MORPH';
                this.morphProgress = 0;
                this.pauseAfterMorph = (next.meta && next.meta.pause);
            }

            finalizeStep() {
                this.currentSnapshotIndex++;
                if (this.pendingSnapshots && this.pendingSnapshots.length > 0) this.loadNextSnapshot();
                else { this.state = 'IDLE'; document.getElementById('status-text').innerText = "Ready."; }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.translate((this.camera.x - this.canvas.width / 2), (this.camera.y - this.canvas.height / 2));
                this.ctx.translate(-this.camera.x, -this.camera.y);
                this.ctx.setTransform(this.camera.scale, 0, 0, this.camera.scale, this.camera.x, this.camera.y);

                if (this.snapshots.length === 0) { this.ctx.restore(); return; }

                const idx = this.currentSnapshotIndex;
                let nodesToDraw = [];
                let floatingNode = null;
                let arrowsToDraw = [];
                let activeNull = null;
                let currentMeta = null;

                if ((this.state === 'MORPH' || this.state === 'WAITING') && idx + 1 < this.snapshots.length) {
                    const snapA = this.snapshots[idx];
                    const snapB = this.snapshots[idx + 1];
                    const t = this.easeInOut(this.morphProgress);
                    nodesToDraw = this.interpolateTrees(snapA.root, snapB.root, t);

                    if (snapB.floating) {
                        const targetNodeB = this.findNode(snapB.root, snapB.floating.targetId);
                        let startX = targetNodeB ? targetNodeB.x : 0;
                        let startY = targetNodeB ? targetNodeB.y - 60 : 0;
                        if (snapA.floating) {
                            const prevTarget = this.findNode(snapA.root, snapA.floating.targetId);
                            if (prevTarget) { startX = prevTarget.x; startY = prevTarget.y; }
                        }
                        if (targetNodeB) {
                            const fx = startX + (targetNodeB.x - startX) * t;
                            const fy = startY + (targetNodeB.y - startY) * t;
                            floatingNode = { x: fx, y: fy, value: snapB.floating.val };
                        }
                    }
                    if (snapB.meta && snapB.meta.arrows) arrowsToDraw = snapB.meta.arrows;
                    currentMeta = (t > 0.5) ? snapB.meta : snapA.meta;
                } else {
                    const snap = this.snapshots[idx >= 0 ? idx : 0];
                    nodesToDraw = this.flattenTree(snap.root);
                    if (snap.meta && snap.meta.arrows) arrowsToDraw = snap.meta.arrows;
                    currentMeta = snap.meta;
                }

                if (currentMeta && currentMeta.activeNull) activeNull = currentMeta.activeNull;
                this.lastDrawnNodes = nodesToDraw;

                // 1. Edges
                this.ctx.beginPath();
                this.ctx.strokeStyle = COLORS.EDGE;
                this.ctx.lineWidth = 3;
                nodesToDraw.forEach(n => {
                    if (n.parentX !== undefined) { this.ctx.moveTo(n.parentX, n.parentY); this.ctx.lineTo(n.x, n.y); }
                });
                this.ctx.stroke();

                // 2. Rotation Path Line (Straight or Zig-Zag)
                if (currentMeta && currentMeta.path && currentMeta.path.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = COLORS.PATH_HIGHLIGHT;
                    this.ctx.lineWidth = 6;
                    let first = true;
                    for (let id of currentMeta.path) {
                        const n = nodesToDraw.find(node => node.id === id);
                        if (n) {
                            if (first) { this.ctx.moveTo(n.x, n.y); first = false; }
                            else { this.ctx.lineTo(n.x, n.y); }
                        }
                    }
                    this.ctx.stroke();
                }

                // 3. Null Links
                nodesToDraw.forEach(n => {
                    if (!n.hasLeft) {
                        const isActive = (activeNull && activeNull.nodeId === n.id && activeNull.side === 'L');
                        const col = isActive ? activeNull.color : COLORS.NULL_LINK;
                        this.drawNullLink(n.x, n.y, 'L', col, isActive);
                    }
                    if (!n.hasRight) {
                        const isActive = (activeNull && activeNull.nodeId === n.id && activeNull.side === 'R');
                        const col = isActive ? activeNull.color : COLORS.NULL_LINK;
                        this.drawNullLink(n.x, n.y, 'R', col, isActive);
                    }
                });

                // 4. Nodes
                nodesToDraw.forEach(n => this.drawNodeCircle(n.x, n.y, n.value, n.color || COLORS.DEFAULT, false, n.height));

                // 5. Rotation Arrows
                let rotMeta = currentMeta;
                let rotAlpha = 1;
                let useStaticCoords = false;
                let startRoot = null;

                if (this.state === 'MORPH' && idx + 1 < this.snapshots.length) {
                    const snapA = this.snapshots[idx];
                    if (snapA.meta && snapA.meta.rotation) {
                        rotMeta = snapA.meta;
                        startRoot = snapA.root;
                        useStaticCoords = true;
                        rotAlpha = Math.max(0, 1 - (this.morphProgress * 1.5));
                    }
                }

                if (rotMeta && rotMeta.rotation) {
                    let pivotNode = null;
                    let childNode = null;

                    if (useStaticCoords && startRoot) {
                        const currentPivot = nodesToDraw.find(n => n.color === COLORS.PIVOT);
                        const currentChild = nodesToDraw.find(n => n.color === COLORS.CHILD);

                        if (currentPivot && currentChild) {
                            pivotNode = this.findNode(startRoot, currentPivot.id);
                            childNode = this.findNode(startRoot, currentChild.id);
                        }
                    } else {
                        pivotNode = nodesToDraw.find(n => n.color === COLORS.PIVOT);
                        childNode = nodesToDraw.find(n => n.color === COLORS.CHILD);
                    }

                    if (pivotNode && childNode && rotAlpha > 0) {
                        this.ctx.save();
                        this.ctx.globalAlpha = rotAlpha;
                        this.drawRotationArrow(childNode.x, childNode.y, pivotNode.x, pivotNode.y, rotMeta.rotation.dir);
                        this.ctx.restore();
                    }
                }

                // 6. Generic Arrows
                if (arrowsToDraw.length > 0) {
                    this.ctx.strokeStyle = COLORS.ARROW; this.ctx.fillStyle = COLORS.ARROW; this.ctx.lineWidth = 3;
                    arrowsToDraw.forEach(arr => {
                        const n1 = nodesToDraw.find(n => n.id === arr.from);
                        const n2 = nodesToDraw.find(n => n.id === arr.to);
                        if (n1 && n2) this.drawStraightArrow(n1.x, n1.y, n2.x, n2.y);
                    });
                }

                // 7. Floating Node
                if (floatingNode) {
                    this.ctx.shadowBlur = 10; this.ctx.shadowColor = COLORS.NEW;
                    this.drawNodeCircle(floatingNode.x, floatingNode.y, floatingNode.value, COLORS.NEW, true);
                    this.ctx.shadowBlur = 0;
                }

                // 8. Tooltip for Balance Factor
                if (this.hoveredNode) {
                    const snap = this.snapshots[this.currentSnapshotIndex >= 0 ? this.currentSnapshotIndex : 0];
                    const realNode = this.findNode(snap.root, this.hoveredNode.id);

                    if (realNode) {
                        const hL = realNode.left ? realNode.left.height : 0;
                        const hR = realNode.right ? realNode.right.height : 0;
                        const bf = hL - hR;

                        let labelText = "Perfectly Balanced";
                        let labelColor = '#00AA00';

                        if (bf > 0) {
                            if (bf > 1) {
                                labelText = `Left Heavy (+${bf}) - Unbalanced`;
                                labelColor = "#CC0000";
                            } else {
                                labelText = `Left Heavy (+${bf})`;
                                labelColor = "#EF6C00";
                            }
                        } else if (bf < 0) {
                            if (bf < -1) {
                                labelText = `Right Heavy (${bf}) - Unbalanced`;
                                labelColor = "#CC0000";
                            } else {
                                labelText = `Right Heavy (${bf})`;
                                labelColor = "#EF6C00";
                            }
                        }

                        const tx = this.hoveredNode.x;
                        const ty = this.hoveredNode.y - this.nodeRadius - 12;

                        // this.ctx.save();
                        this.ctx.translate(tx, ty);
                        // this.ctx.scale(1 / this.camera.scale, 1 / this.camera.scale);

                        this.ctx.font = "19px Arial";
                        const metrics = this.ctx.measureText(labelText);
                        const paddingX = 8;
                        const paddingY = 6;
                        const w = metrics.width + paddingX * 2;
                        const h = 26;

                        this.ctx.shadowColor = "rgba(0,0,0,0.3)";
                        this.ctx.shadowBlur = 4;
                        this.ctx.shadowOffsetY = 2;

                        this.ctx.fillStyle = "#ffffff";
                        this.ctx.beginPath();
                        this.ctx.roundRect(-w / 2, -h, w, h, 4);
                        this.ctx.fill();

                        this.ctx.beginPath();
                        this.ctx.moveTo(-5, 0);
                        this.ctx.lineTo(5, 0);
                        this.ctx.lineTo(0, 5);
                        this.ctx.fillStyle = "#ffffff";
                        this.ctx.fill();

                        this.ctx.shadowColor = "rgba(0,0,0,0)";
                        this.ctx.shadowBlur = 0;
                        this.shadowOffsetY = 0;

                        this.ctx.fillStyle = labelColor;
                        this.ctx.textAlign = "center";
                        this.ctx.textBaseline = "middle";
                        this.ctx.fillText(labelText, 0, -h / 2);

                        // this.ctx.restore();
                    }
                }
                this.ctx.restore();
            }

            drawRotationArrow(x1, y1, x2, y2, dir) {
                const ctx = this.ctx;
                const r = this.nodeRadius;
                const startX = x1; const startY = y1 - r;
                const endY = y2; let endX; let endX2;
                let cp1X, cp1Y, cp2X, cp2Y;
                const arcHeight = 60; const sideOffset = 40;
                const startBulge = 30;

                if (dir === 'CW') {
                    endX = x2 - r;
                    endX2 = x2 - r * 1.2;
                    cp1X = startX - startBulge; cp1Y = startY - arcHeight;
                    cp2X = endX - sideOffset; cp2Y = endY;
                } else {
                    endX = x2 + r;
                    endX2 = x2 + r * 1.2;
                    cp1X = startX + startBulge; cp1Y = startY - arcHeight;
                    cp2X = endX + sideOffset; cp2Y = endY;
                }

                ctx.beginPath(); ctx.strokeStyle = COLORS.ARROW; ctx.lineWidth = 5;
                ctx.moveTo(startX, startY); ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX2, endY); ctx.stroke();

                const vecX = endX - cp2X; const vecY = endY - cp2Y;
                const angle = Math.atan2(vecY, vecX);
                this.drawArrowHead(endX, endY, angle);
            }

            drawArrowHead(x, y, angle) {
                const ctx = this.ctx; const size = 16;
                ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
                ctx.beginPath(); ctx.fillStyle = COLORS.ARROW;
                ctx.moveTo(0, 0); ctx.lineTo(-size, -size / 2.5); ctx.lineTo(-size, size / 2.5);
                ctx.closePath(); ctx.fill(); ctx.restore();
            }

            drawNullLink(x, y, side, color, isActive) {
                const r = this.nodeRadius;
                const spread = 12; const drop = 25; const dir = (side === 'L') ? -1 : 1;
                const startX = x + (r * 0.5 * dir); const startY = y + (r * 0.8);
                const endX = x + (r + spread) * dir; const endY = y + r + drop;
                this.ctx.beginPath(); this.ctx.strokeStyle = color; this.ctx.lineWidth = isActive ? 4 : 3;
                this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke();
                const perpSize = 10;
                const dx = endX - startX; const dy = endY - startY;
                const angle = Math.atan2(dy, dx); const perpAngle = angle + Math.PI / 2;
                this.ctx.beginPath();
                this.ctx.moveTo(endX - perpSize * Math.cos(perpAngle), endY - perpSize * Math.sin(perpAngle));
                this.ctx.lineTo(endX + perpSize * Math.cos(perpAngle), endY + perpSize * Math.sin(perpAngle));
                this.ctx.stroke();
            }

            drawStraightArrow(fromX, fromY, toX, toY) {
                const headlen = 15; const angle = Math.atan2(toY - fromY, toX - fromX);
                const r = this.nodeRadius + 5;
                const startX = fromX + r * Math.cos(angle); const startY = fromY + r * Math.sin(angle);
                const endX = toX - r * Math.cos(angle); const endY = toY - r * Math.sin(angle);
                this.ctx.beginPath(); this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
                this.ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
                this.ctx.fill();
            }

            drawNodeCircle(x, y, val, color, isFloating = false, height = null) {
                const r = this.nodeRadius;
                this.ctx.beginPath(); this.ctx.arc(x, y, r, 0, Math.PI * 2);
                this.ctx.fillStyle = color;
                this.ctx.fill();

                if (color === COLORS.DEFAULT || color === COLORS.STROKE || color === COLORS.CHECK) {
                    this.ctx.strokeStyle = color === COLORS.CHECK ? COLORS.CHECK : COLORS.STROKE;
                    this.ctx.fillStyle = COLORS.TEXT;
                } else {
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.fillStyle = '#fff';
                }
                if (color === COLORS.CHILD || color === COLORS.FOUND) {
                    this.ctx.fillStyle = '#333';
                    this.ctx.strokeStyle = '#fff';
                }

                this.ctx.lineWidth = isFloating ? 3 : 3;
                this.ctx.stroke();

                this.ctx.font = '22px Arial';
                this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                this.ctx.fillText(val, x, y + 1);

                if (height !== null && height !== undefined) {
                    const badgeRadius = 10;
                    const bx = x + (r * 0.7); const by = y - (r * 0.7);
                    this.ctx.beginPath(); this.ctx.arc(bx, by, badgeRadius, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#ffffff'; this.ctx.fill();
                    this.ctx.strokeStyle = COLORS.EDGE; this.ctx.lineWidth = 1; this.ctx.stroke();
                    this.ctx.fillStyle = COLORS.EDGE; this.ctx.font = 'bold 11px Arial';
                    this.ctx.fillText(height, bx, by + 1);
                }
            }

            findNode(root, id) {
                if (!root) return null;
                if (root.id === id) return root;
                return this.findNode(root.left, id) || this.findNode(root.right, id);
            }

            interpolateTrees(rootA, rootB, t) {
                const mapA = new Map(); const mapB = new Map();
                const mapFn = (n, m, p) => {
                    if (!n) return;
                    m.set(n.id, { node: n, pX: p ? p.x : null, pY: p ? p.y : null, pId: p ? p.id : null });
                    mapFn(n.left, m, n); mapFn(n.right, m, n);
                };
                mapFn(rootA, mapA, null); mapFn(rootB, mapB, null);
                const result = [];
                const allIds = new Set([...mapA.keys(), ...mapB.keys()]);
                allIds.forEach(id => {
                    const dA = mapA.get(id); const dB = mapB.get(id);
                    if (dA && dB) {
                        const x = dA.node.x + (dB.node.x - dA.node.x) * t;
                        const y = dA.node.y + (dB.node.y - dA.node.y) * t;
                        const color = (t > 0.5) ? dB.node.color : dA.node.color;
                        const height = (t > 0.5) ? dB.node.height : dA.node.height;
                        let pX, pY;
                        if (dA.pId === dB.pId && dA.pId !== null) {
                            const pdA = mapA.get(dA.pId); const pdB = mapB.get(dB.pId);
                            if (pdA && pdB) { pX = pdA.node.x + (pdB.node.x - pdA.node.x) * t; pY = pdA.node.y + (pdB.node.y - pdA.node.y) * t; }
                        } else if (dB.pId !== null) {
                            const pdB = mapB.get(dB.pId); if (pdB) { pX = pdB.node.x; pY = pdB.node.y; }
                        }
                        const hasL = (t > 0.5) ? !!dB.node.left : !!dA.node.left;
                        const hasR = (t > 0.5) ? !!dB.node.right : !!dA.node.right;
                        result.push({ id: id, x, y, value: dB.node.value, color, parentX: pX, parentY: pY, hasLeft: hasL, hasRight: hasR, height: height });
                    } else if (dB && !dA) {
                        let startX = dB.node.x; let startY = dB.node.y;
                        if (dB.pId !== null) {
                            const parentInA = mapA.get(dB.pId);
                            if (parentInA) { startX = parentInA.node.x; startY = parentInA.node.y; }
                        }
                        const x = startX + (dB.node.x - startX) * t;
                        const y = startY + (dB.node.y - startY) * t;

                        let pX, pY;
                        if (dB.pId !== null) {
                            const pdB = mapB.get(dB.pId);
                            const pdA = mapA.get(dB.pId);
                            if (pdA && pdB) {
                                pX = pdA.node.x + (pdB.node.x - pdA.node.x) * t;
                                pY = pdA.node.y + (pdB.node.y - pdA.node.y) * t;
                            } else if (pdB) { pX = pdB.node.x; pY = pdB.node.y; }
                        }
                        result.push({
                            id: id, x: x, y: y, value: dB.node.value, color: dB.node.color,
                            parentX: pX, parentY: pY,
                            hasLeft: !!dB.node.left, hasRight: !!dB.node.right,
                            height: dB.node.height
                        });
                    } else if (dA && !dB) {
                        if (t < 0.8) result.push({
                            id: id, x: dA.node.x, y: dA.node.y, value: dA.node.value, color: COLORS.DELETE,
                            parentX: dA.pX, parentY: dA.pY,
                            hasLeft: !!dA.node.left, hasRight: !!dA.node.right,
                            height: dA.node.height
                        });
                    }
                });
                return result;
            }

            flattenTree(root) {
                const res = [];
                const trav = (n, p) => {
                    if (!n) return;
                    res.push({
                        id: n.id, x: n.x, y: n.y, value: n.value, color: n.color,
                        parentX: p ? p.x : undefined, parentY: p ? p.y : undefined,
                        hasLeft: !!n.left, hasRight: !!n.right,
                        height: n.height
                    });
                    trav(n.left, n); trav(n.right, n);
                };
                trav(root, null);
                return res;
            }
            easeInOut(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }
        }

        const app = {
            tree: new AVLTree(),
            viz: null,
            init: function () { this.viz = new Visualizer('treeCanvas'); this.updateUI(); },
            updateSpeed: function () {
                const val = parseFloat(document.getElementById('speedSlider').value);
                this.viz.setSpeed(val);
            },
            togglePause: function () {
                const isPaused = this.viz.togglePause();
                const btn = document.getElementById('btnPause');
                btn.innerText = isPaused ? "Resume" : "Pause";
            },
            handleInsert: function () {
                const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
                if (!isNaN(val)) { this.runOp(rec => this.tree.insert(val, rec)); inp.value = ''; }
            },
            handleDelete: function () {
                const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
                if (!isNaN(val)) { this.runOp(rec => this.tree.delete(val, rec)); inp.value = ''; }
            },
            handleSearch: function () {
                const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
                if (!isNaN(val)) this.runOp(rec => this.tree.search(val, rec), false);
            },
            handleUndo: function () {
                if (this.tree.history.length === 0) return;
                const oldRoot = this.tree.restoreFromHistory();
                const snaps = [{ root: oldRoot ? oldRoot.clone() : null, meta: { text: "Undo successful" } }];
                this.viz.enqueueOperation(snaps);
                this.updateUI();
            },
            handleClear: function () {
                this.tree = new AVLTree(); this.viz.snapshots = []; this.viz.currentSnapshotIndex = -1;
                this.viz.camera.targetScale = 1; this.viz.draw(); this.updateUI();
            },
            handleRandomTree: function () {
                this.handleClear();
                const snaps = []; snaps.push({ root: null });
                const count = 15; const values = new Set();
                while (values.size < count) values.add(Math.floor(Math.random() * 100) + 1);
                const batchRecorder = (root, floating, meta) => { snaps.push({ root: root ? root.clone() : null, floating, meta }); };
                for (let val of values) { this.tree.insert(val, batchRecorder); }
                this.viz.enqueueOperation(snaps);
                this.updateUI();
            },
            handleDemoSimpleRight: function () {
                this.handleClear();
                const snaps = []; snaps.push({ root: null });

                // Step 1: Build initial unbalanced state (30 -> 20)
                const silentRecorder = (root, floating, meta) => { };
                this.tree.insert(30, silentRecorder);
                this.tree.insert(20, silentRecorder);

                // Snapshot of the setup
                snaps.push({ root: this.tree.root.clone(), meta: { text: "Setup: 30 -> 20. Next: Insert 10 (Causes Right Rotation)" } });

                // Step 2: Record the rotation
                const activeRecorder = (root, floating, meta) => { snaps.push({ root: root ? root.clone() : null, floating, meta }); };
                this.tree.insert(10, activeRecorder);

                this.viz.enqueueOperation(snaps);
                this.updateUI();
            },
            handleDemoSimpleLeft: function () {
                this.handleClear();
                const snaps = []; snaps.push({ root: null });

                // Step 1: Build initial unbalanced state (10 -> 20)
                const silentRecorder = (root, floating, meta) => { };
                this.tree.insert(10, silentRecorder);
                this.tree.insert(20, silentRecorder);

                // Snapshot of the setup
                snaps.push({ root: this.tree.root.clone(), meta: { text: "Setup: 10 -> 20. Next: Insert 30 (Causes Left Rotation)" } });

                // Step 2: Record the rotation
                const activeRecorder = (root, floating, meta) => { snaps.push({ root: root ? root.clone() : null, floating, meta }); };
                this.tree.insert(30, activeRecorder);

                this.viz.enqueueOperation(snaps);
                this.updateUI();
            },
            handleDemoDoubleLeftRight: function () {
                this.handleClear();
                const snaps = []; snaps.push({ root: null });

                // Step 1: Build initial zigzag state (30 -> 10)
                const silentRecorder = (root, floating, meta) => { };
                this.tree.insert(30, silentRecorder);
                this.tree.insert(10, silentRecorder);

                // Snapshot of the setup
                snaps.push({ root: this.tree.root.clone(), meta: { text: "Setup: 30 -> 10. Next: Insert 20 (Causes Double Rotation)" } });

                // Step 2: Record the rotation
                const activeRecorder = (root, floating, meta) => { snaps.push({ root: root ? root.clone() : null, floating, meta }); };
                this.tree.insert(20, activeRecorder);

                this.viz.enqueueOperation(snaps);
                this.updateUI();
            },
            handleDemoDoubleRightLeft: function () {
                this.handleClear();
                const snaps = []; snaps.push({ root: null });

                // Step 1: Build initial zigzag state (10 -> 30)
                const silentRecorder = (root, floating, meta) => { };
                this.tree.insert(10, silentRecorder);
                this.tree.insert(30, silentRecorder);

                // Snapshot of the setup
                snaps.push({ root: this.tree.root.clone(), meta: { text: "Setup: 10 -> 30. Next: Insert 20 (Causes Double Rotation)" } });

                // Step 2: Record the rotation
                const activeRecorder = (root, floating, meta) => { snaps.push({ root: root ? root.clone() : null, floating, meta }); };
                this.tree.insert(20, activeRecorder);

                this.viz.enqueueOperation(snaps);
                this.updateUI();
            },
            toggleModal: function () {
                const m = document.getElementById('helpModal');
                m.style.display = (m.style.display === 'block') ? 'none' : 'block';
            },
            runOp: function (fn, allowsUndo = true) {
                if (this.viz.isPaused) this.togglePause();
                if (this.viz.state !== 'IDLE') return;
                const snaps = [];
                if (this.tree.root) snaps.push({ root: this.tree.root.clone() }); else snaps.push({ root: null });
                fn((root, floating, meta) => snaps.push({ root: root ? root.clone() : null, floating, meta }));
                this.viz.enqueueOperation(snaps);
                if (allowsUndo) this.updateUI();
            },
            updateUI: function () { document.getElementById('btnUndo').disabled = (this.tree.history.length === 0); }
        };

        window.onload = () => app.init();
    </script>
</body>

</html>