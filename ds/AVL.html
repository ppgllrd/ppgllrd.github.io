<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Visualizer</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: #f5f5f5;
            --text-color: #333333;
            --border-color: #ddd;
            
            /* UI Colors */
            --btn-insert: #2E7D32; 
            --btn-delete: #c62828; 
            --btn-search: #1565C0; 
            --btn-undo: #6A1B9A;   
            --btn-gray: #546E7A;
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            display: flex; flex-direction: column; height: 100vh;
            overflow: auto; user-select: none;
        }

        header {
            padding: 10px 20px; background-color: var(--panel-bg);
            display: flex; flex-direction: column; gap: 10px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .header-top { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .gui { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        h1 { margin: 0; font-size: 1.2rem; color: #222; }
        .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .sub-controls { display: flex; gap: 15px; align-items: center; font-size: 0.9rem; color: #555; vertical-align: middle;}

        input[type="number"] {
            padding: 6px; border-radius: 4px; border: 1px solid #999;
            background: #fff; color: #000; width: 60px; text-align: center; font-weight: bold;
        }
        input[type="range"] { width: 100px; cursor: pointer; }

        button {
            padding: 6px 14px; border: none; border-radius: 4px; cursor: pointer;
            font-weight: 600; color: white; transition: filter 0.2s, transform 0.1s;
            font-size: 0.85rem; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }

        .btn-insert { background-color: var(--btn-insert); }
        .btn-delete { background-color: var(--btn-delete); }
        .btn-search { background-color: var(--btn-search); }
        .btn-undo { background-color: var(--btn-undo); }
        .btn-clear { background-color: var(--btn-gray); }
        .btn-random { background-color: #EF6C00; }
        .btn-pause { background-color: #455A64; width: 80px;}

        #canvas-container {
            flex-grow: 100; position: relative; overflow: hidden;
            background-color: var(--bg-color);
            cursor: crosshair;
            min-height: 200px;
        }
        canvas { display: block; width: 100%; height: 100%; }

        #legend {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255,255,255,0.95); padding: 10px;
            border: 1px solid #ddd; border-radius: 8px; font-size: 0.8rem;
            pointer-events: none; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; color: #333; }
        .dot { width: 14px; height: 14px; border-radius: 50%; }
        .line-icon { width: 15px; height: 3px; border-radius: 2px; }
        .arrow-icon { font-size: 16px; font-weight: bold; color: #D50000; }

        #status-bar {
            padding: 8px 2px 0px 0px; background-color: var(--panel-bg);
            font-size: 0.85rem; border-top: 1px solid var(--border-color);
            display: flex; justify-content: space-between; color: #555;
            flex-shrink: 0;
        }
        #status-text { font-weight: bold; color: #222; }

        #author { 
            flex-grow: 1; position: relative; overflow: hidden;
            background: #f4f7f6; font-size: 0.75em; color: #777; text-align: center; line-height: 2;}    
    </style>
</head>
<body>

<header>
    <div class="header-top">
        <h1>AVL Visualizer</h1>        
    </div>
    <div class="gui">
        <div class="controls">
            <input type="number" id="inputValue" placeholder="#" onkeydown="if(event.key==='Enter') app.handleInsert()">
            <button class="btn-insert" onclick="app.handleInsert()">Insert</button>
            <button class="btn-search" onclick="app.handleSearch()">Search</button>
            <button class="btn-delete" onclick="app.handleDelete()">Delete</button>
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>
            <button class="btn-undo" onclick="app.handleUndo()" id="btnUndo" disabled>Undo</button>
            <button class="btn-random" onclick="app.handleRandomTree()">Random Tree</button>
            <button class="btn-clear" onclick="app.handleClear()">Clear</button>
        </div>
        <div class="sub-controls">
             <label for="speed-slider">Speed:</label>
            <label title="Animation Speed">
                <input type="range" id="speedSlider" min="1" max="5" step="0.1" value="1" oninput="app.updateSpeed()">
                <!--span id="speedLabel">1x</span-->
            </label>
            <button class="btn-pause" onclick="app.togglePause()" id="btnPause">Pause</button>
        </div>
    </div>
    <div id="status-bar">
        <span id="status-text">Ready.</span>
    <!--span id="queue-info">Queue: 0</span-->

</div>
</header>

<div id="canvas-container">
    <canvas id="treeCanvas"></canvas>
    <div id="legend">
        <div class="legend-item"><div class="dot" style="background:#B2FBA5; border:1px solid #B2FBA5"></div><span style="color:#D50000; font-weight:bold;">12</span> &nbsp; Normal</div>
        <div class="legend-item"><div class="dot" style="background:#4CAF50; border:1px solid #fff"></div>Inserted</div>
        <div class="legend-item"><div class="dot" style="background:#FF5722; border:1px solid #fff"></div>Pivot (Orange)</div>
        <div class="legend-item"><div class="dot" style="background:#FFC107; border:1px solid #fff"></div>Child (Yellow)</div>
        <div class="legend-item"><div class="arrow-icon">&#8635;</div>Rotation</div>
        <div class="legend-item"><div class="dot" style="background:#F44336; border:1px solid #fff"></div>Delete</div>
        <div class="legend-item"><div class="dot" style="background:#2196F3; border:1px solid #fff"></div>Visiting</div>
        <div class="legend-item"><div class="line-icon" style="background:#1565C0;"></div>Null Link</div>
    </div>
</div>

<div id="author">Pepe Gallardo. Dpto. Lenguajes y Ciencias de la Computación. Universidad de Málaga</div>

<script>
const COLORS = {
    DEFAULT: '#B2FBA5',
    TEXT: '#D50000',
    EDGE: '#1565C0',
    NEW: '#4CAF50',
    VISIT: '#2196F3',
    PIVOT: '#FF5722', 
    CHILD: '#FFC107',
    FOUND: '#00E676',
    DELETE: '#F44336',
    NULL_LINK: '#1565C0',
    ARROW: '#D50000' 
};

class Node {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.height = 1;
        this.id = Node.nextId++;
        this.color = COLORS.DEFAULT;
        this.x = 0; this.y = 0;
    }
    clone() {
        const newNode = new Node(this.value);
        newNode.height = this.height; newNode.id = this.id; newNode.color = this.color;
        newNode.x = this.x; newNode.y = this.y;
        if (this.left) newNode.left = this.left.clone();
        if (this.right) newNode.right = this.right.clone();
        return newNode;
    }
}
Node.nextId = 0;

class AVLTree {
    constructor() { this.root = null; this.history = []; }
    saveToHistory() {
        const state = this.root ? this.root.clone() : null;
        this.history.push(state);
        if (this.history.length > 25) this.history.shift();
    }
    restoreFromHistory() {
        if (this.history.length === 0) return null;
        this.root = this.history.pop(); return this.root;
    }
    resetVisuals(node) {
        if (!node) return;
        node.color = COLORS.DEFAULT;
        this.resetVisuals(node.left); this.resetVisuals(node.right);
    }
    cleanUp(recordSnapshot) {
        this.resetVisuals(this.root);
        recordSnapshot(this.root, null, { text: 'Ready.' });
    }
    getHeight(node) { return node ? node.height : 0; }
    updateHeight(node) { node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right)); }
    getBalance(node) { return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0; }

    rightRotate(y, record) {
        const x = y.left; const T2 = x.right;
        const pY = y.color; const pX = x.color;
        y.color = COLORS.PIVOT; x.color = COLORS.CHILD;
        record(this.root, null, { 
            pause: true, 
            text: `Right Rotate: ${y.value} moves down`,
            rotation: { id: y.id, dir: 'CW' } 
        });
        x.right = y; y.left = T2;
        this.updateHeight(y); this.updateHeight(x);
        y.color = pY; x.color = pX;
        return x;
    }
    leftRotate(x, record) {
        const y = x.right; const T2 = y.left;
        const pX = x.color; const pY = y.color;
        x.color = COLORS.PIVOT; y.color = COLORS.CHILD;
        record(this.root, null, { 
            pause: true, 
            text: `Left Rotate: ${x.value} moves down`,
            rotation: { id: x.id, dir: 'CCW' }
        });
        y.left = x; x.right = T2;
        this.updateHeight(x); this.updateHeight(y);
        x.color = pX; y.color = pY;
        return y;
    }
    insert(value, recordSnapshot) {
        this.saveToHistory();
        const _insert = (node) => {
            if (node) recordSnapshot(this.root, { val: value, targetId: node.id }, { text: `Finding place for ${value}...` });
            if (!node) { const nn = new Node(value); nn.color = COLORS.NEW; return nn; }
            if (value < node.value) {
                if (!node.left) recordSnapshot(this.root, null, { text: `Reached null link (Left of ${node.value})`, activeNull: { nodeId: node.id, side: 'L', color: COLORS.VISIT } });
                node.left = _insert(node.left);
            } else if (value > node.value) {
                if (!node.right) recordSnapshot(this.root, null, { text: `Reached null link (Right of ${node.value})`, activeNull: { nodeId: node.id, side: 'R', color: COLORS.VISIT } });
                node.right = _insert(node.right);
            } else return node;
            this.updateHeight(node);
            const balance = this.getBalance(node);
            if (balance > 1 && value < node.left.value) return this.rightRotate(node, recordSnapshot);
            if (balance < -1 && value > node.right.value) return this.leftRotate(node, recordSnapshot);
            if (balance > 1 && value > node.left.value) { node.left = this.leftRotate(node.left, recordSnapshot); return this.rightRotate(node, recordSnapshot); }
            if (balance < -1 && value < node.right.value) { node.right = this.rightRotate(node.right, recordSnapshot); return this.leftRotate(node, recordSnapshot); }
            return node;
        };
        this.root = _insert(this.root);
        recordSnapshot(this.root, null, { text: `Inserted ${value}` });
        this.cleanUp(recordSnapshot);
    }
    delete(value, recordSnapshot) {
        this.saveToHistory();
        let found = false;
        const _delete = (node, val, showSearch = true) => {
            if (!node) return node;
            if (showSearch) {
                node.color = COLORS.VISIT;
                recordSnapshot(this.root, null, { text: `Searching ${val}...` });
                node.color = COLORS.DEFAULT;
            }
            if (val < node.value) {
                if(showSearch && !node.left) recordSnapshot(this.root, null, { text: `${val} not found (Left of ${node.value})`, activeNull: { nodeId: node.id, side: 'L', color: COLORS.DELETE } });
                node.left = _delete(node.left, val, showSearch);
            } else if (val > node.value) {
                if(showSearch && !node.right) recordSnapshot(this.root, null, { text: `${val} not found (Right of ${node.value})`, activeNull: { nodeId: node.id, side: 'R', color: COLORS.DELETE } });
                node.right = _delete(node.right, val, showSearch);
            } else {
                found = true;
                if (!node.left || !node.right) {
                    node.color = COLORS.DELETE;
                    recordSnapshot(this.root, null, { pause: true, text: `Deleting ${node.value}` });
                    const temp = node.left ? node.left : node.right;
                    node = temp ? temp : null;
                } else {
                    let temp = node.right;
                    recordSnapshot(this.root, null, { text: "Finding successor (right side)..." });
                    while (temp.left) {
                        temp.color = COLORS.VISIT;
                        recordSnapshot(this.root, null, { text: `Visiting: ${temp.value}` });
                        temp.color = COLORS.DEFAULT;
                        temp = temp.left;
                    }
                    recordSnapshot(this.root, null, { text: `Successor found (Left of ${temp.value} is null)`, activeNull: { nodeId: temp.id, side: 'L', color: COLORS.VISIT } });
                    node.color = COLORS.DELETE; temp.color = COLORS.PIVOT;
                    recordSnapshot(this.root, null, { pause: true, text: `Successor ${temp.value} replaces ${node.value}`, arrows: [{ from: temp.id, to: node.id }] });
                    node.value = temp.value;
                    node.color = COLORS.NEW; temp.color = COLORS.DEFAULT;
                    recordSnapshot(this.root, null, { text: `Value replaced` });
                    node.right = _delete(node.right, temp.value, false);
                }
            }
            if (!node) return node;
            this.updateHeight(node);
            const balance = this.getBalance(node);
            if (balance > 1 && this.getBalance(node.left) >= 0) return this.rightRotate(node, recordSnapshot);
            if (balance > 1 && this.getBalance(node.left) < 0) { node.left = this.leftRotate(node.left, recordSnapshot); return this.rightRotate(node, recordSnapshot); }
            if (balance < -1 && this.getBalance(node.right) <= 0) return this.leftRotate(node, recordSnapshot);
            if (balance < -1 && this.getBalance(node.right) > 0) { node.right = this.rightRotate(node.right, recordSnapshot); return this.leftRotate(node, recordSnapshot); }
            return node;
        };
        this.root = _delete(this.root, value);
        if(found) recordSnapshot(this.root, null, { text: `Finished` }); else recordSnapshot(this.root, null, { text: `Value ${value} not found` });
        this.cleanUp(recordSnapshot);
    }
    search(value, recordSnapshot) {
        let current = this.root;
        let found = false;
        if(!current) { recordSnapshot(null, null, { text: "Tree is empty" }); return; }
        while (current) {
            current.color = (current.value === value) ? COLORS.FOUND : COLORS.VISIT;
            const txt = current.value === value ? `Found!` : `Visiting ${current.value}...`;
            recordSnapshot(this.root, null, { text: txt, pause: (current.value === value) });
            if (current.value === value) { found = true; break; }
            else if (value < current.value) {
                if(!current.left) recordSnapshot(this.root, null, { text: `${value} not found (Left of ${current.value})`, activeNull: { nodeId: current.id, side: 'L', color: COLORS.DELETE } });
                current = current.left;
            } else {
                if(!current.right) recordSnapshot(this.root, null, { text: `${value} not found (Right of ${current.value})`, activeNull: { nodeId: current.id, side: 'R', color: COLORS.DELETE } });
                current = current.right;
            }
        }
        if(!found) recordSnapshot(this.root, null, { text: "Not found." });
        this.cleanUp(recordSnapshot);
    }
}

class Visualizer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.camera = { scale: 1, targetScale: 1, x: 0, targetX: 0, y: 0, targetY: 0 };
        this.nodeRadius = 25;
        this.levelHeight = 80;
        this.snapshots = [];
        this.currentSnapshotIndex = -1;
        this.lastDrawnNodes = [];
        this.state = 'IDLE';
        this.isPaused = false;
        this.morphProgress = 0;
        this.baseMorphSpeed = 0.05;
        this.currentSpeedFactor = 1;
        this.pauseTimer = 0;
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.canvas.addEventListener('mousedown', (e) => this.handleClick(e));
        this.lastTime = 0;
        requestAnimationFrame(t => this.loop(t));
    }

    resize() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
        if (this.snapshots.length > 0) {
            const snap = this.snapshots[this.currentSnapshotIndex >= 0 ? this.currentSnapshotIndex : 0];
            if (snap && snap.root) {
                this.fitTreeBounds(snap.root);
                this.camera.scale = this.camera.targetScale;
                this.camera.x = this.camera.targetX;
                this.camera.y = this.camera.targetY;
            }
        }
    }
    getTreeBounds(root) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        let hasNodes = false;
        const traverse = (n) => {
            if (!n) return;
            hasNodes = true;
            minX = Math.min(minX, n.x - this.nodeRadius);
            maxX = Math.max(maxX, n.x + this.nodeRadius);
            minY = Math.min(minY, n.y - this.nodeRadius);
            maxY = Math.max(maxY, n.y + this.nodeRadius);
            traverse(n.left); traverse(n.right);
        };
        traverse(root);
        return { minX, maxX, minY, maxY, hasNodes };
    }
    fitTreeBounds(root) {
        const bounds = this.getTreeBounds(root);
        this.fitBoundsToScreen(bounds);
    }
    fitBoundsToScreen(bounds) {
        if (!bounds.hasNodes) {
            this.camera.targetScale = 1; this.camera.targetX = this.canvas.width / 2; this.camera.targetY = 100;
            return;
        }
        const padding = 150;
        const treeW = bounds.maxX - bounds.minX + padding;
        const treeH = bounds.maxY - bounds.minY + padding;
        const scale = Math.min(1.3, Math.min(this.canvas.width / treeW, this.canvas.height / treeH));
        const treeCX = (bounds.minX + bounds.maxX) / 2;
        const treeCY = (bounds.minY + bounds.maxY) / 2;
        this.camera.targetScale = scale;
        this.camera.targetX = (this.canvas.width / 2) - (treeCX * scale);
        this.camera.targetY = (this.canvas.height / 2) - (treeCY * scale);
        if (treeH * scale < this.canvas.height * 0.7) this.camera.targetY = 100;
    }
    setSpeed(val) { this.currentSpeedFactor = 1 / val; }
    togglePause() { this.isPaused = !this.isPaused; return this.isPaused; }

    handleClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
        for (let n of this.lastDrawnNodes) {
            const sx = (n.x * this.camera.scale) + this.camera.x;
            const sy = (n.y * this.camera.scale) + this.camera.y;
            const r = this.nodeRadius * this.camera.scale;
            if (Math.hypot(mx - sx, my - sy) < r) {
                document.getElementById('inputValue').value = n.value;
                document.getElementById('inputValue').focus();
                return;
            }
        }
    }
    calculateLayout(root) {
        if (!root) return;
        let order = 0;
        const traverse = (node, depth) => {
            if (!node) return;
            traverse(node.left, depth + 1);
            node.x = order * (this.nodeRadius * 2.8);
            node.y = depth * this.levelHeight + 80;
            order++;
            traverse(node.right, depth + 1);
        };
        traverse(root, 0);
        const width = (order > 0 ? order - 1 : 0) * (this.nodeRadius * 2.8);
        const offset = width / 2;
        const centerTree = (node) => { if(!node) return; node.x -= offset; centerTree(node.left); centerTree(node.right); };
        centerTree(root);
    }
    enqueueOperation(snapshots) {
        if (snapshots.length === 0) return;
        snapshots.forEach(s => this.calculateLayout(s.root));
        let gMinX = Infinity, gMaxX = -Infinity, gMinY = Infinity, gMaxY = -Infinity;
        let hasNodes = false;
        const allFrames = (this.snapshots.length > 0) ? [this.snapshots[this.snapshots.length-1], ...snapshots] : snapshots;
        allFrames.forEach(s => {
            const b = this.getTreeBounds(s.root);
            if (b.hasNodes) {
                hasNodes = true;
                gMinX = Math.min(gMinX, b.minX); gMaxX = Math.max(gMaxX, b.maxX);
                gMinY = Math.min(gMinY, b.minY); gMaxY = Math.max(gMaxY, b.maxY);
            }
        });
        this.fitBoundsToScreen({ minX: gMinX, maxX: gMaxX, minY: gMinY, maxY: gMaxY, hasNodes: hasNodes });
        if (this.snapshots.length === 0) {
            this.snapshots.push(snapshots[0]); this.currentSnapshotIndex = 0; snapshots.shift();
        }
        if (snapshots.length > 0) { this.pendingSnapshots = snapshots; this.state = 'CAMERA'; }
    }
    loop(timestamp) { if (!this.isPaused) this.update(); this.draw(); requestAnimationFrame(t => this.loop(t)); }

    update() {
        const camSpeed = 0.1;
        this.camera.scale += (this.camera.targetScale - this.camera.scale) * camSpeed;
        this.camera.x += (this.camera.targetX - this.camera.x) * camSpeed;
        this.camera.y += (this.camera.targetY - this.camera.y) * camSpeed;
        const pending = this.pendingSnapshots ? this.pendingSnapshots.length : 0;
        // document.getElementById('queue-info').innerText = `In Queue: ${pending}`;
        if (this.state === 'CAMERA') {
             const dist = Math.hypot(this.camera.x - this.camera.targetX, this.camera.y - this.camera.targetY);
             if (dist < 10 && Math.abs(this.camera.scale - this.camera.targetScale) < 0.05) {
                 if (this.pendingSnapshots.length > 0) this.loadNextSnapshot();
                 else this.state = 'IDLE';
             }
        } else if (this.state === 'MORPH') {
            this.morphProgress += this.baseMorphSpeed * this.currentSpeedFactor;
            if (this.morphProgress >= 1) {
                this.morphProgress = 1;
                if (this.pauseAfterMorph) {
                    this.state = 'WAITING';
                    this.pauseTimer = 50 / this.currentSpeedFactor;
                } else { this.finalizeStep(); }
            }
        } else if (this.state === 'WAITING') {
            this.pauseTimer--; if (this.pauseTimer <= 0) this.finalizeStep();
        }
    }

    loadNextSnapshot() {
        const next = this.pendingSnapshots.shift();
        this.snapshots.push(next);
        if (next.meta && next.meta.text) document.getElementById('status-text').innerText = next.meta.text;
        this.state = 'MORPH';
        this.morphProgress = 0;
        this.pauseAfterMorph = (next.meta && next.meta.pause);
    }

    finalizeStep() {
        this.currentSnapshotIndex++;
        if (this.pendingSnapshots && this.pendingSnapshots.length > 0) this.loadNextSnapshot();
        else { this.state = 'IDLE'; document.getElementById('status-text').innerText = "Ready."; }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save();
        this.ctx.translate(this.camera.x, this.camera.y);
        this.ctx.scale(this.camera.scale, this.camera.scale);
        if (this.snapshots.length === 0) { this.ctx.restore(); return; }

        const idx = this.currentSnapshotIndex;
        let nodesToDraw = [];
        let floatingNode = null;
        let arrowsToDraw = [];
        let activeNull = null;
        let currentMeta = null;
        
        if ((this.state === 'MORPH' || this.state === 'WAITING') && idx + 1 < this.snapshots.length) {
            const snapA = this.snapshots[idx];
            const snapB = this.snapshots[idx+1];
            const t = this.easeInOut(this.morphProgress);
            nodesToDraw = this.interpolateTrees(snapA.root, snapB.root, t);
            
            if (snapB.floating) {
                const targetNodeB = this.findNode(snapB.root, snapB.floating.targetId);
                let startX = targetNodeB ? targetNodeB.x : 0;
                let startY = targetNodeB ? targetNodeB.y - 60 : 0;
                if (snapA.floating) { 
                    const prevTarget = this.findNode(snapA.root, snapA.floating.targetId);
                    if(prevTarget) { startX = prevTarget.x; startY = prevTarget.y; }
                }
                if (targetNodeB) {
                    const fx = startX + (targetNodeB.x - startX) * t;
                    const fy = startY + (targetNodeB.y - startY) * t;
                    floatingNode = { x: fx, y: fy, value: snapB.floating.val };
                }
            }
            if (snapB.meta && snapB.meta.arrows) arrowsToDraw = snapB.meta.arrows;
            currentMeta = (t > 0.5) ? snapB.meta : snapA.meta;
        } else {
            const snap = this.snapshots[idx >= 0 ? idx : 0];
            nodesToDraw = this.flattenTree(snap.root);
            if (snap.meta && snap.meta.arrows) arrowsToDraw = snap.meta.arrows;
            currentMeta = snap.meta;
        }

        if (currentMeta && currentMeta.activeNull) activeNull = currentMeta.activeNull;
        this.lastDrawnNodes = nodesToDraw; 

        this.ctx.beginPath(); 
        this.ctx.strokeStyle = COLORS.EDGE; 
        this.ctx.lineWidth = 3;
        nodesToDraw.forEach(n => {
            if (n.parentX !== undefined) { this.ctx.moveTo(n.parentX, n.parentY); this.ctx.lineTo(n.x, n.y); }
        });
        this.ctx.stroke();

        nodesToDraw.forEach(n => {
            if (!n.hasLeft) {
                const isActive = (activeNull && activeNull.nodeId === n.id && activeNull.side === 'L');
                const col = isActive ? activeNull.color : COLORS.NULL_LINK;
                this.drawNullLink(n.x, n.y, 'L', col, isActive);
            }
            if (!n.hasRight) {
                const isActive = (activeNull && activeNull.nodeId === n.id && activeNull.side === 'R');
                const col = isActive ? activeNull.color : COLORS.NULL_LINK;
                this.drawNullLink(n.x, n.y, 'R', col, isActive);
            }
        });

        nodesToDraw.forEach(n => this.drawNodeCircle(n.x, n.y, n.value, n.color || COLORS.DEFAULT));

        if (currentMeta && currentMeta.rotation) {
            const pivotNode = nodesToDraw.find(n => n.color === COLORS.PIVOT);
            const childNode = nodesToDraw.find(n => n.color === COLORS.CHILD);
            
            if (pivotNode && childNode) {
                this.drawRotationArrow(childNode.x, childNode.y, pivotNode.x, pivotNode.y, currentMeta.rotation.dir);
            }
        }

        if (arrowsToDraw.length > 0) {
            this.ctx.strokeStyle = COLORS.CHILD; this.ctx.fillStyle = COLORS.CHILD; this.ctx.lineWidth = 3;
            arrowsToDraw.forEach(arr => {
                const n1 = nodesToDraw.find(n => n.id === arr.from);
                const n2 = nodesToDraw.find(n => n.id === arr.to);
                if (n1 && n2) this.drawStraightArrow(n1.x, n1.y, n2.x, n2.y);
            });
        }
        if (floatingNode) {
            this.ctx.shadowBlur = 10; this.ctx.shadowColor = COLORS.NEW;
            this.drawNodeCircle(floatingNode.x, floatingNode.y, floatingNode.value, COLORS.NEW, true);
            this.ctx.shadowBlur = 0;
        }
        this.ctx.restore();
    }

    drawRotationArrow(x1, y1, x2, y2, dir) {
        const ctx = this.ctx;
        const r = this.nodeRadius;
        
        // Start: Top of Child
        const startX = x1;
        const startY = y1 - r;
        
        // End: Side of Parent (Vertical Center)
        const endY = y2;
        let endX;
        
        let cp1X, cp1Y, cp2X, cp2Y;
        const arcHeight = 60; 
        const sideOffset = 40; // CP2 Push out
        
        // START BULGE LOGIC: Move CP1 outwards to avoid vertical start
        const startBulge = 30; 

        if (dir === 'CW') { 
            // Child is Left -> Hits Parent Left Side
            endX = x2 - r;
            
            // CP1: Up and Left (Outwards)
            cp1X = startX - startBulge;
            cp1Y = startY - arcHeight;
            
            // CP2: Horizontal Out from Parent
            cp2X = endX - sideOffset;
            cp2Y = endY; 
            
        } else { 
            // Child is Right -> Hits Parent Right Side
            endX = x2 + r;
            
            // CP1: Up and Right (Outwards)
            cp1X = startX + startBulge;
            cp1Y = startY - arcHeight;
            
            // CP2: Horizontal Out from Parent
            cp2X = endX + sideOffset;
            cp2Y = endY;
        }

        ctx.beginPath();
        ctx.strokeStyle = COLORS.ARROW;
        ctx.lineWidth = 5;
        
        ctx.moveTo(startX, startY);
        ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX, endY);
        ctx.stroke();
        
        // Arrowhead Angle
        const vecX = endX - cp2X;
        const vecY = endY - cp2Y;
        const angle = Math.atan2(vecY, vecX);
        
        this.drawArrowHead(endX, endY, angle);
    }

    drawArrowHead(x, y, angle) {
        const ctx = this.ctx;
        const size = 16;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.fillStyle = COLORS.ARROW;
        ctx.moveTo(0, 0);
        ctx.lineTo(-size, -size/2.5);
        ctx.lineTo(-size, size/2.5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    drawNullLink(x, y, side, color, isActive) {
        const r = this.nodeRadius;
        const spread = 12; const drop = 25; const dir = (side === 'L') ? -1 : 1;
        const startX = x + (r * 0.5 * dir); const startY = y + (r * 0.8);
        const endX = x + (r + spread) * dir; const endY = y + r + drop;
        this.ctx.beginPath(); this.ctx.strokeStyle = color; this.ctx.lineWidth = isActive ? 4 : 3;
        this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke();
        const perpSize = 10;
        const dx = endX - startX; const dy = endY - startY;
        const angle = Math.atan2(dy, dx); const perpAngle = angle + Math.PI / 2;
        this.ctx.beginPath();
        this.ctx.moveTo(endX - perpSize * Math.cos(perpAngle), endY - perpSize * Math.sin(perpAngle));
        this.ctx.lineTo(endX + perpSize * Math.cos(perpAngle), endY + perpSize * Math.sin(perpAngle));
        this.ctx.stroke();
    }

    drawStraightArrow(fromX, fromY, toX, toY) {
        const headlen = 15;
        const angle = Math.atan2(toY - fromY, toX - fromX);
        const r = this.nodeRadius + 5;
        const startX = fromX + r * Math.cos(angle); const startY = fromY + r * Math.sin(angle);
        const endX = toX - r * Math.cos(angle); const endY = toY - r * Math.sin(angle);
        this.ctx.beginPath(); this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(endX, endY);
        this.ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI/6), endY - headlen * Math.sin(angle - Math.PI/6));
        this.ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI/6), endY - headlen * Math.sin(angle + Math.PI/6));
        this.ctx.fill();
    }

    drawNodeCircle(x, y, val, color, isFloating=false) {
        const r = this.nodeRadius;
        this.ctx.beginPath(); this.ctx.arc(x, y, r, 0, Math.PI * 2);
        this.ctx.fillStyle = color; this.ctx.fill();
        if (color === COLORS.DEFAULT) {
            this.ctx.strokeStyle = color; 
            this.ctx.fillStyle = COLORS.TEXT; 
        } else {
            this.ctx.strokeStyle = '#fff';
            this.ctx.fillStyle = '#fff';
        }
        this.ctx.lineWidth = isFloating ? 3 : 2; this.ctx.stroke();
        this.ctx.font = '20px Arial';
        this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
        this.ctx.fillText(val, x, y);
    }

    findNode(root, id) {
        if(!root) return null;
        if(root.id === id) return root;
        return this.findNode(root.left, id) || this.findNode(root.right, id);
    }

    interpolateTrees(rootA, rootB, t) {
        const mapA = new Map(); const mapB = new Map();
        const mapFn = (n, m, p) => {
            if(!n) return;
            m.set(n.id, { node: n, pX: p?p.x:null, pY: p?p.y:null, pId: p?p.id:null });
            mapFn(n.left, m, n); mapFn(n.right, m, n);
        };
        mapFn(rootA, mapA, null); mapFn(rootB, mapB, null);
        const result = [];
        const allIds = new Set([...mapA.keys(), ...mapB.keys()]);
        allIds.forEach(id => {
            const dA = mapA.get(id); const dB = mapB.get(id);
            if (dA && dB) {
                const x = dA.node.x + (dB.node.x - dA.node.x) * t;
                const y = dA.node.y + (dB.node.y - dA.node.y) * t;
                const color = (t > 0.5) ? dB.node.color : dA.node.color;
                let pX, pY;
                if (dA.pId === dB.pId && dA.pId !== null) {
                     const pdA = mapA.get(dA.pId); const pdB = mapB.get(dB.pId);
                     if(pdA && pdB) { pX = pdA.node.x + (pdB.node.x - pdA.node.x) * t; pY = pdA.node.y + (pdB.node.y - pdA.node.y) * t; }
                } else if (dB.pId !== null) {
                    const pdB = mapB.get(dB.pId); if(pdB) { pX = pdB.node.x; pY = pdB.node.y; }
                }
                const hasL = (t > 0.5) ? !!dB.node.left : !!dA.node.left;
                const hasR = (t > 0.5) ? !!dB.node.right : !!dA.node.right;
                result.push({ id: id, x, y, value: dB.node.value, color, parentX: pX, parentY: pY, hasLeft: hasL, hasRight: hasR });
            } else if (dB && !dA) {
                let startX = dB.node.x; let startY = dB.node.y;
                if (dB.pId !== null) {
                    const parentInA = mapA.get(dB.pId);
                    if (parentInA) { startX = parentInA.node.x; startY = parentInA.node.y; }
                }
                const x = startX + (dB.node.x - startX) * t;
                const y = startY + (dB.node.y - startY) * t;
                
                let pX, pY;
                if (dB.pId !== null) {
                     const pdB = mapB.get(dB.pId);
                     const pdA = mapA.get(dB.pId); 
                     if (pdA && pdB) {
                         pX = pdA.node.x + (pdB.node.x - pdA.node.x) * t;
                         pY = pdA.node.y + (pdB.node.y - pdA.node.y) * t;
                     } else if (pdB) { pX = pdB.node.x; pY = pdB.node.y; }
                }
                result.push({ 
                    id: id, x: x, y: y, value: dB.node.value, color: dB.node.color, 
                    parentX: pX, parentY: pY,
                    hasLeft: !!dB.node.left, hasRight: !!dB.node.right
                });
            } else if (dA && !dB) {
                if(t < 0.8) result.push({ 
                    id: id, x: dA.node.x, y: dA.node.y, value: dA.node.value, color: COLORS.DELETE, 
                    parentX: dA.pX, parentY: dA.pY,
                    hasLeft: !!dA.node.left, hasRight: !!dA.node.right
                });
            }
        });
        return result;
    }

    flattenTree(root) {
        const res = [];
        const trav = (n, p) => {
            if(!n) return;
            res.push({ 
                id: n.id, x: n.x, y: n.y, value: n.value, color: n.color, 
                parentX: p ? p.x : undefined, parentY: p ? p.y : undefined,
                hasLeft: !!n.left, hasRight: !!n.right
            });
            trav(n.left, n); trav(n.right, n);
        };
        trav(root, null);
        return res;
    }
    easeInOut(t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t; }
}

const app = {
    tree: new AVLTree(),
    viz: null,
    init: function() { this.viz = new Visualizer('treeCanvas'); this.updateUI(); },
    updateSpeed: function() {
        const val = parseFloat(document.getElementById('speedSlider').value);
        // document.getElementById('speedLabel').innerText = '1/' + val + 'x';
        this.viz.setSpeed(val);
    },
    togglePause: function() {
        const isPaused = this.viz.togglePause();
        const btn = document.getElementById('btnPause');
        btn.innerText = isPaused ? "Resume" : "Pause";
        btn.style.backgroundColor = isPaused ? "#2E7D32" : "#455A64";
    },
    handleInsert: function() { 
        const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
        if (!isNaN(val)) { this.runOp(rec => this.tree.insert(val, rec)); inp.value = ''; inp.focus(); }
    },
    handleDelete: function() { 
        const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
        if (!isNaN(val)) { this.runOp(rec => this.tree.delete(val, rec)); inp.value = ''; }
    },
    handleSearch: function() { 
        const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
        if (!isNaN(val)) this.runOp(rec => this.tree.search(val, rec), false);
    },
    handleUndo: function() { 
        if (this.tree.history.length === 0) return;
        const oldRoot = this.tree.restoreFromHistory();
        const snaps = [{ root: oldRoot ? oldRoot.clone() : null, meta: { text: "Undo successful" } }];
        this.viz.enqueueOperation(snaps);
        this.updateUI();
    },
    handleClear: function() { 
        this.tree = new AVLTree(); this.viz.snapshots = []; this.viz.currentSnapshotIndex = -1; 
        this.viz.camera.targetScale = 1; this.viz.draw(); this.updateUI(); 
    },
    handleRandomTree: function() {
        this.handleClear();
        const snaps = []; snaps.push({ root: null });
        const count = 15; const values = new Set();
        while(values.size < count) values.add(Math.floor(Math.random() * 100) + 1);
        const batchRecorder = (root, floating, meta) => { snaps.push({ root: root ? root.clone() : null, floating, meta }); };
        for (let val of values) { this.tree.insert(val, batchRecorder); }
        this.viz.enqueueOperation(snaps);
        this.updateUI();
    },
    runOp: function(fn, allowsUndo = true) {
        if(this.viz.isPaused) this.togglePause();
        if (this.viz.state !== 'IDLE') return;
        const snaps = [];
        if(this.tree.root) snaps.push({ root: this.tree.root.clone() }); else snaps.push({ root: null });
        fn((root, floating, meta) => snaps.push({ root: root ? root.clone() : null, floating, meta }));
        this.viz.enqueueOperation(snaps);
        if(allowsUndo) this.updateUI();
    },
    updateUI: function() { document.getElementById('btnUndo').disabled = (this.tree.history.length === 0); }
};

window.onload = () => app.init();
</script>
</body>
</html>