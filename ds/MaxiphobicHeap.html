<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maxiphobic Heap Visualizer v38: Fixed Recursion Visibility</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: #f5f5f5;
            --border-color: #ddd;
            
            /* UI Colors */
            --btn-insert: #2E7D32; 
            --btn-delete: #c62828; 
            --btn-search: #1565C0; 
            --btn-undo: #6A1B9A;   
            --btn-gray: #546E7A;
            --btn-merge: #EF6C00;
            --btn-build: #7B1FA2;
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex; flex-direction: column; 
            height: 100vh; 
            height: 100dvh; /* Mobile fix */
            overflow: hidden; user-select: none;
        }

        header {
            padding: 10px 20px; background-color: var(--panel-bg);
            display: flex; flex-direction: column; gap: 10px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .header-top { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .gui { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        
        h1 { margin: 0; font-size: 1.2rem; color: #222; }
        
        .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .sub-controls { display: flex; gap: 15px; align-items: center; font-size: 0.9rem; color: #555; vertical-align: middle;}

        input[type="number"] {
            padding: 6px; border-radius: 4px; border: 1px solid #999;
            background: #fff; color: #000; width: 60px; text-align: center; font-weight: bold;
        }
        input[type="range"] { width: 100px; cursor: pointer; }

        button {
            padding: 6px 14px; border: none; border-radius: 4px; cursor: pointer;
            font-weight: 600; color: white; transition: filter 0.2s, transform 0.1s;
            font-size: 0.85rem; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }

        .btn-insert { background-color: var(--btn-insert); }
        .btn-delete { background-color: var(--btn-delete); }
        .btn-search { background-color: var(--btn-search); }
        .btn-undo { background-color: var(--btn-undo); }
        .btn-clear { background-color: var(--btn-gray); }
        .btn-merge { background-color: var(--btn-merge); }
        .btn-build { background-color: var(--btn-build); }
        .btn-pause { background-color: #455A64; width: 80px;}
        .btn-help { background-color: #607D8B; font-size: 1.1rem; padding: 4px 10px; border-radius: 50%; }

        #canvas-container {
            flex-grow: 1; position: relative; overflow: hidden;
            background-color: var(--bg-color);
            cursor: crosshair;
            min-height: 0;
        }
        canvas { display: block; width: 100%; height: 100%; }

        #legend {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255,255,255,0.95); padding: 10px;
            border: 1px solid #ddd; border-radius: 8px; font-size: 0.8rem;
            pointer-events: none; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; color: #333; }
        .dot { width: 14px; height: 14px; border-radius: 50%; }
        .line-icon { width: 15px; height: 3px; border-radius: 2px; }
        .arrow-icon { font-size: 16px; font-weight: bold; color: #cc0000; }

        #status-bar {
            padding: 8px 2px 0px 0px; background-color: var(--panel-bg);
            font-size: 0.85rem; border-top: 1px solid var(--border-color);
            display: flex; justify-content: space-between; color: #555;
            flex-shrink: 0;
        }
        #status-text { font-weight: bold; color: #222; }

        #author { 
            width: 100%;
            background: #f4f7f6; 
            font-size: 0.75em; color: #777; text-align: center; line-height: 2.5;
            border-top: 1px solid #ddd;
            flex-shrink: 0; 
        }

        /* Modal */
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 8px; max-height: 80vh; overflow-y: auto; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: black; }
        h2 { color: #2E7D32; margin-top:0; }
        h3 { color: #1565C0; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 15px;}
        p, li { font-size: 0.95rem; line-height: 1.5; color: #333; }
        .complexity { font-family: monospace; background: #eee; padding: 2px 5px; border-radius: 4px; color: #c62828; }
    </style>
</head>
<body>

<header>
    <div class="header-top">
        <h1>Maxiphobic Heap Visualizer</h1>
        <button class="btn-help" onclick="app.toggleModal()" title="Help / Algorithms">?</button>
    </div>
    <div class="gui">
        <div class="controls">
            <input type="number" id="inputValue" title="Enter a number" placeholder="#" onkeydown="if(event.key==='Enter') app.handleInsert()">
            <button class="btn-insert" title="Insert a value" onclick="app.handleInsert()">Insert</button>
            <button class="btn-delete" title="Delete Minimum" onclick="app.handleDeleteMin()">Delete Min</button>
            <button class="btn-search" title="Show Minimum" onclick="app.handleGetMin()">Get Min</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>
            
            <button class="btn-merge" title="Merge two random trees" onclick="app.handleMergeScenario()">Merge Demo</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

            <button class="btn-build" title="Sequential Insertion (O(N log N))" onclick="app.handleRandomBuild()">Build Rand</button>
            <button class="btn-build" title="Pairwise Merge (O(N))" onclick="app.handleBottomUpBuild()">Build Bottom-Up</button>

            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>
            
            <button class="btn-undo" title="Undo last action" onclick="app.handleUndo()" id="btnUndo" disabled>Undo</button>
            <button class="btn-clear" title="Clear tree" onclick="app.handleClear()">Clear</button>
        </div>
        <div class="sub-controls">
            <label for="speedSlider">Slowdown:</label>
            <label title="Slide right to slow down animation">
                <input type="range" id="speedSlider" min="1" max="5" step="0.1" value="1" oninput="app.updateSpeed()">
            </label>
            <button class="btn-pause" title="Pause/Resume" onclick="app.togglePause()" id="btnPause">Pause</button>
        </div>
    </div>
    <div id="status-bar">
        <span id="status-text">Ready.</span>
        <span id="queue-info">Queue: 0</span>
    </div>
</header>

<div id="canvas-container">
    <canvas id="treeCanvas"></canvas>
    <div id="legend">
        <div class="legend-item"><div class="dot" style="background:#C8E6C9; border:2px solid #C8E6C9"></div>&nbsp; Tree 1 (Left)</div>
        <div class="legend-item"><div class="dot" style="background:#D1C4E9; border:2px solid #D1C4E9"></div>&nbsp; Tree 2 (Right)</div>
        <div class="legend-item"><div class="dot" style="background:#FFCC80; border:2px solid #E65100"></div>&nbsp; Comparing</div>
        <div class="legend-item"><div class="line-icon" style="background:#1565C0;"></div>&nbsp; Null Link</div>
        <div class="legend-item"><div style="border:1px solid #1565C0; border-radius:50%; width:16px; height:16px; text-align:center; font-size:9px; color:#1565C0; font-weight:bold; line-height:16px;">s</div>&nbsp; Weight</div>
    </div>
</div>

<div id="author">Pepe Gallardo. Dpto. Lenguajes y Ciencias de la Computación. Universidad de Málaga</div>

<!-- Help Modal -->
<div id="helpModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="app.toggleModal()">&times;</span>
        <h2>Maxiphobic Heap Details</h2>
        
        <h3>Definition</h3>
        <p>A <strong>Maxiphobic Heap</strong> is a variant of a leftist heap designed to minimize the path length during merges. The name comes from its strategy of "fearing the maximum" weight subtree.</p>
        
        <h3>Merge Operation</h3>
        <p>To merge two heaps $H_1$ and $H_2$:
        <ol>
            <li>Assume $root(H_1) \le root(H_2)$. If not, swap them. $H_1$ becomes the new root.</li>
            <li>Consider the three available subtrees: $H_1.left$, $H_1.right$, and the entire tree $H_2$.</li>
            <li>Select the subtree with the <strong>largest weight</strong> (most nodes).</li>
            <li>This largest subtree becomes the <strong>Left Child</strong> of $H_1$.</li>
            <li>The other two smaller subtrees are merged recursively to become the <strong>Right Child</strong>.</li>
        </ol>
        </p>
        <ul>
            <li>Complexity: <span class="complexity">O(log N)</span></li>
        </ul>
        
        <h3>Build Algorithms</h3>
        <p><strong>Build Random:</strong> <span class="complexity">O(N log N)</span></p>
        <p><strong>Build Bottom-Up:</strong> <span class="complexity">O(N)</span></p>
    </div>
</div>

<script>
const COLORS = {
    FILL1: '#C8E6C9', STROKE1: '#C8E6C9', 
    FILL2: '#D1C4E9', STROKE2: '#D1C4E9',
    COMPARE_FILL: '#FFCC80', COMPARE_STROKE: '#E65100',
    TEXT_VAL: '#000000',
    EDGE: '#1565C0',
    WEIGHT_TEXT: '#1565C0',
    WEIGHT_STROKE: '#1565C0',
    ARROW: '#D50000'
};

class Node {
    constructor(val, origin) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.val = val;
        this.weight = 1;
        this.left = null;
        this.right = null;
        this.origin = origin;
        this.x = 0; this.y = 0;
        this.highlight = false;
    }
    clone() {
        const n = new Node(this.val, this.origin);
        n.id = this.id; 
        n.weight = this.weight;
        n.highlight = this.highlight;
        n.x = this.x; n.y = this.y;
        if (this.left) n.left = this.left.clone();
        if (this.right) n.right = this.right.clone();
        return n;
    }
}

const MaxiHeap = {
    getWeight: (n) => n ? n.weight : 0,
    updateWeight: (n) => { if (n) n.weight = 1 + MaxiHeap.getWeight(n.left) + MaxiHeap.getWeight(n.right); },

    recordMerge: (rootList, h1Original, h2Original) => {
        const steps = [];
        let worldRoots = rootList.map(r => r ? r.clone() : null).filter(r => r);
        
        const snapshot = (msg, highlightIds=[]) => {
            const frames = worldRoots.map(r => r.clone());
            const mark = (n) => {
                if(!n) return;
                n.highlight = highlightIds.includes(n.id) ? 'compare' : false;
                mark(n.left); mark(n.right);
            };
            frames.forEach(mark);
            steps.push({ msg, roots: frames });
        };

        function mergeRec(t1, t2, parent) {
            if (t1 && t2) snapshot(`Comparing roots: ${t1.val} vs ${t2.val}`, [t1.id, t2.id]);

            if (!t1) {
                if (parent) {
                    // Base case: attach remaining tree
                    const idx = worldRoots.findIndex(n => n.id === t2.id);
                    if (idx !== -1) worldRoots.splice(idx, 1);
                    parent.right = t2;
                }
                return t2;
            }
            if (!t2) return t1;

            // 1. Swap roots
            if (t1.val > t2.val) {
                let temp = t1; t1 = t2; t2 = temp;
                
                // Top level logic vs Recursion logic
                if (!parent) {
                    const i1 = worldRoots.findIndex(n => n.id === t2.id);
                    const i2 = worldRoots.findIndex(n => n.id === t1.id);
                    if (i1 !== -1) worldRoots[i1] = t1;
                    if (i2 !== -1) worldRoots[i2] = t2;
                }
                
                if (!worldRoots.some(n => n.id === t2.id)) worldRoots.push(t2);
                
                if (parent) {
                    // t1 became the root of this subtree, ensure it's not in worldRoots if attached
                    const idx = worldRoots.findIndex(n => n.id === t1.id);
                    if (idx !== -1) worldRoots.splice(idx, 1);
                }

                snapshot(`Swap: ${t1.val} < ${t2.val}. ${t1.val} becomes new root.`, [t1.id, t2.id]);
            }

            // 2. Candidates
            let left = t1.left;
            let right = t1.right;
            let other = t2;

            let wL = MaxiHeap.getWeight(left);
            let wR = MaxiHeap.getWeight(right);
            let wO = MaxiHeap.getWeight(other);
            
            t1.weight = t1.weight + t2.weight;
            
            // Detach children to visualize them floating
            t1.left = null;
            t1.right = null;
            
            const addToWorld = (n) => {
                if (n && !worldRoots.some(r => r.id === n.id)) worldRoots.push(n);
            };
            addToWorld(left);
            addToWorld(right);
            addToWorld(other);
            
            let maxW = Math.max(wL, Math.max(wR, wO));
            snapshot(`Maxiphobic Selection: L(${wL}), R(${wR}), Other(${wO}). Max: ${maxW}`, [t1.id]);
            
            let small1, small2;

            if (wL === maxW) {
                t1.left = left;
                const idx = worldRoots.findIndex(n => n.id === left.id);
                if (idx !== -1) worldRoots.splice(idx, 1); 
                small1 = right;
                small2 = other;
                snapshot(`Left child (w:${wL}) is largest. Merging others.`, [t1.id]);
            } else if (wR === maxW) {
                t1.left = right;
                const idx = worldRoots.findIndex(n => n.id === right.id);
                if (idx !== -1) worldRoots.splice(idx, 1);
                small1 = left;
                small2 = other;
                snapshot(`Right child (w:${wR}) is largest. Moving to Left.`, [t1.id]);
            } else {
                t1.left = other;
                const idx = worldRoots.findIndex(n => n.id === other.id);
                if (idx !== -1) worldRoots.splice(idx, 1);
                small1 = left;
                small2 = right;
                snapshot(`Other tree (w:${wO}) is largest. Moving to Left.`, [t1.id]);
            }
            
            // 3. Recursive Merge for Right Child
            // CRITICAL FIX: Pass null as parent to keep small1/small2 visible in worldRoots during recursion
            t1.right = mergeRec(small1, small2, null);
            
            // Attach result
            if (t1.right) {
                const idx = worldRoots.findIndex(n => n.id === t1.right.id);
                if (idx !== -1) worldRoots.splice(idx, 1);
            }
            
            snapshot(`Merge step complete at ${t1.val}`, [t1.id]);
            return t1;
        }

        snapshot("Merge Start", []);
        
        let t1 = null, t2 = null;
        if (h1Original && h2Original) {
             t1 = worldRoots.find(n => n.id === h1Original.id);
             t2 = worldRoots.find(n => n.id === h2Original.id);
        }
        if (!t1 && worldRoots.length > 0) t1 = worldRoots[0];
        if (!t2 && worldRoots.length > 1) t2 = worldRoots[1];

        const res = mergeRec(t1, t2, null);
        
        worldRoots = [res];
        snapshot("Merge Complete", []);
        return steps;
    },

    createRandom: (val, origin) => new Node(val, origin)
};

const app = {
    mainTree: null, history: [], steps: [], currentStep: 0, isPlaying: false, transition: 1,
    canvas: null, ctx: null, camera: { scale: 1, x: 0, y: 0, targetScale: 1, targetX: 0, targetY: 0 },
    nodeRadius: 28, levelGap: 70,

    init: function() {
        this.canvas = document.getElementById('treeCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.canvas.addEventListener('mousedown', (e) => this.handleClick(e));
        window.onclick = (e) => { if (e.target == document.getElementById('helpModal')) app.toggleModal(); }
        this.updateUI(); this.loop();
    },

    resize: function() {
        this.canvas.width = document.getElementById('canvas-container').offsetWidth;
        this.canvas.height = document.getElementById('canvas-container').offsetHeight;
    },

    toggleModal: function() {
        const m = document.getElementById('helpModal');
        m.style.display = (m.style.display === 'block') ? 'none' : 'block';
    },

    saveState: function() {
        if(this.mainTree) this.history.push(this.mainTree.clone());
        else this.history.push(null);
        if(this.history.length > 20) this.history.shift();
        this.updateUI();
    },

    handleClick: function(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
        const w = this.canvas.width; const h = this.canvas.height;
        if (!this.vizNodes) return;
        for (let n of this.vizNodes) {
            const sx = w/2 + (n.x - this.camera.x) * this.camera.scale;
            const sy = h/2 + (n.y - this.camera.y) * this.camera.scale;
            const r = this.nodeRadius * this.camera.scale;
            if (Math.hypot(mx - sx, my - sy) < r) {
                document.getElementById('inputValue').value = n.val;
                document.getElementById('inputValue').focus();
                return;
            }
        }
    },

    handleInsert: function() {
        const val = parseInt(document.getElementById('inputValue').value);
        if (isNaN(val)) return;
        this.saveState();
        const newNode = new Node(val, 2);
        const h1 = this.mainTree ? this.mainTree.clone() : null;
        const h2 = newNode.clone();
        this.steps = MaxiHeap.recordMerge([h1, h2].filter(x=>x), h1, h2);
        this.mainTree = this.performMerge(this.mainTree, newNode);
        this.startAnimation();
        document.getElementById('inputValue').value = '';
    },

    handleDeleteMin: function() {
        if (!this.mainTree) return;
        this.saveState();
        const left = this.mainTree.left; const right = this.mainTree.right;
        const h1 = left ? left.clone() : null;
        const h2 = right ? right.clone() : null;
        const roots = [h1, h2].filter(x=>x);
        if(roots.length === 0) { this.steps = [{msg: "Heap empty", roots: []}]; this.mainTree = null; }
        else if (roots.length === 1) { this.steps = [{msg: "Root removed", roots: roots}]; this.mainTree = roots[0]; }
        else {
            this.steps = MaxiHeap.recordMerge(roots, h1, h2);
            this.mainTree = this.performMerge(this.mainTree.left, this.mainTree.right);
        }
        this.startAnimation();
    },

    handleGetMin: function() {
        if (!this.mainTree) return;
        const root = this.mainTree.clone(); root.highlight = 'compare';
        this.steps = [{ msg: `Minimum: ${root.val}`, roots: [root] }, { msg: "Ready", roots: [this.mainTree.clone()] }];
        this.startAnimation();
    },

    handleMergeScenario: function() {
        this.saveState();
        const h1 = this.createRandomTree(5, 1);
        const h2 = this.createRandomTree(4, 2);
        this.steps = MaxiHeap.recordMerge([h1, h2], h1, h2);
        this.mainTree = this.performMerge(h1.clone(), h2.clone()); 
        this.startAnimation();
    },

    handleRandomBuild: function() {
        this.handleClear();
        const vals = Array.from({length: 8}, () => Math.floor(Math.random()*99)+1);
        let tempTree = null;
        let allSteps = [{ msg: "Start Random Build", roots: [] }];
        for(let val of vals) {
            const newNode = new Node(val, 2);
            const h1 = tempTree ? tempTree.clone() : null;
            const h2 = newNode.clone();
            const mergeSteps = MaxiHeap.recordMerge([h1, h2].filter(x=>x), h1, h2);
            mergeSteps.forEach(s => s.msg = `Insert ${val}: ${s.msg}`);
            allSteps.push(...mergeSteps);
            tempTree = this.performMerge(tempTree, newNode);
        }
        this.steps = allSteps;
        this.mainTree = tempTree;
        this.startAnimation();
    },

    handleBottomUpBuild: function() {
        this.handleClear();
        const count = 12;
        let queue = Array.from({length: count}, (_, i) => new Node(Math.floor(Math.random()*99)+1, (i%2)+1));
        let allSteps = [{ msg: "Initial Queue of Trees", roots: queue.map(r=>r.clone()) }];
        while(queue.length > 1) {
            const h1 = queue.shift();
            const h2 = queue.shift();
            const contextRoots = [h1, h2, ...queue];
            const mergeSteps = MaxiHeap.recordMerge(contextRoots, h1, h2);
            mergeSteps.forEach(s => s.msg = `Merging Pair: ${s.msg}`);
            allSteps.push(...mergeSteps);
            const merged = this.performMerge(h1, h2);
            queue.push(merged);
            allSteps.push({ msg: "Pair merged, added to queue", roots: queue.map(r => r.clone()) });
        }
        this.mainTree = queue[0];
        this.steps = allSteps;
        this.startAnimation();
    },

    handleUndo: function() {
        if (this.history.length > 0) {
            this.mainTree = this.history.pop();
            this.steps = [{ msg: "Undo successful", roots: this.mainTree ? [this.mainTree] : [] }];
            this.startAnimation();
            this.isPlaying = false; this.transition = 1; this.updateUI();
        }
    },

    handleClear: function() {
        this.saveState();
        this.mainTree = null;
        this.steps = [{ msg: "Cleared", roots: [] }];
        this.startAnimation();
    },

    createRandomTree: function(n, origin) {
        let t = null;
        for(let i=0; i<n; i++) {
            const val = Math.floor(Math.random()*100);
            t = this.performMerge(t, new Node(val, origin));
        }
        return t;
    },

    performMerge: function(h1, h2) {
        if (!h1) return h2;
        if (!h2) return h1;
        if (h1.val > h2.val) { let temp = h1; h1 = h2; h2 = temp; }
        let left = h1.left;
        let right = h1.right;
        let other = h2;
        let wL = MaxiHeap.getWeight(left);
        let wR = MaxiHeap.getWeight(right);
        let wO = MaxiHeap.getWeight(other);
        let maxW = Math.max(wL, Math.max(wR, wO));
        
        if (wL === maxW) {
            h1.right = this.performMerge(right, other);
        } else if (wR === maxW) {
            h1.left = right;
            h1.right = this.performMerge(left, other);
        } else {
            h1.left = other;
            h1.right = this.performMerge(left, right);
        }
        MaxiHeap.updateWeight(h1);
        return h1;
    },

    startAnimation: function() {
        this.currentStep = 0; this.transition = 0; this.isPlaying = true; this.updateUI();
    },

    updateUI: function() {
        document.getElementById('status-text').innerText = this.steps[this.currentStep]?.msg || "Ready.";
        document.getElementById('queue-info').innerText = `Step: ${this.steps.length>0 ? this.currentStep+1 : 0} / ${this.steps.length}`;
        document.getElementById('btnUndo').disabled = this.history.length === 0;
        document.getElementById('btnPause').innerText = (this.currentStep === this.steps.length - 1 && !this.isPlaying && this.steps.length > 1) ? "Restart" : (this.isPlaying ? "Pause" : "Resume");
    },

    togglePause: function() {
        if (this.currentStep === this.steps.length - 1) { this.currentStep = 0; this.transition = 0; }
        this.isPlaying = !this.isPlaying; this.updateUI();
    },

    updateSpeed: function() {},

    loop: function(ts) {
        if (!this.lastTime) this.lastTime = ts;
        let dt = ts - this.lastTime; this.lastTime = ts;
        dt /= parseFloat(document.getElementById('speedSlider').value);

        this.camera.x += (this.camera.targetX - this.camera.x) * 0.1;
        this.camera.y += (this.camera.targetY - this.camera.y) * 0.1;
        this.camera.scale += (this.camera.targetScale - this.camera.scale) * 0.1;

        if (this.isPlaying) {
            this.transition += dt * 0.0015; 
            if (this.transition >= 1.3) { 
                this.transition = 0;
                if (this.currentStep < this.steps.length - 1) { this.currentStep++; this.updateUI(); }
                else { this.isPlaying = false; this.transition = 1; this.updateUI(); }
            }
        } else {
            if (this.transition < 1) this.transition += dt * 0.005; else this.transition = 1;
        }
        this.draw(); requestAnimationFrame((t) => this.loop(t));
    },

    draw: function() {
        const ctx = this.ctx; const w = this.canvas.width; const h = this.canvas.height;
        ctx.clearRect(0, 0, w, h);
        if (this.steps.length === 0) return;

        const curSnap = this.steps[this.currentStep];
        const prevSnap = this.currentStep > 0 ? this.steps[this.currentStep - 1] : curSnap;
        const layoutCur = this.layoutInOrder(curSnap.roots);
        const layoutPrev = this.layoutInOrder(prevSnap.roots);
        
        this.fitCamera([...this.flatten(layoutCur), ...this.flatten(layoutPrev)], w, h);

        let t = Math.min(Math.max(this.transition, 0), 1);
        const easeT = t < .5 ? 2*t*t : -1+(4-2*t)*t;
        const prevMap = new Map();
        this.flatten(layoutPrev).forEach(n => prevMap.set(n.id, {x:n.x, y:n.y}));

        ctx.save();
        ctx.translate(w/2, h/2); ctx.scale(this.camera.scale, this.camera.scale); ctx.translate(-this.camera.x, -this.camera.y);
        
        layoutCur.forEach(r => this.drawLinksRec(r, prevMap, easeT));
        this.vizNodes = [];
        layoutCur.forEach(r => this.drawNodesRec(r, prevMap, easeT));
        ctx.restore();
    },

    layoutInOrder: function(roots) {
        const clones = roots.map(r => r.clone());
        let counter = 0; const X_SPACING = 70; 
        const traverse = (n, depth) => {
            if(!n) return;
            traverse(n.left, depth+1);
            n.x = counter * X_SPACING; n.y = 50 + depth * this.levelGap;
            counter++;
            traverse(n.right, depth+1);
        };
        clones.forEach(root => { traverse(root, 0); counter += 1; });
        return clones;
    },
    
    fitCamera: function(nodes, w, h) {
        if (nodes.length === 0) return;
        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        nodes.forEach(n => {
            minX = Math.min(minX, n.x - 40); maxX = Math.max(maxX, n.x + 40);
            minY = Math.min(minY, n.y - 40); maxY = Math.max(maxY, n.y + 40);
        });
        const sc = Math.min(w/(maxX-minX+100), h/(maxY-minY+150), 1.1);
        this.camera.targetScale = sc;
        this.camera.targetX = (minX+maxX)/2; this.camera.targetY = minY + (maxY-minY)/2;
    },

    drawLinksRec: function(node, prevMap, t) {
        if (!node) return;
        let cx = node.x, cy = node.y;
        const p = prevMap.get(node.id);
        if(p) { cx = p.x + (node.x-p.x)*t; cy = p.y + (node.y-p.y)*t; }
        
        if(!node.left) this.drawNull(cx, cy, 'L');
        if(!node.right) this.drawNull(cx, cy, 'R');
        
        const line = (child) => {
            let chx = child.x, chy = child.y;
            const cp = prevMap.get(child.id);
            if(cp) { chx = cp.x + (child.x-cp.x)*t; chy = cp.y + (child.y-cp.y)*t; }
            this.ctx.beginPath(); this.ctx.moveTo(cx, cy); this.ctx.lineTo(chx, chy);
            this.ctx.strokeStyle = COLORS.EDGE; this.ctx.lineWidth = 3; this.ctx.stroke();
        };
        if(node.left) { line(node.left); this.drawLinksRec(node.left, prevMap, t); }
        if(node.right) { line(node.right); this.drawLinksRec(node.right, prevMap, t); }
    },
    
    drawNull: function(x, y, dir) {
        const dx = dir === 'L' ? -15 : 15; const dy = 25;
        this.ctx.beginPath(); this.ctx.moveTo(x, y+this.nodeRadius/2); this.ctx.lineTo(x+dx, y+this.nodeRadius+dy);
        this.ctx.strokeStyle = COLORS.EDGE; this.ctx.lineWidth = 3; this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.moveTo(x+dx-5, y+this.nodeRadius+dy); this.ctx.lineTo(x+dx+5, y+this.nodeRadius+dy); this.ctx.stroke();
    },

    drawNodesRec: function(n, prevMap, t) {
        if(!n) return;
        let cx = n.x, cy = n.y;
        const p = prevMap.get(n.id);
        if(p) { cx = p.x + (n.x-p.x)*t; cy = p.y + (n.y-p.y)*t; } else this.ctx.globalAlpha = t;
        
        this.vizNodes.push({x:cx, y:cy, val:n.val});

        const ctx = this.ctx;
        let fill = n.origin===1 ? COLORS.FILL1 : COLORS.FILL2;
        let stroke = n.origin===1 ? COLORS.STROKE1 : COLORS.STROKE2;
        if(n.highlight === 'compare') { fill = COLORS.COMPARE_FILL; stroke = COLORS.COMPARE_STROKE; }

        ctx.beginPath(); ctx.arc(cx, cy, this.nodeRadius, 0, 2*Math.PI);
        ctx.fillStyle = fill; ctx.fill(); ctx.strokeStyle = stroke; ctx.lineWidth = 3; ctx.stroke();
        
        ctx.fillStyle = COLORS.TEXT_VAL; ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(n.val, cx, cy+1);

        const bx = cx+this.nodeRadius-5; const by = cy-this.nodeRadius+5;
        ctx.beginPath(); ctx.arc(bx, by, 10, 0, 2*Math.PI);
        ctx.fillStyle = '#ffffff'; ctx.fill(); ctx.strokeStyle = COLORS.WEIGHT_STROKE; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = COLORS.WEIGHT_TEXT; ctx.font = 'bold 11px Arial'; ctx.fillText(n.weight, bx, by+1);

        ctx.globalAlpha = 1;
        this.drawNodesRec(n.left, prevMap, t); this.drawNodesRec(n.right, prevMap, t);
    },

    flatten: function(roots) {
        let list = [];
        const t = (n) => { if(!n)return; list.push(n); t(n.left); t(n.right); };
        roots.forEach(t);
        return list;
    }
};
app.init();
</script>
</body>
</html>