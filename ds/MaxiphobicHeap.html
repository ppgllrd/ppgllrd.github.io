<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maxiphobic Min-Heap Visualizer</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: #f5f5f5;
            --border-color: #ddd;
            
            /* UI Colors */
            --btn-insert: #2E7D32; 
            --btn-delete: #c62828; 
            --btn-search: #1668BD; 
            --btn-undo: #6A1B9A;   
            --btn-gray: #546E7A;
            --btn-merge: #EF6C00;
            --btn-build: #7B1FA2; 
            --btn-merges: #00838F; 
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex; flex-direction: column; 
            height: 100vh; 
            height: 100dvh; 
            overflow: hidden; user-select: none;
        }

        header {
            padding: 10px 20px; background-color: var(--panel-bg);
            display: flex; flex-direction: column; gap: 10px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .header-top { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .gui { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        
        h1 { margin: 0; font-size: 1.2rem; color: #222; }
        
        .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .sub-controls { display: flex; gap: 15px; align-items: center; font-size: 0.9rem; color: #555; vertical-align: middle;}

        input[type="number"] {
            padding: 6px; border-radius: 4px; border: 1px solid #999;
            background: #fff; color: #000; width: 60px; text-align: center; font-weight: bold;
        }
        input[type="range"] { width: 100px; cursor: pointer; }

        button {
            padding: 6px 14px; border: none; border-radius: 4px; cursor: pointer;
            font-weight: 600; color: white; transition: filter 0.2s, transform 0.1s;
            font-size: 0.85rem; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }

        .btn-insert { background-color: var(--btn-insert); }
        .btn-delete { background-color: var(--btn-delete); }
        .btn-search { background-color: var(--btn-search); }
        .btn-undo { background-color: var(--btn-undo); }
        .btn-clear { background-color: var(--btn-gray); }
        .btn-merge { background-color: var(--btn-merge); }
        .btn-build { background-color: var(--btn-build); }
        .btn-merges { background-color: var(--btn-merges); }
        .btn-pause { background-color: #455A64; width: 80px;}
        .btn-help { background-color: #607D8B; font-size: 1.1rem; padding: 4px 10px; border-radius: 50%; }

        #canvas-container {
            flex-grow: 1; position: relative; overflow: hidden;
            background-color: var(--bg-color);
            cursor: default;
            min-height: 0;
        }
        canvas { display: block; width: 100%; height: 100%; }

        #legend {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255,255,255,0.95); padding: 10px;
            border: 1px solid #ddd; border-radius: 8px; font-size: 0.8rem;
            pointer-events: none; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; color: #333; }
        .dot { width: 14px; height: 14px; border-radius: 50%; }
        .line-icon { width: 15px; height: 3px; border-radius: 2px; }

        #status-bar {
            padding: 8px 2px 0px 0px; background-color: var(--panel-bg);
            font-size: 0.85rem; border-top: 1px solid var(--border-color);
            display: flex; justify-content: space-between; color: #555;
            flex-shrink: 0;
        }
        #status-text { font-weight: bold; color: #222; }

        #author { 
            width: 100%;
            background: #f4f7f6; 
            font-size: 0.75em; color: #777; text-align: center; line-height: 2.5;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }

        /* Modal */
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 8px; max-height: 80vh; overflow-y: auto; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: black; }
        h2 { color: #2E7D32; margin-top:0; }
        h3 { color: #1668BD; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 15px;}
        p, li { font-size: 0.95rem; line-height: 1.5; color: #333; }
        .complexity { font-family: monospace; background: #eee; padding: 2px 5px; border-radius: 4px; color: #c62828; }
        .node-sample {
            display: inline-block; width: 30px; height: 30px; border-radius: 50%;
            background: #B0F9B0; border: 1px solid #B0F9B0;
            text-align: center; line-height: 30px; position: relative;
            font-family: Arial, sans-serif; font-weight: bold;
        }    
        .node-val { color: #D50000; font-size: 12px; }
        .node-weight { 
            position: absolute; bottom: -2px; right: -2px; 
            font-size: 10px; color: #1565C0; background: rgba(255,255,255,0.8); 
            border-radius: 50%; padding: 1px 3px;
        }
    </style>
</head>
<body>

<header>
    <div class="header-top">
        <h1>Maxiphobic Min-Heap Visualizer</h1>
        <button class="btn-help" onclick="app.toggleModal()" title="Help / Algorithms">?</button>
    </div>
    <div class="gui">
        <div class="controls">
            <input type="number" id="inputValue" title="Enter a number" placeholder="#" onkeydown="if(event.key==='Enter') app.handleInsert()">
            <button class="btn-insert" title="Insert a value" onclick="app.handleInsert()">Insert</button>
            <button class="btn-delete" title="Delete the minimum element (Root)" onclick="app.handleDeleteMin()">Delete Minimum</button>
            <button class="btn-search" title="Show minimum element" onclick="app.handleGetMin()">Minimum</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>
            
            <button class="btn-merge" title="Merge two random Maxiphobic heaps" onclick="app.handleMergeScenario()">Merge</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

            <button class="btn-build" title="Sequential Insertion (O(n log n))" onclick="app.handleRandomBuild()">Build Random</button>
            <button class="btn-merges" title="Pairwise Merge (O(n))" onclick="app.handleBottomUpBuild()">Build Bottom-Up</button>

            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>
            
            <button class="btn-undo" title="Undo last action" onclick="app.handleUndo()" id="btnUndo" disabled>Undo</button>
            <button class="btn-clear" title="Clear tree" onclick="app.handleClear()">Clear</button>
        </div>
        <div class="sub-controls">
            <label for="speedSlider">Slowdown:</label>
            <label title="Slide right to slow down the animation">
                <input type="range" id="speedSlider" min="1" max="5" step="0.1" value="1" oninput="app.updateSpeed()">
            </label>
            <button class="btn-pause" title="Pause/Resume" onclick="app.togglePause()" id="btnPause">Pause</button>
        </div>
    </div>
    <div id="status-bar">
        <span id="status-text">Ready. Use Mouse/Touch to Pan & Zoom.</span>
    </div>
</header>

<div id="canvas-container">
    <canvas id="treeCanvas"></canvas>
    <div id="legend">
        <div class="legend-item">
            <div class="node-sample"><span class="node-val">V</span><span class="node-weight">w</span></div>&nbsp; Value / Weight
        </div>
        <div class="legend-item"><div class="dot" style="background:#B0F9B0; border:2px solid #B0F9B0"></div>&nbsp; Tree 1 (Left)</div>
        <div class="legend-item"><div class="dot" style="background:#99FFFF; border:2px solid #99FFFF"></div>&nbsp; Tree 2 (Right)</div>
        <div class="legend-item"><div class="dot" style="background:#CC99FF; border:2px solid #CC99FF"></div>&nbsp; Comparing/Selected</div>
        <div class="legend-item"><div class="dot" style="width:10px; height:10px; background:#F44336; border:1px solid #F44336"></div>&nbsp; Max Weight (Winner)</div>
        <div class="legend-item"><div class="line-icon" style="background:#1668BD;"></div>&nbsp; Null Link</div>
    </div>
</div>

<div id="author">Pepe Gallardo. Dpto. Lenguajes y Ciencias de la Computación. Universidad de Málaga</div>

<!-- Help Modal -->
<div id="helpModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="app.toggleModal()">&times;</span>
        <h2>Algorithm Details</h2>
        
        <h3>Maxiphobic Heap</h3>
        <p>A <strong>Maxiphobic Heap</strong> is a kind of heap designed to minimize the path length during merges by avoiding the "heavy" side. It maintains the usual Min-Heap property but determines structure based on subtree weights.</p>
        
        <h3>Operations</h3>

        <p><strong>Minimum:</strong> <span class="complexity">O(1)</span><br>
        The minimum element is always at the root of the tree.</p>

        <p><strong>Insert:</strong> <span class="complexity">O(log n)</span><br>
        Creates a new single-node heap with the value and merges it with the existing heap.</p>

        <p><strong>Delete Minimum:</strong> <span class="complexity">O(log n)</span><br>
        Removes the root node. The left and right subtrees of the root are then merged to form the new heap.</p>

        <p><strong>Merge:</strong> <span class="complexity">O(log n)</span><br>
        Merges two heaps <b>H<sub>1</sub></b> and <b>H<sub>2</sub></b> recursively:
        <ol>
            <li>Compare roots. The smaller root stays as the parent.</li>
            <li>Consider three candidates: <b>H<sub>1</sub>.left</b>, <b>H<sub>1</sub>.right</b>, and <b>H<sub>2</sub></b>.</li>
            <li><strong>Maxiphobic Rule:</strong> The candidate with the <strong>largest weight</strong> (most nodes) becomes the Left Child.</li>
            <li>The other two smaller candidates are merged recursively to form the Right Child.</li>
        </ol>
        </p>

        <h3>Build Algorithms</h3>
        <p><strong>Build Random (Sequential):</strong> <span class="complexity">O(n log n)</span><br>
        Inserts elements one by one into an initially empty heap.</p>
        
        <p><strong>Build Bottom-Up (Pairwise):</strong> <span class="complexity">O(n)</span><br>
        Places all elements as single-node heaps in a queue. Repeatedly takes the first two heaps, merges them, and places the result at the end of the queue.</p>
    </div>
</div>

<script>
const COLORS = {
    FILL1: '#99FFFF', STROKE1: '#99FFFF',
    FILL2: '#B0F9B0', STROKE2: '#B0F9B0', 
    COMPARE_FILL: '#CC99FF', COMPARE_STROKE: '#CC99FF',
    MINIMUM: '#CC99FF',    
    DELETE: '#D32F2F',
    TEXT_VAL: '#CC0000',
    EDGE: '#1668BD',
    WEIGHT_TEXT: '#1668BD',
    WEIGHT_STROKE: '#1668BD',
    WEIGHT_HIGHLIGHT: '#F44336', // Red
    ARROW: '#D50000'
};

class Node {
    constructor(val, origin) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.val = val;
        this.weight = 1;
        this.left = null;
        this.right = null;
        this.origin = origin;
        this.x = 0; this.y = 0;
        this.highlight = false;
        this.highlightWeight = false; 
    }
    clone() {
        const n = new Node(this.val, this.origin);
        n.id = this.id; 
        n.weight = this.weight;
        n.highlight = this.highlight;
        n.highlightWeight = this.highlightWeight;
        n.x = this.x; n.y = this.y;
        if (this.left) n.left = this.left.clone();
        if (this.right) n.right = this.right.clone();
        return n;
    }
}

const MaxiHeap = {
    getWeight: (n) => n ? n.weight : 0,

    recordMerge: (rootList, h1Original, h2Original) => {
        const steps = [];
        let worldRoots = rootList.map(r => r ? r.clone() : null).filter(r => r);
        
        let unrelatedQueue = [];
        let t1 = null, t2 = null;

        if (h1Original && h2Original) {
             t1 = worldRoots.find(n => n.id === h1Original.id);
             t2 = worldRoots.find(n => n.id === h2Original.id);
        }
        if (!t1 && worldRoots.length > 0) t1 = worldRoots[0];
        if (!t2 && worldRoots.length > 1) t2 = worldRoots[1];

        if (!t1 && !t2) return steps;
        if (!t1 || !t2) {
             let survivor = t1 || t2;
             unrelatedQueue = worldRoots.filter(x => x && x.id !== survivor.id);
             steps.push({ msg: "One heap is empty. No merge needed.", roots: [survivor, ...unrelatedQueue] });
             return steps;
        }

        unrelatedQueue = worldRoots.filter(r => r.id !== t1.id && r.id !== t2.id);
        let mainTree = t1; 
        let floatingTree = t2;

        const takeSnapshot = (msg, floatingNodes = [], highlightIds = [], weightHighlightIds = []) => {
            let frameRoots = [mainTree, ...floatingNodes, ...unrelatedQueue].filter(x => x);
            let frames = frameRoots.map(r => r.clone());
            const mark = (n) => {
                if(!n) return;
                n.highlight = highlightIds.includes(n.id) ? 'compare' : false;
                if(weightHighlightIds.includes(n.id)) n.highlightWeight = true;
                mark(n.left); mark(n.right);
            };
            frames.forEach(mark);
            steps.push({ msg, roots: frames });
        };

        takeSnapshot(`Merging trees ${t1.val} and ${t2.val}`, [floatingTree]);

        function mergeRec(t1, t2, parent) {
            if (!t1 && !t2) return null;
            
            if (!t1) {
                if (parent) {
                    parent.right = t2;
                    takeSnapshot(`Attaching ${t2.val}`, [], [t2.id]);
                }
                return t2;
            }
            if (!t2) {
                takeSnapshot(`Attaching ${t1.val}`, [], [t1.id]);
                return t1;
            }

            let winnerNode = (t1.val <= t2.val) ? t1 : t2;
            let floaterNode = (t1.val <= t2.val) ? t2 : t1;
        
            if (parent) {
                parent.right = winnerNode;
            } else {
                mainTree = winnerNode;
            }

            takeSnapshot(`Comparing roots: ${t1.val} vs ${t2.val}`, [floaterNode], [t1.id, t2.id]);

            t1 = winnerNode;
            t2 = floaterNode;

            t1.weight = t1.weight + t2.weight;

            let left = t1.left;
            let right = t1.right;
            let other = t2;

            t1.left = null;
            t1.right = null;
            
            let wL = MaxiHeap.getWeight(left);
            let wR = MaxiHeap.getWeight(right);
            let wO = MaxiHeap.getWeight(other);
            let maxW = Math.max(wL, Math.max(wR, wO));

            let winner, loser1, loser2;
            let choiceMsg = "";

            if (wL === maxW) {
                winner = left; loser1 = right; loser2 = other;
                choiceMsg = `Left child (weight ${wL}) is heaviest.`;
            } else if (wR === maxW) {
                winner = right; loser1 = left; loser2 = other;
                choiceMsg = `Right child (weight ${wR}) is heaviest. Moves to Left.`;
            } else {
                winner = other; loser1 = left; loser2 = right;
                choiceMsg = `Other tree (weight ${wO}) is heaviest. Moves to Left.`;
            }

            let floats = [left, right, other].filter(x=>x);
            takeSnapshot(`Candidates: L(weight ${wL}), R(weight ${wR}), Other(weight ${wO})`, floats, [t1.id]);

            let weightHighs = winner ? [winner.id] : [];

            takeSnapshot(`${choiceMsg}`, floats, [t1.id], weightHighs);

            t1.left = winner;
            
            let nextFloats = [loser1, loser2].filter(x=>x);
            takeSnapshot(`${choiceMsg} Recurse with remaining two.`, nextFloats, [t1.id], weightHighs);

            takeSnapshot(`${choiceMsg} Recurse with remaining two.`, nextFloats, [], []);

            t1.right = loser1;
            t1.right = mergeRec(loser1, loser2, t1);
            
            return t1;
        }

        mergeRec(mainTree, floatingTree, null);
        takeSnapshot("Merge Complete.", []);
        return steps;
    }
};

const app = {
    mainTree: null, history: [], steps: [], currentStep: 0, isPlaying: false, transition: 1,
    canvas: null, ctx: null, 
    
    // Camera & Navigation
    currentSpeedFactor: 1.0,
    baseMorphSpeed: 3.0, 
    camera: { scale: 1, x: 0, y: 0, targetScale: 1, targetX: 0, targetY: 0 },
    isDragging: false,
    dragStart: { x: 0, y: 0 },
    initialCamera: { x: 0, y: 0 },
    initialPinchDist: 0,
    initialScale: 1,
    hoveredNode: null,

    nodeRadius: 28, levelGap: 70,

    init: function() {
        this.canvas = document.getElementById('treeCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Unified Events
        this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', e => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', e => this.onMouseUp(e));
        this.canvas.addEventListener('mouseleave', e => this.onMouseUp(e));
        this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });
        this.canvas.addEventListener('touchstart', e => this.onTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', e => this.onTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', e => this.onTouchEnd(e));

        window.onclick = (e) => { if (e.target == document.getElementById('helpModal')) app.toggleModal(); }
        this.updateUI(); 
        this.lastTime = 0;
        requestAnimationFrame(t => this.loop(t));
    },

    resize: function() {
        this.canvas.width = document.getElementById('canvas-container').offsetWidth;
        this.canvas.height = document.getElementById('canvas-container').offsetHeight;
    },

    toggleModal: function() {
        const m = document.getElementById('helpModal');
        m.style.display = (m.style.display === 'block') ? 'none' : 'block';
    },

    saveState: function() {
        if(this.mainTree) this.history.push(this.mainTree.clone());
        else this.history.push(null);
        if(this.history.length > 20) this.history.shift();
        this.updateUI();
    },

    // --- INPUT HANDLING ---

    checkNodeHit: function (mx, my) {
        if (!this.vizNodes) return null;
        const w = this.canvas.width; const h = this.canvas.height;
        for (let n of this.vizNodes) {
            const sx = w / 2 + (n.x - this.camera.x) * this.camera.scale;
            const sy = h / 2 + (n.y - this.camera.y) * this.camera.scale;
            const r = this.nodeRadius * this.camera.scale;
            if (Math.hypot(mx - sx, my - sy) < r) return n;
        }
        return null;
    },

    onMouseDown: function (e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left; const my = e.clientY - rect.top;

        const node = this.checkNodeHit(mx, my);
        if (node) {
            document.getElementById('inputValue').value = node.val;
            // document.getElementById('inputValue').focus();
            return;
        }

        this.isDragging = true;
        this.dragStart = { x: mx, y: my };
        this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };
        this.canvas.style.cursor = 'grabbing';
    },

    onMouseMove: function (e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left; const my = e.clientY - rect.top;

        this.hoveredNode = this.checkNodeHit(mx, my);
        if (this.isDragging) this.canvas.style.cursor = 'grabbing';
        else if (this.hoveredNode) this.canvas.style.cursor = 'pointer';
        else this.canvas.style.cursor = 'default';

        if (!this.isDragging) return;

        const dx = mx - this.dragStart.x;
        const dy = my - this.dragStart.y;

        this.camera.targetX = this.initialCamera.x - (dx / this.camera.scale);
        this.camera.targetY = this.initialCamera.y - (dy / this.camera.scale);
    },

    onMouseUp: function () {
        this.isDragging = false;
        this.canvas.style.cursor = this.hoveredNode ? 'pointer' : 'default';
    },

    onWheel: function (e) {
        e.preventDefault();
        const zoomIntensity = 0.001;
        const scroll = e.deltaY;
        let newScale = this.camera.targetScale * (1 - scroll * zoomIntensity);
        newScale = Math.min(Math.max(0.2, newScale), 5);

        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
        const w = this.canvas.width; const h = this.canvas.height;

        // World coordinates under mouse
        const worldX = this.camera.targetX + (mx - w / 2) / this.camera.targetScale;
        const worldY = this.camera.targetY + (my - h / 2) / this.camera.targetScale;

        this.camera.targetScale = newScale;
        // Adjust translation to keep world point under mouse
        this.camera.targetX = worldX - (mx - w / 2) / newScale;
        this.camera.targetY = worldY - (my - h / 2) / newScale;
    },

    getTouchDist: function (touches) {
        return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
    },

    onTouchStart: function (e) {
        if (e.touches.length === 1) {
            const t = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const mx = t.clientX - rect.left; const my = t.clientY - rect.top;

            const node = this.checkNodeHit(mx, my);
            if (node) {
                document.getElementById('inputValue').value = node.val;
                // document.getElementById('inputValue').focus();
                return;
            }
            this.isDragging = true;
            this.dragStart = { x: mx, y: my };
            this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };
        } else if (e.touches.length === 2) {
            this.isDragging = false;
            this.initialPinchDist = this.getTouchDist(e.touches);
            this.initialScale = this.camera.targetScale;
        }
    },

    onTouchMove: function (e) {
        e.preventDefault();
        if (e.touches.length === 1 && this.isDragging) {
            const t = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const mx = t.clientX - rect.left; const my = t.clientY - rect.top;
            const dx = mx - this.dragStart.x; const dy = my - this.dragStart.y;
            this.camera.targetX = this.initialCamera.x - (dx / this.camera.scale);
            this.camera.targetY = this.initialCamera.y - (dy / this.camera.scale);
        } else if (e.touches.length === 2) {
            const dist = this.getTouchDist(e.touches);
            if (this.initialPinchDist > 0) {
                const scaleFactor = dist / this.initialPinchDist;
                this.camera.targetScale = Math.min(Math.max(0.2, this.initialScale * scaleFactor), 5);
            }
        }
    },

    onTouchEnd: function () {
        this.isDragging = false;
        this.initialPinchDist = 0;
    },

    // --- ACTIONS ---

    handleInsert: function() {
        const val = parseInt(document.getElementById('inputValue').value);
        if (isNaN(val)) return;
        this.saveState();
        const newNode = new Node(val, 2); 
        const h1 = this.mainTree ? this.mainTree.clone() : null;
        const h2 = newNode.clone();
        this.steps = MaxiHeap.recordMerge([h1, h2].filter(x=>x), h1, h2);
        this.mainTree = this.performMerge(this.mainTree, newNode);
        this.startAnimation();
        document.getElementById('inputValue').value = '';
    },

    handleDeleteMin: function() {
        if (!this.mainTree) return;
        this.saveState();

        const rootToDelete = this.mainTree.clone();
        rootToDelete.highlight = 'delete-target'; 

        const left = this.mainTree.left; 
        const right = this.mainTree.right;
        const h1 = left ? left.clone() : null;
        const h2 = right ? right.clone() : null;
        const childrenRoots = [h1, h2].filter(x => x);
        let mergeSteps = [];
        let finalTree = null;

        if (childrenRoots.length === 0) {
            mergeSteps = [{msg: "Heap empty", roots: []}];
            finalTree = null;
        } else if (childrenRoots.length === 1) {
            mergeSteps = [{msg: "Root removed. Single child remains.", roots: [childrenRoots[0]]}];
            finalTree = childrenRoots[0];
        } else {
            mergeSteps = MaxiHeap.recordMerge(childrenRoots, h1, h2);
            finalTree = this.performMerge(this.mainTree.left, this.mainTree.right);
        }
        this.steps = [
            { msg: "Selected Minimum for Deletion", roots: [rootToDelete] }, 
            { msg: "Removing root...", roots: childrenRoots },
            ...mergeSteps 
        ];
        this.mainTree = finalTree;
        this.startAnimation();
    },

    handleGetMin: function() {
        if (!this.mainTree) return;
        const root = this.mainTree.clone(); root.highlight = 'minimum';
        this.steps = [{ msg: `Minimum: ${root.val}`, roots: [root] }, { msg: "Ready", roots: [this.mainTree.clone()] }];
        this.startAnimation();
    },

    handleMergeScenario: function() {
        this.saveState();
        const h1 = this.createRandomTree(8, 1);
        const h2 = this.createRandomTree(6, 2);
        this.steps = MaxiHeap.recordMerge([h1, h2], h1, h2);
        this.mainTree = this.performMerge(h1.clone(), h2.clone()); 
        this.startAnimation();
    },
    
    handleRandomBuild: function() {
        this.handleClear();
        const vals = Array.from({length: 8}, () => Math.floor(Math.random()*99)+1);
        let tempTree = null;
        let allSteps = [{ msg: "Start Random Build (O(n log n))", roots: [] }];
        for(let val of vals) {
            const newNode = new Node(val, 2);
            const h1 = tempTree ? tempTree.clone() : null;
            const h2 = newNode.clone();
            let contextRoots = [h1, h2].filter(x=>x);
            const mergeSteps = MaxiHeap.recordMerge(contextRoots, h1, h2);
            mergeSteps.forEach(s => s.msg = `Insert ${val}: ${s.msg}`);
            allSteps.push(...mergeSteps);
            tempTree = this.performMerge(tempTree, newNode);
        }
        this.steps = allSteps;
        this.mainTree = tempTree;
        this.startAnimation();
    },
    
    handleBottomUpBuild: function() {
        this.handleClear();
        const count = 12;
        let queue = Array.from({length: count}, (_, i) => new Node(Math.floor(Math.random()*99)+1, (i%2)+1));
        let allSteps = [{ msg: "Initial Queue of Trees (O(n))", roots: queue.map(r=>r.clone()) }];
        
        while(queue.length > 1) {
            const h1 = queue.shift();
            const h2 = queue.shift();
            const contextRoots = [h1, h2, ...queue];
            const mergeSteps = MaxiHeap.recordMerge(contextRoots, h1, h2);
            mergeSteps.forEach(s => s.msg = `Merging Pair: ${s.msg}`);
            allSteps.push(...mergeSteps);
            const merged = this.performMerge(h1, h2);
            queue.push(merged);
            allSteps.push({ msg: "Pair merged. Moved to end of queue.", roots: queue.map(r => r.clone()) });
        }
        this.mainTree = queue[0];
        this.steps = allSteps;
        this.startAnimation();
    },

    handleUndo: function() {
        if (this.history.length > 0) {
            this.mainTree = this.history.pop();
            this.steps = [{ msg: "Undo successful", roots: this.mainTree ? [this.mainTree] : [] }];
            this.startAnimation();
            this.isPlaying = false; this.transition = 1; this.updateUI();
        }
    },

    handleClear: function() {
        this.saveState();
        this.mainTree = null;
        this.steps = [{ msg: "Cleared", roots: [] }];
        this.startAnimation();
    },

    createRandomTree: function(n, origin) {
        let t = null;
        for(let i=0; i<n; i++) {
            const val = Math.floor(Math.random()*100);
            t = this.performMerge(t, new Node(val, origin));
        }
        return t;
    },

    performMerge: function(h1, h2) {
        if (!h1) return h2;
        if (!h2) return h1;
        if (h1.val > h2.val) { let temp = h1; h1 = h2; h2 = temp; }
        
        let w1 = h1.weight; let w2 = h2.weight;
        let left = h1.left;
        let right = h1.right;
        let other = h2;
        let wL = MaxiHeap.getWeight(left);
        let wR = MaxiHeap.getWeight(right);
        let wO = MaxiHeap.getWeight(other);
        let maxW = Math.max(wL, Math.max(wR, wO));

        if (wL === maxW) {
            h1.left = left;
            h1.right = this.performMerge(right, other);
        } else if (wR === maxW) {
            h1.left = right;
            h1.right = this.performMerge(left, other);
        } else {
            h1.left = other;
            h1.right = this.performMerge(left, right);
        }
        h1.weight = w1 + w2; 
        return h1;
    },

    startAnimation: function() {
        this.currentStep = 0; this.transition = 0; this.isPlaying = true; this.updateUI();
        this.fitToAllSteps();
    },

    fitToAllSteps: function () {
        if (this.steps.length === 0) return;
        const frames = [this.steps[0]];
        if (this.steps.length > 1) frames.push(this.steps[this.steps.length - 1]);

        let allNodes = [];
        frames.forEach(frame => {
            const layout = this.layoutInOrder(frame.roots);
            allNodes.push(...this.flatten(layout));
        });

        const w = this.canvas.width; const h = this.canvas.height;
        if (allNodes.length === 0) {
            this.camera.targetScale = 1; this.camera.targetX = 0; this.camera.targetY = 0;
            return;
        }

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        allNodes.forEach(n => {
            minX = Math.min(minX, n.x - 40); maxX = Math.max(maxX, n.x + 40);
            minY = Math.min(minY, n.y - 40); maxY = Math.max(maxY, n.y + 40);
        });

        const sc = Math.min(w / (maxX - minX + 100), h / (maxY - minY + 150), 1.1);
        this.camera.targetScale = sc;
        this.camera.targetX = (minX + maxX) / 2;
        this.camera.targetY = minY + (maxY - minY) / 2;
    },

    updateUI: function() {
        document.getElementById('status-text').innerText = this.steps[this.currentStep]?.msg || "Ready.";
        document.getElementById('btnUndo').disabled = this.history.length === 0;
        document.getElementById('btnPause').innerText = (this.currentStep === this.steps.length - 1 && !this.isPlaying && this.steps.length > 1) ? "Restart" : (this.isPlaying ? "Pause" : "Resume");
    },
    togglePause: function() {
        if (this.currentStep === this.steps.length - 1) { this.currentStep = 0; this.transition = 0; }
        this.isPlaying = !this.isPlaying; this.updateUI();
    },
    updateSpeed: function() { 
        this.currentSpeedFactor = 1.0 / parseFloat(document.getElementById('speedSlider').value);
    },

    loop: function(ts) {
        if (!this.lastTime) this.lastTime = ts;
        let dt = (ts - this.lastTime) / 1000;
        dt = Math.min(dt, 0.1);
        this.lastTime = ts;

        const camFactor = 1 - Math.exp(-10 * dt);
        this.camera.x += (this.camera.targetX - this.camera.x) * camFactor;
        this.camera.y += (this.camera.targetY - this.camera.y) * camFactor;
        this.camera.scale += (this.camera.targetScale - this.camera.scale) * camFactor;

        if (this.isPlaying) {
            this.transition += dt * this.currentSpeedFactor * this.baseMorphSpeed; 
            if (this.transition >= 1.3) { 
                this.transition = 0;
                if (this.currentStep < this.steps.length - 1) { this.currentStep++; this.updateUI(); }
                else { this.isPlaying = false; this.transition = 1; this.updateUI(); }
            }
        } else {
            if (this.transition < 1) this.transition += dt * this.currentSpeedFactor * this.baseMorphSpeed * 2; else this.transition = 1;
        }
        this.draw(); requestAnimationFrame((t) => this.loop(t));
    },

    draw: function() {
        const ctx = this.ctx; const w = this.canvas.width; const h = this.canvas.height;
        ctx.clearRect(0, 0, w, h);
        if (this.steps.length === 0) return;

        const curSnap = this.steps[this.currentStep];
        const prevSnap = this.currentStep > 0 ? this.steps[this.currentStep - 1] : curSnap;
        const layoutCur = this.layoutInOrder(curSnap.roots);
        const layoutPrev = this.layoutInOrder(prevSnap.roots);
        
        let t = Math.min(Math.max(this.transition, 0), 1);
        const easeT = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        const prevMap = new Map();
        this.flatten(layoutPrev).forEach(n => prevMap.set(n.id, {x:n.x, y:n.y}));

        ctx.save();
        ctx.translate(w/2, h/2); ctx.scale(this.camera.scale, this.camera.scale); ctx.translate(-this.camera.x, -this.camera.y);
        
        layoutCur.forEach(r => this.drawLinksRec(r, prevMap, easeT));
        this.vizNodes = [];
        layoutCur.forEach(r => this.drawNodesRec(r, prevMap, easeT));
        ctx.restore();
    },

    layoutInOrder: function(roots) {
        const clones = roots.map(r => r.clone());
        let counter = 0; const X_SPACING = 70; 
        const traverse = (n, depth) => {
            if(!n) return;
            traverse(n.left, depth+1);
            n.x = counter * X_SPACING; n.y = 50 + depth * this.levelGap;
            counter++;
            traverse(n.right, depth+1);
        };
        clones.forEach(root => { traverse(root, 0); counter += 1; });
        return clones;
    },

    drawLinksRec: function(node, prevMap, t) {
        if (!node) return;
        let cx = node.x, cy = node.y;
        const p = prevMap.get(node.id);
        if(p) { cx = p.x + (node.x-p.x)*t; cy = p.y + (node.y-p.y)*t; }
        
        if(!node.left) this.drawNull(cx, cy, 'L');
        if(!node.right) this.drawNull(cx, cy, 'R');
        
        const line = (child) => {
            let chx = child.x, chy = child.y;
            const cp = prevMap.get(child.id);
            if(cp) { chx = cp.x + (child.x-cp.x)*t; chy = cp.y + (child.y-cp.y)*t; }
            this.ctx.beginPath(); this.ctx.moveTo(cx, cy); this.ctx.lineTo(chx, chy);
            this.ctx.strokeStyle = COLORS.EDGE; this.ctx.lineWidth = 3; this.ctx.stroke();
        };
        if(node.left) { line(node.left); this.drawLinksRec(node.left, prevMap, t); }
        if(node.right) { line(node.right); this.drawLinksRec(node.right, prevMap, t); }
    },
    
    drawNull: function(x, y, dir) {
        const dx = dir === 'L' ? -15 : 15; const dy = 25;
        this.ctx.beginPath(); this.ctx.moveTo(x, y+this.nodeRadius/2); this.ctx.lineTo(x+dx, y+this.nodeRadius+dy);
        this.ctx.strokeStyle = COLORS.EDGE; this.ctx.lineWidth = 3; this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.moveTo(x+dx-5, y+this.nodeRadius+dy); this.ctx.lineTo(x+dx+5, y+this.nodeRadius+dy); this.ctx.stroke();
    },

    drawNodesRec: function(n, prevMap, t) {
        if(!n) return;
        let cx = n.x, cy = n.y;
        const p = prevMap.get(n.id);
        if(p) { cx = p.x + (n.x-p.x)*t; cy = p.y + (n.y-p.y)*t; } /* else this.ctx.globalAlpha = t; */
        
        this.vizNodes.push({x:cx, y:cy, val:n.val});

        const ctx = this.ctx;
        let fill = n.origin===1 ? COLORS.FILL1 : COLORS.FILL2;
        let stroke = n.origin===1 ? COLORS.STROKE1 : COLORS.STROKE2;
        
        let textColor = COLORS.TEXT_VAL; 

        if(n.highlight === 'compare') { 
            fill = COLORS.COMPARE_FILL; 
            stroke = COLORS.COMPARE_STROKE; 
        }
        else if(n.highlight === 'minimum') { 
            fill = COLORS.MINIMUM; 
            stroke = COLORS.MINIMUM; 
        }
        else if(n.highlight === 'delete-target') {
            fill = COLORS.DELETE; 
            stroke = COLORS.DELETE; 
            textColor = '#FFFFFF'; 
        } 

        ctx.beginPath(); ctx.arc(cx, cy, this.nodeRadius, 0, 2*Math.PI);
        ctx.fillStyle = fill; ctx.fill(); ctx.strokeStyle = stroke; ctx.lineWidth = 3; ctx.stroke();
        
        // Value Text
        ctx.fillStyle = textColor; 
        ctx.font = '22px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
        ctx.fillText(n.val, cx, cy+1);

        // Weight badge
        const bx = cx+this.nodeRadius-5; const by = cy-this.nodeRadius+5;
        ctx.beginPath(); ctx.arc(bx, by, 10, 0, 2*Math.PI);
        ctx.fillStyle = n.highlightWeight ? COLORS.WEIGHT_HIGHLIGHT : '#ffffff'; 
        ctx.fill(); ctx.strokeStyle = n.highlightWeight ? COLORS.WEIGHT_HIGHLIGHT : COLORS.WEIGHT_STROKE; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = n.highlightWeight ? '#ffffff' : COLORS.WEIGHT_TEXT; ctx.font = 'bold 11px Arial'; ctx.fillText(n.weight, bx, by+1);

        ctx.globalAlpha = 1;
        this.drawNodesRec(n.left, prevMap, t); this.drawNodesRec(n.right, prevMap, t);
    },
    
    flatten: function(roots) {
        let list = [];
        const t = (n) => { if(!n)return; list.push(n); t(n.left); t(n.right); };
        roots.forEach(t);
        return list;
    }
};
app.init();
</script>
</body>
</html>