<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BST Visualizer</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: #f5f5f5;
            --border-color: #ddd;
            
            /* UI Colors */
            --btn-insert: #2E7D32; 
            --btn-delete: #c62828; 
            --btn-search: #1668BD; 
            --btn-undo: #6A1B9A;   
            --btn-gray: #546E7A;
            --btn-random: #EF6C00;
            --btn-info: #009688; /* Teal for Traversals/Min/Max */
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex; flex-direction: column; 
            height: 100vh; height: 100dvh; 
            overflow: hidden; user-select: none;
        }

        header {
            padding: 10px 20px; background-color: var(--panel-bg);
            display: flex; flex-direction: column; gap: 10px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .header-top { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .gui { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        
        h1 { margin: 0; font-size: 1.2rem; color: #222; }
        
        .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .sub-controls { display: flex; gap: 15px; align-items: center; font-size: 0.9rem; color: #555; vertical-align: middle;}

        input[type="number"] {
            padding: 6px; border-radius: 4px; border: 1px solid #999;
            background: #fff; color: #000; width: 60px; text-align: center; font-weight: bold;
        }
        input[type="range"] { width: 100px; cursor: pointer; }

        button {
            padding: 6px 14px; border: none; border-radius: 4px; cursor: pointer;
            font-weight: 600; color: white; transition: filter 0.2s, transform 0.1s;
            font-size: 0.85rem; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }

        .btn-insert { background-color: var(--btn-insert); }
        .btn-delete { background-color: var(--btn-delete); }
        .btn-search { background-color: var(--btn-search); }
        .btn-undo { background-color: var(--btn-undo); }
        .btn-clear { background-color: var(--btn-gray); }
        .btn-random { background-color: var(--btn-random); }
        .btn-info { background-color: var(--btn-info); }
        .btn-pause { background-color: #455A64; width: 80px;}
        .btn-help { background-color: #607D8B; font-size: 1.1rem; padding: 4px 10px; border-radius: 50%; }

        #canvas-container {
            flex-grow: 1; position: relative; overflow: hidden;
            background-color: var(--bg-color);
            cursor: crosshair;
            min-height: 0;
        }
        canvas { display: block; width: 100%; height: 100%; }

        #legend {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255,255,255,0.95); padding: 10px;
            border: 1px solid #ddd; border-radius: 8px; font-size: 0.8rem;
            pointer-events: none; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; color: #333; }
        .dot { width: 14px; height: 14px; border-radius: 50%; }
        .line-icon { width: 15px; height: 3px; border-radius: 2px; }
        .arrow-icon { font-size: 16px; font-weight: bold; color: #D50000; }

        #status-bar {
            padding: 8px 2px 0px 0px; background-color: var(--panel-bg);
            font-size: 0.85rem; border-top: 1px solid var(--border-color);
            display: flex; justify-content: space-between; color: #555;
            flex-shrink: 0;
        }
        #status-text { font-weight: bold; color: #222; }

        #author { 
            width: 100%;
            background: #f4f7f6; 
            font-size: 0.75em; color: #777; text-align: center; line-height: 2.5;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }

        /* Modal */
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 8px; max-height: 80vh; overflow-y: auto; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: black; }
        h2 { color: #2E7D32; margin-top:0; }
        h3 { color: #1668BD; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 15px;}
        p, li { font-size: 0.95rem; line-height: 1.5; color: #333; }
        .complexity { font-family: monospace; background: #eee; padding: 2px 5px; border-radius: 4px; color: #c62828; }
        
        .node-sample {
            display: inline-block; width: 30px; height: 30px; border-radius: 50%;
            background: #B0F9B0; border: 1px solid #B0F9B0;
            text-align: center; line-height: 30px; position: relative;
            font-family: Arial, sans-serif; font-weight: bold;
        }    
        .node-val { color: #D50000; font-size: 12px; }
    </style>
</head>
<body>

<header>
    <div class="header-top">
        <h1>Binary Search Tree (BST) Visualizer</h1>
        <button class="btn-help" onclick="app.toggleModal()" title="Help / Algorithms">?</button>
    </div>
    <div class="gui">
        <div class="controls">
            <input type="number" id="inputValue" placeholder="#" title="Enter a number" onkeydown="if(event.key==='Enter') app.handleInsert()">
            <button class="btn-insert" title="Insert value" onclick="app.handleInsert()">Insert</button>
            <button class="btn-delete" title="Delete value" onclick="app.handleDelete()">Delete</button>
            <button class="btn-search" title="Search value" onclick="app.handleSearch()">Search</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

            <button class="btn-info" title="Find minimum value" onclick="app.handleMin()">Min</button>
            <button class="btn-info" title="Find maximum value" onclick="app.handleMax()">Max</button>
            <button class="btn-info" title="In-order traversal" onclick="app.handleInOrder()">InOrder</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

            <button class="btn-random" title="Generate random tree" onclick="app.handleRandomTree()">Random</button>

            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

            <button class="btn-undo" title="Undo last action" onclick="app.handleUndo()" id="btnUndo" disabled>Undo</button>
            <button class="btn-clear" title="Clear the tree" onclick="app.handleClear()">Clear</button>
        </div>
        <div class="sub-controls">
            <label for="speedSlider">Slowdown:</label>
            <label title="Slide right to slow down the animation">
                <input type="range" id="speedSlider" min="1" max="5" step="0.1" value="1" oninput="app.updateSpeed()">
            </label>
            <button class="btn-pause" title="Pause animation" onclick="app.togglePause()" id="btnPause">Pause</button>
        </div>
    </div>
    <div id="status-bar">
        <span id="status-text">Ready.</span>
    </div>
</header>

<div id="canvas-container">
    <canvas id="treeCanvas"></canvas>
    <div id="legend">
        <div class="legend-item">
            <div class="node-sample"><span class="node-val">V</span></div>&nbsp; Value
        </div>
        <div class="legend-item"><div class="dot" style="background:#4CAF50; border:1px solid #fff"></div>&nbsp; Inserted</div>
        <div class="legend-item"><div class="dot" style="background:#2196F3; border:1px solid #fff"></div>&nbsp; Visiting</div>
        <div class="legend-item"><div class="dot" style="background:#00E676; border:1px solid #fff"></div>&nbsp; Found</div>
        <div class="legend-item"><div class="dot" style="background:#F44336; border:1px solid #fff"></div>&nbsp; Delete</div>
        <div class="legend-item"><div class="line-icon" style="background:#1668BD;"></div>&nbsp; Null Link</div>
    </div>
</div>

<div id="author">Pepe Gallardo. Dpto. Lenguajes y Ciencias de la Computaci칩n. Universidad de M치laga</div>

<!-- Help Modal -->
<div id="helpModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="app.toggleModal()">&times;</span>
        <h2>Binary Search Tree (BST)</h2>
        
        <h3>Properties</h3>
        <p>A rooted binary tree data structure with the key of each internal node being:</p>
        <ul>
            <li>Greater than all keys in the respective node's <strong>left subtree</strong>.</li>
            <li>Less than all keys in the respective node's <strong>right subtree</strong>.</li>
        </ul>
        
        <h3>Complexity</h3>
        <p>The time complexity of operations depends on the height (h) of the tree.</p>
        <ul>
            <li><strong>Average Case:</strong> <span class="complexity">O(log n)</span> (when balanced).</li>
            <li><strong>Worst Case:</strong> <span class="complexity">O(n)</span> (when the tree becomes a linked list, e.g., inserting sorted data).</li>
        </ul>

        <h3>Algorithms</h3>
        <p><strong>Search/Insert:</strong> Traverse down from root comparing values.</p>
        <p><strong>Delete:</strong>
            <ul>
                <li>Leaf: Just remove.</li>
                <li>One Child: Replace with child.</li>
                <li>Two Children: Find successor (min of right subtree), replace value, and delete successor.</li>
            </ul>
        </p>
    </div>
</div>

<script>
const COLORS = {
    DEFAULT: '#B0F9B0',    // Light Green (Standard)
    STROKE: '#B0F9B0',     // Border Standard
    
    TEXT: '#CC0000',       // Red Text
    EDGE: '#1668BD',       // Blue Edges
    
    NEW: '#4CAF50',        // Darker Green
    VISIT: '#2196F3',      // Blue traversal
    PIVOT: '#FF5722',      // Orange (Used in rotation logic if present)
    CHILD: '#FFC107',      // Yellow
    FOUND: '#00E676',      // Bright Green
    PROCESSED: '#00E676',      // Bright Green
    DELETE: '#F44336',     // Red
    NULL_LINK: '#1668BD',  // Blue
    ARROW: '#D50000'       // Red Arrows
};

class Node {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.id = Node.nextId++;
        this.color = COLORS.DEFAULT;
        this.x = 0; this.y = 0;
    }
    clone() {
        const newNode = new Node(this.value);
        newNode.id = this.id; newNode.color = this.color;
        newNode.x = this.x; newNode.y = this.y;
        if (this.left) newNode.left = this.left.clone();
        if (this.right) newNode.right = this.right.clone();
        return newNode;
    }
}
Node.nextId = 0;

class BinarySearchTree {
    constructor() { this.root = null; this.history = []; }
    
    saveToHistory() {
        const state = this.root ? this.root.clone() : null;
        this.history.push(state);
        if (this.history.length > 25) this.history.shift();
    }
    restoreFromHistory() {
        if (this.history.length === 0) return null;
        this.root = this.history.pop(); return this.root;
    }
    resetVisuals(node) {
        if (!node) return;
        node.color = COLORS.DEFAULT;
        this.resetVisuals(node.left); this.resetVisuals(node.right);
    }
    cleanUp(recordSnapshot) {
        this.resetVisuals(this.root);
        recordSnapshot(this.root, null, { text: 'Ready.' });
    }

    insert(value, recordSnapshot) {
        this.saveToHistory();
        const _insert = (node) => {
            if (node) recordSnapshot(this.root, { val: value, targetId: node.id }, { text: `Finding place for ${value}...` });
            if (!node) { const nn = new Node(value); nn.color = COLORS.NEW; return nn; }
            if (value < node.value) {
                if (!node.left) recordSnapshot(this.root, null, { text: `Reached null link (Left of ${node.value})`, activeNull: { nodeId: node.id, side: 'L', color: COLORS.VISIT } });
                node.left = _insert(node.left);
            } else if (value > node.value) {
                if (!node.right) recordSnapshot(this.root, null, { text: `Reached null link (Right of ${node.value})`, activeNull: { nodeId: node.id, side: 'R', color: COLORS.VISIT } });
                node.right = _insert(node.right);
            }
            return node;
        };
        this.root = _insert(this.root);
        recordSnapshot(this.root, null, { text: `Inserted ${value}` });
        this.cleanUp(recordSnapshot);
    }

    delete(value, recordSnapshot) {
        this.saveToHistory();
        let found = false;
        const _delete = (node, val, showSearch = true) => {
            if (!node) return node;
            if (showSearch) {
                node.color = COLORS.VISIT;
                recordSnapshot(this.root, null, { text: `Searching ${val}...` });
                node.color = COLORS.DEFAULT;
            }
            if (val < node.value) {
                if(showSearch && !node.left) recordSnapshot(this.root, null, { text: `${val} not found (Left of ${node.value})`, activeNull: { nodeId: node.id, side: 'L', color: COLORS.DELETE } });
                node.left = _delete(node.left, val, showSearch);
            } else if (val > node.value) {
                if(showSearch && !node.right) recordSnapshot(this.root, null, { text: `${val} not found (Right of ${node.value})`, activeNull: { nodeId: node.id, side: 'R', color: COLORS.DELETE } });
                node.right = _delete(node.right, val, showSearch);
            } else {
                found = true;
                if (!node.left) {
                    node.color = COLORS.DELETE;
                    recordSnapshot(this.root, null, { pause: true, text: `Deleting ${node.value}` });
                    return node.right;
                } else if (!node.right) {
                    node.color = COLORS.DELETE;
                    recordSnapshot(this.root, null, { pause: true, text: `Deleting ${node.value}` });
                    return node.left;
                } else {
                    let temp = node.right;
                    recordSnapshot(this.root, null, { text: "Finding successor (right side)..." });
                    while (temp.left) {
                        temp.color = COLORS.VISIT;
                        recordSnapshot(this.root, null, { text: `Visiting: ${temp.value}` });
                        temp.color = COLORS.DEFAULT;
                        temp = temp.left;
                    }
                    recordSnapshot(this.root, null, { text: `Successor found (Left of ${temp.value} is null)`, activeNull: { nodeId: temp.id, side: 'L', color: COLORS.VISIT } });
                    node.color = COLORS.DELETE; temp.color = COLORS.PIVOT;
                    recordSnapshot(this.root, null, { pause: true, text: `Successor ${temp.value} replaces ${node.value}`, arrows: [{ from: temp.id, to: node.id }] });
                    node.value = temp.value;
                    node.color = COLORS.NEW; temp.color = COLORS.DEFAULT;
                    recordSnapshot(this.root, null, { text: `Value replaced` });
                    node.right = _delete(node.right, temp.value, false);
                }
            }
            return node;
        };
        this.root = _delete(this.root, value);
        if(found) recordSnapshot(this.root, null, { text: `Finished` }); else recordSnapshot(this.root, null, { text: `Value ${value} not found` });
        this.cleanUp(recordSnapshot);
    }

    search(value, recordSnapshot) {
        let current = this.root;
        let found = false;
        if(!current) { recordSnapshot(null, null, { text: "Tree is empty" }); return; }
        while (current) {
            current.color = (current.value === value) ? COLORS.FOUND : COLORS.VISIT;
            const txt = current.value === value ? `Found!` : `Visiting ${current.value}...`;
            recordSnapshot(this.root, null, { text: txt, pause: (current.value === value) });
            if (current.value === value) { found = true; break; }
            else if (value < current.value) {
                if(!current.left) recordSnapshot(this.root, null, { text: `${value} not found (Left of ${current.value})`, activeNull: { nodeId: current.id, side: 'L', color: COLORS.DELETE }, pause: true });
                current = current.left;
            } else {
                if(!current.right) recordSnapshot(this.root, null, { text: `${value} not found (Right of ${current.value})`, activeNull: { nodeId: current.id, side: 'R', color: COLORS.DELETE }, pause: true });
                current = current.right;
            }
        }
        if(!found) recordSnapshot(this.root, null, { text: "Not found." });
        this.cleanUp(recordSnapshot);
    }

    findMin(recordSnapshot) {
        let current = this.root;
        if(!current) { recordSnapshot(null, null, { text: "Tree is empty" }); return; }
        
        while(current) {
            current.color = COLORS.VISIT;
            recordSnapshot(this.root, null, { text: `Checking ${current.value}...` });
            
            if (current.left) {
                current.color = COLORS.DEFAULT; // Leave trail default
                current = current.left;
            } else {
                current.color = COLORS.FOUND;
                recordSnapshot(this.root, null, { text: `Minimum value is ${current.value}`, pause: true });
                break;
            }
        }
        this.cleanUp(recordSnapshot);
    }

    findMax(recordSnapshot) {
        let current = this.root;
        if(!current) { recordSnapshot(null, null, { text: "Tree is empty" }); return; }
        
        while(current) {
            current.color = COLORS.VISIT;
            recordSnapshot(this.root, null, { text: `Checking ${current.value}...` });
            
            if (current.right) {
                current.color = COLORS.DEFAULT;
                current = current.right;
            } else {
                current.color = COLORS.FOUND;
                recordSnapshot(this.root, null, { text: `Maximum value is ${current.value}`, pause: true });
                break;
            }
        }
        this.cleanUp(recordSnapshot);
    }

    inOrder(recordSnapshot) {
        const result = [];
        
        const _traverse = (node) => {
            if(!node) return;
            
            if (node.color !== COLORS.PROCESSED) {
                node.color = COLORS.VISIT;
                recordSnapshot(this.root, null, { text: `Traversing to left child of ${node.value}...` });
            }
            
            _traverse(node.left);
            
            node.color = COLORS.PROCESSED;
            result.push(node.value);
            
            recordSnapshot(this.root, null, { 
                text: `In-Order: [${result.join(', ')}]`, 
                pause: true // Peque침a pausa para ver que se ha a침adido
            });
            
            _traverse(node.right);
        };
        
        if(!this.root) {
             recordSnapshot(null, null, { text: "Tree is empty" });
        } else {
             _traverse(this.root);
             
             recordSnapshot(this.root, null, { 
                 text: `Traversal Complete: [${result.join(', ')}]`,
                 pause: true 
             });
        }
        
        this.cleanUp(recordSnapshot);
    }    
}

class Visualizer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.camera = { scale: 1, targetScale: 1, x: 0, targetX: 0, y: 0, targetY: 0 };
        this.nodeRadius = 28; // Matched to others
        this.levelHeight = 70; 
        this.snapshots = [];
        this.currentSnapshotIndex = -1;
        this.lastDrawnNodes = [];
        this.state = 'IDLE';
        this.isPaused = false;
        this.morphProgress = 0;
        this.baseMorphSpeed = 0.05;
        this.currentSpeedFactor = 1;
        this.pauseTimer = 0;
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.canvas.addEventListener('mousedown', (e) => this.handleClick(e));
        
        // Modal close
        window.onclick = (e) => {
             if (e.target == document.getElementById('helpModal')) app.toggleModal();
        }

        this.lastTime = 0;
        requestAnimationFrame(t => this.loop(t));
    }

    resize() {
        this.canvas.width = document.getElementById('canvas-container').offsetWidth;
        this.canvas.height = document.getElementById('canvas-container').offsetHeight;
        if (this.snapshots.length > 0) {
            const snap = this.snapshots[this.currentSnapshotIndex >= 0 ? this.currentSnapshotIndex : 0];
            if (snap && snap.root) {
                this.fitTreeBounds(snap.root);
                this.camera.scale = this.camera.targetScale;
                this.camera.x = this.camera.targetX;
                this.camera.y = this.camera.targetY;
            }
        }
    }
    getTreeBounds(root) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        let hasNodes = false;
        const traverse = (n) => {
            if (!n) return;
            hasNodes = true;
            minX = Math.min(minX, n.x - this.nodeRadius);
            maxX = Math.max(maxX, n.x + this.nodeRadius);
            minY = Math.min(minY, n.y - this.nodeRadius);
            maxY = Math.max(maxY, n.y + this.nodeRadius);
            traverse(n.left); traverse(n.right);
        };
        traverse(root);
        return { minX, maxX, minY, maxY, hasNodes };
    }
    fitTreeBounds(root) {
        const bounds = this.getTreeBounds(root);
        this.fitBoundsToScreen(bounds);
    }
    fitBoundsToScreen(bounds) {
        if (!bounds.hasNodes) {
            this.camera.targetScale = 1; this.camera.targetX = this.canvas.width / 2; this.camera.targetY = 100;
            return;
        }
        const padding = 150;
        const treeW = bounds.maxX - bounds.minX + padding;
        const treeH = bounds.maxY - bounds.minY + padding;
        const scale = Math.min(1.3, Math.min(this.canvas.width / treeW, this.canvas.height / treeH));
        const treeCX = (bounds.minX + bounds.maxX) / 2;
        const treeCY = (bounds.minY + bounds.maxY) / 2;
        this.camera.targetScale = scale;
        this.camera.targetX = (this.canvas.width / 2) - (treeCX * scale);
        this.camera.targetY = (this.canvas.height / 2) - (treeCY * scale);
        if (treeH * scale < this.canvas.height * 0.7) this.camera.targetY = 100;
    }
    setSpeed(val) { this.currentSpeedFactor = 1 / val; }
    togglePause() { this.isPaused = !this.isPaused; return this.isPaused; }

    handleClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
        for (let n of this.lastDrawnNodes) {
            const sx = (n.x * this.camera.scale) + this.camera.x;
            const sy = (n.y * this.camera.scale) + this.camera.y;
            const r = this.nodeRadius * this.camera.scale;
            if (Math.hypot(mx - sx, my - sy) < r) {
                document.getElementById('inputValue').value = n.value;
                document.getElementById('inputValue').focus();
                return;
            }
        }
    }
    calculateLayout(root) {
        if (!root) return;
        let order = 0;
        const traverse = (node, depth) => {
            if (!node) return;
            traverse(node.left, depth + 1);
            node.x = order * (this.nodeRadius * 2.5); // Spacing matching others
            node.y = depth * this.levelHeight + 80;
            order++;
            traverse(node.right, depth + 1);
        };
        traverse(root, 0);
        const width = (order > 0 ? order - 1 : 0) * (this.nodeRadius * 2.5);
        const offset = width / 2;
        const centerTree = (node) => { if(!node) return; node.x -= offset; centerTree(node.left); centerTree(node.right); };
        centerTree(root);
    }
    enqueueOperation(snapshots) {
        if (snapshots.length === 0) return;
        snapshots.forEach(s => this.calculateLayout(s.root));
        let gMinX = Infinity, gMaxX = -Infinity, gMinY = Infinity, gMaxY = -Infinity;
        let hasNodes = false;
        const allFrames = (this.snapshots.length > 0) ? [this.snapshots[this.snapshots.length-1], ...snapshots] : snapshots;
        allFrames.forEach(s => {
            const b = this.getTreeBounds(s.root);
            if (b.hasNodes) {
                hasNodes = true;
                gMinX = Math.min(gMinX, b.minX); gMaxX = Math.max(gMaxX, b.maxX);
                gMinY = Math.min(gMinY, b.minY); gMaxY = Math.max(gMaxY, b.maxY);
            }
        });
        this.fitBoundsToScreen({ minX: gMinX, maxX: gMaxX, minY: gMinY, maxY: gMaxY, hasNodes: hasNodes });
        if (this.snapshots.length === 0) {
            this.snapshots.push(snapshots[0]); this.currentSnapshotIndex = 0; snapshots.shift();
        }
        if (snapshots.length > 0) { this.pendingSnapshots = snapshots; this.state = 'CAMERA'; }
    }
    loop(timestamp) { if (!this.isPaused) this.update(); this.draw(); requestAnimationFrame(t => this.loop(t)); }

    update() {
        const camSpeed = 0.1;
        this.camera.scale += (this.camera.targetScale - this.camera.scale) * camSpeed;
        this.camera.x += (this.camera.targetX - this.camera.x) * camSpeed;
        this.camera.y += (this.camera.targetY - this.camera.y) * camSpeed;
        
        if (this.state === 'CAMERA') {
             const dist = Math.hypot(this.camera.x - this.camera.targetX, this.camera.y - this.camera.targetY);
             if (dist < 10 && Math.abs(this.camera.scale - this.camera.targetScale) < 0.05) {
                 if (this.pendingSnapshots.length > 0) this.loadNextSnapshot();
                 else this.state = 'IDLE';
             }
        } else if (this.state === 'MORPH') {
            this.morphProgress += this.baseMorphSpeed * this.currentSpeedFactor;
            if (this.morphProgress >= 1) {
                this.morphProgress = 1;
                if (this.pauseAfterMorph) {
                    this.state = 'WAITING';
                    this.pauseTimer = 50 / this.currentSpeedFactor;
                } else { this.finalizeStep(); }
            }
        } else if (this.state === 'WAITING') {
            this.pauseTimer--; if (this.pauseTimer <= 0) this.finalizeStep();
        }
    }

    loadNextSnapshot() {
        const next = this.pendingSnapshots.shift();
        this.snapshots.push(next);
        if (next.meta && next.meta.text) document.getElementById('status-text').innerText = next.meta.text;
        this.state = 'MORPH';
        this.morphProgress = 0;
        this.pauseAfterMorph = (next.meta && next.meta.pause);
    }

    finalizeStep() {
        this.currentSnapshotIndex++;
        if (this.pendingSnapshots && this.pendingSnapshots.length > 0) this.loadNextSnapshot();
        else { this.state = 'IDLE'; document.getElementById('status-text').innerText = "Ready."; }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save();
        
        // Consistent Camera transform
        this.ctx.translate(this.canvas.width/2, this.canvas.height/2); 
        this.ctx.translate((this.camera.x - this.canvas.width/2), (this.camera.y - this.canvas.height/2));
        this.ctx.translate(-this.camera.x, -this.camera.y); 
        this.ctx.setTransform(this.camera.scale, 0, 0, this.camera.scale, this.camera.x, this.camera.y);

        if (this.snapshots.length === 0) { this.ctx.restore(); return; }

        const idx = this.currentSnapshotIndex;
        let nodesToDraw = [];
        let floatingNode = null;
        let arrowsToDraw = [];
        let activeNull = null;
        let currentMeta = null;
        
        if ((this.state === 'MORPH' || this.state === 'WAITING') && idx + 1 < this.snapshots.length) {
            const snapA = this.snapshots[idx];
            const snapB = this.snapshots[idx+1];
            const t = this.easeInOut(this.morphProgress);
            nodesToDraw = this.interpolateTrees(snapA.root, snapB.root, t);
            
            if (snapB.floating) {
                const targetNodeB = this.findNode(snapB.root, snapB.floating.targetId);
                let startX = targetNodeB ? targetNodeB.x : 0;
                let startY = targetNodeB ? targetNodeB.y - 60 : 0;
                if (snapA.floating) { 
                    const prevTarget = this.findNode(snapA.root, snapA.floating.targetId);
                    if(prevTarget) { startX = prevTarget.x; startY = prevTarget.y; }
                }
                if (targetNodeB) {
                    const fx = startX + (targetNodeB.x - startX) * t;
                    const fy = startY + (targetNodeB.y - startY) * t;
                    floatingNode = { x: fx, y: fy, value: snapB.floating.val };
                }
            }
            if (snapB.meta && snapB.meta.arrows) arrowsToDraw = snapB.meta.arrows;
            currentMeta = (t > 0.5) ? snapB.meta : snapA.meta;
        } else {
            const snap = this.snapshots[idx >= 0 ? idx : 0];
            nodesToDraw = this.flattenTree(snap.root);
            if (snap.meta && snap.meta.arrows) arrowsToDraw = snap.meta.arrows;
            currentMeta = snap.meta;
        }

        if (currentMeta && currentMeta.activeNull) activeNull = currentMeta.activeNull;
        this.lastDrawnNodes = nodesToDraw; 

        this.ctx.beginPath(); 
        this.ctx.strokeStyle = COLORS.EDGE; 
        this.ctx.lineWidth = 3;
        nodesToDraw.forEach(n => {
            if (n.parentX !== undefined) { this.ctx.moveTo(n.parentX, n.parentY); this.ctx.lineTo(n.x, n.y); }
        });
        this.ctx.stroke();

        nodesToDraw.forEach(n => {
            if (!n.hasLeft) {
                const isActive = (activeNull && activeNull.nodeId === n.id && activeNull.side === 'L');
                const col = isActive ? activeNull.color : COLORS.NULL_LINK;
                this.drawNullLink(n.x, n.y, 'L', col, isActive);
            }
            if (!n.hasRight) {
                const isActive = (activeNull && activeNull.nodeId === n.id && activeNull.side === 'R');
                const col = isActive ? activeNull.color : COLORS.NULL_LINK;
                this.drawNullLink(n.x, n.y, 'R', col, isActive);
            }
        });

        nodesToDraw.forEach(n => this.drawNodeCircle(n.x, n.y, n.value, n.color || COLORS.DEFAULT));

        if (arrowsToDraw.length > 0) {
            this.ctx.strokeStyle = COLORS.CHILD; this.ctx.fillStyle = COLORS.CHILD; this.ctx.lineWidth = 3;
            arrowsToDraw.forEach(arr => {
                const n1 = nodesToDraw.find(n => n.id === arr.from);
                const n2 = nodesToDraw.find(n => n.id === arr.to);
                if (n1 && n2) this.drawStraightArrow(n1.x, n1.y, n2.x, n2.y);
            });
        }
        if (floatingNode) {
            this.ctx.shadowBlur = 10; this.ctx.shadowColor = COLORS.NEW;
            this.drawNodeCircle(floatingNode.x, floatingNode.y, floatingNode.value, COLORS.NEW, true);
            this.ctx.shadowBlur = 0;
        }
        this.ctx.restore();
    }

    drawNullLink(x, y, side, color, isActive) {
        const r = this.nodeRadius;
        const spread = 12; const drop = 25; const dir = (side === 'L') ? -1 : 1;
        const startX = x + (r * 0.5 * dir); const startY = y + (r * 0.8);
        const endX = x + (r + spread) * dir; const endY = y + r + drop;
        this.ctx.beginPath(); this.ctx.strokeStyle = color; this.ctx.lineWidth = isActive ? 4 : 3;
        this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke();
        const perpSize = 10;
        const dx = endX - startX; const dy = endY - startY;
        const angle = Math.atan2(dy, dx); const perpAngle = angle + Math.PI / 2;
        this.ctx.beginPath();
        this.ctx.moveTo(endX - perpSize * Math.cos(perpAngle), endY - perpSize * Math.sin(perpAngle));
        this.ctx.lineTo(endX + perpSize * Math.cos(perpAngle), endY + perpSize * Math.sin(perpAngle));
        this.ctx.stroke();
    }

    drawStraightArrow(fromX, fromY, toX, toY) {
        const headlen = 15;
        const angle = Math.atan2(toY - fromY, toX - fromX);
        const r = this.nodeRadius + 5;
        const startX = fromX + r * Math.cos(angle); const startY = fromY + r * Math.sin(angle);
        const endX = toX - r * Math.cos(angle); const endY = toY - r * Math.sin(angle);
        this.ctx.beginPath(); this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(endX, endY);
        this.ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI/6), endY - headlen * Math.sin(angle - Math.PI/6));
        this.ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI/6), endY - headlen * Math.sin(angle + Math.PI/6));
        this.ctx.fill();
    }

    drawNodeCircle(x, y, val, color, isFloating=false) {
        const r = this.nodeRadius;
        this.ctx.beginPath(); this.ctx.arc(x, y, r, 0, Math.PI * 2);
        this.ctx.fillStyle = color; this.ctx.fill();
        
        if (color === COLORS.DEFAULT || color === COLORS.STROKE) {
            this.ctx.strokeStyle = COLORS.STROKE; 
            this.ctx.fillStyle = COLORS.TEXT; 
        } else {
            this.ctx.strokeStyle = '#fff';
            this.ctx.fillStyle = '#fff';
        }
        
        // Ensure highlighted nodes have contrast if background is light (yellow/found)
        if (color === COLORS.CHILD || color === COLORS.FOUND) {
             this.ctx.fillStyle = '#333';
             this.ctx.strokeStyle = '#fff';
        }

        this.ctx.lineWidth = isFloating ? 3 : 3; this.ctx.stroke();
        this.ctx.font = '22px Arial';
        this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
        this.ctx.fillText(val, x, y+1);
    }

    findNode(root, id) {
        if(!root) return null;
        if(root.id === id) return root;
        return this.findNode(root.left, id) || this.findNode(root.right, id);
    }

    interpolateTrees(rootA, rootB, t) {
        const mapA = new Map(); const mapB = new Map();
        const mapFn = (n, m, p) => {
            if(!n) return;
            m.set(n.id, { node: n, pX: p?p.x:null, pY: p?p.y:null, pId: p?p.id:null });
            mapFn(n.left, m, n); mapFn(n.right, m, n);
        };
        mapFn(rootA, mapA, null); mapFn(rootB, mapB, null);
        const result = [];
        const allIds = new Set([...mapA.keys(), ...mapB.keys()]);
        allIds.forEach(id => {
            const dA = mapA.get(id); const dB = mapB.get(id);
            if (dA && dB) {
                const x = dA.node.x + (dB.node.x - dA.node.x) * t;
                const y = dA.node.y + (dB.node.y - dA.node.y) * t;
                const color = (t > 0.5) ? dB.node.color : dA.node.color;
                let pX, pY;
                if (dA.pId === dB.pId && dA.pId !== null) {
                     const pdA = mapA.get(dA.pId); const pdB = mapB.get(dB.pId);
                     if(pdA && pdB) { pX = pdA.node.x + (pdB.node.x - pdA.node.x) * t; pY = pdA.node.y + (pdB.node.y - pdA.node.y) * t; }
                } else if (dB.pId !== null) {
                    const pdB = mapB.get(dB.pId); if(pdB) { pX = pdB.node.x; pY = pdB.node.y; }
                }
                const hasL = (t > 0.5) ? !!dB.node.left : !!dA.node.left;
                const hasR = (t > 0.5) ? !!dB.node.right : !!dA.node.right;
                result.push({ id: id, x, y, value: dB.node.value, color, parentX: pX, parentY: pY, hasLeft: hasL, hasRight: hasR });
            } else if (dB && !dA) {
                let startX = dB.node.x; let startY = dB.node.y;
                if (dB.pId !== null) {
                    const parentInA = mapA.get(dB.pId);
                    if (parentInA) { startX = parentInA.node.x; startY = parentInA.node.y; }
                }
                const x = startX + (dB.node.x - startX) * t;
                const y = startY + (dB.node.y - startY) * t;
                
                let pX, pY;
                if (dB.pId !== null) {
                     const pdB = mapB.get(dB.pId);
                     const pdA = mapA.get(dB.pId); 
                     if (pdA && pdB) {
                         pX = pdA.node.x + (pdB.node.x - pdA.node.x) * t;
                         pY = pdA.node.y + (pdB.node.y - pdA.node.y) * t;
                     } else if (pdB) { pX = pdB.node.x; pY = pdB.node.y; }
                }
                result.push({ 
                    id: id, x: x, y: y, value: dB.node.value, color: dB.node.color, 
                    parentX: pX, parentY: pY,
                    hasLeft: !!dB.node.left, hasRight: !!dB.node.right
                });
            } else if (dA && !dB) {
                if(t < 0.8) result.push({ 
                    id: id, x: dA.node.x, y: dA.node.y, value: dA.node.value, color: COLORS.DELETE, 
                    parentX: dA.pX, parentY: dA.pY,
                    hasLeft: !!dA.node.left, hasRight: !!dA.node.right
                });
            }
        });
        return result;
    }

    flattenTree(root) {
        const res = [];
        const trav = (n, p) => {
            if(!n) return;
            res.push({ 
                id: n.id, x: n.x, y: n.y, value: n.value, color: n.color, 
                parentX: p ? p.x : undefined, parentY: p ? p.y : undefined,
                hasLeft: !!n.left, hasRight: !!n.right
            });
            trav(n.left, n); trav(n.right, n);
        };
        trav(root, null);
        return res;
    }
    easeInOut(t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t; }
}

const app = {
    tree: new BinarySearchTree(),
    viz: null,
    init: function() { this.viz = new Visualizer('treeCanvas'); this.updateUI(); },
    updateSpeed: function() {
        const val = parseFloat(document.getElementById('speedSlider').value);
        this.viz.setSpeed(val);
    },
    togglePause: function() {
        const isPaused = this.viz.togglePause();
        const btn = document.getElementById('btnPause');
        btn.innerText = isPaused ? "Resume" : "Pause";
    },
    handleInsert: function() { 
        const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
        if (!isNaN(val)) { this.runOp(rec => this.tree.insert(val, rec)); inp.value = ''; inp.focus(); }
    },
    handleDelete: function() { 
        const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
        if (!isNaN(val)) { this.runOp(rec => this.tree.delete(val, rec)); inp.value = ''; }
    },
    handleSearch: function() { 
        const inp = document.getElementById('inputValue'); const val = parseInt(inp.value);
        if (!isNaN(val)) this.runOp(rec => this.tree.search(val, rec), false);
    },
    handleMin: function() { this.runOp(rec => this.tree.findMin(rec), false); },
    handleMax: function() { this.runOp(rec => this.tree.findMax(rec), false); },
    handleInOrder: function() { this.runOp(rec => this.tree.inOrder(rec), false); },
    handleUndo: function() { 
        if (this.tree.history.length === 0) return;
        const oldRoot = this.tree.restoreFromHistory();
        const snaps = [{ root: oldRoot ? oldRoot.clone() : null, meta: { text: "Undo successful" } }];
        this.viz.enqueueOperation(snaps);
        this.updateUI();
    },
    handleClear: function() { 
        this.tree = new BinarySearchTree(); this.viz.snapshots = []; this.viz.currentSnapshotIndex = -1; 
        this.viz.camera.targetScale = 1; this.viz.draw(); this.updateUI(); 
    },
    handleRandomTree: function() {
        this.handleClear();
        const snaps = []; snaps.push({ root: null });
        const count = 15; const values = new Set();
        while(values.size < count) values.add(Math.floor(Math.random() * 100) + 1);
        const batchRecorder = (root, floating, meta) => { snaps.push({ root: root ? root.clone() : null, floating, meta }); };
        for (let val of values) { this.tree.insert(val, batchRecorder); }
        this.viz.enqueueOperation(snaps);
        this.updateUI();
    },
    toggleModal: function() {
        const m = document.getElementById('helpModal');
        m.style.display = (m.style.display === 'block') ? 'none' : 'block';
    },
    runOp: function(fn, allowsUndo = true) {
        if(this.viz.isPaused) this.togglePause();
        if (this.viz.state !== 'IDLE') return;
        const snaps = [];
        if(this.tree.root) snaps.push({ root: this.tree.root.clone() }); else snaps.push({ root: null });
        fn((root, floating, meta) => snaps.push({ root: root ? root.clone() : null, floating, meta }));
        this.viz.enqueueOperation(snaps);
        if(allowsUndo) this.updateUI();
    },
    updateUI: function() { document.getElementById('btnUndo').disabled = (this.tree.history.length === 0); }
};

window.onload = () => app.init();
</script>
</body>
</html>