<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Separate Chaining Visualizer (Final)</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: #f5f5f5;
            --border-color: #ddd;
            --btn-insert: #2E7D32; 
            --btn-delete: #c62828; 
            --btn-search: #1668BD; 
            --btn-undo: #6A1B9A;   
            --btn-gray: #546E7A;
            --btn-random: #EF6C00;
        }

        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: var(--bg-color); display: flex; flex-direction: column; height: 100vh; height: 100dvh; overflow: hidden; user-select: none; }
        header { padding: 10px 20px; background-color: var(--panel-bg); display: flex; flex-direction: column; gap: 10px; border-bottom: 1px solid var(--border-color); box-shadow: 0 2px 4px rgba(0,0,0,0.05); flex-shrink: 0; }
        .header-top { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .gui { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        h1 { margin: 0; font-size: 1.2rem; color: #222; }
        .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .sub-controls { display: flex; gap: 15px; align-items: center; font-size: 0.9rem; color: #555; vertical-align: middle;}
        input[type="text"] { padding: 6px; border-radius: 4px; border: 1px solid #999; background: #fff; color: #000; width: 60px; text-align: center; font-weight: bold; }
        input[type="range"] { width: 100px; cursor: pointer; }
        button { padding: 6px 14px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; color: white; transition: filter 0.2s, transform 0.1s; font-size: 0.85rem; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }
        .btn-insert { background-color: var(--btn-insert); } .btn-delete { background-color: var(--btn-delete); }
        .btn-search { background-color: var(--btn-search); } .btn-undo { background-color: var(--btn-undo); }
        .btn-clear { background-color: var(--btn-gray); } .btn-random { background-color: var(--btn-random); }
        .btn-pause { background-color: #455A64; width: 80px;} .btn-help { background-color: #607D8B; font-size: 1.1rem; padding: 4px 10px; border-radius: 50%; }
        #canvas-container { flex-grow: 1; position: relative; overflow: hidden; background-color: var(--bg-color); cursor: default; min-height: 0; }
        canvas { display: block; width: 100%; height: 100%; -webkit-tap-highlight-color: transparent; }
        #legend { position: absolute; top: 20px; left: 20px; background: rgba(255,255,255,0.75); padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.8rem; pointer-events: none; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; color: #333; }
        .square { width: 14px; height: 14px; border-radius: 2px; border: 1px solid #999; }
        .dot { width: 10px; height: 10px; border-radius: 50%; background: #1668BD; display:inline-block; }
        .arrow-icon { font-size: 16px; font-weight: bold; color: #cc0000; }
        #status-bar { padding: 8px 2px 0px 0px; background-color: var(--panel-bg); font-size: 0.85rem; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; color: #555; flex-shrink: 0; }
        #status-text { font-weight: bold; color: #222; }
        #author { width: 100%; background: #f4f7f6; font-size: 0.75em; color: #777; text-align: center; line-height: 2.5; border-top: 1px solid #ddd; flex-shrink: 0; }
        
        /* Tooltip Styles */
        #tooltip {
            position: fixed;
            display: none;
            background: rgba(26, 26, 26, 0.9);
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 15px;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            backdrop-filter: blur(4px);
        }
        .tooltip-item { font-weight: bold; color: #ff8a80; }
        .tooltip-hash { font-weight: bold; color: #80d8ff; }

        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 8px; max-height: 80vh; overflow-y: auto; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: black; }
        h2 { color: #2E7D32; margin-top:0; }
        h3 { color: #1668BD; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 15px;}
        p, li { font-size: 0.95rem; line-height: 1.5; color: #333; }
    </style>
</head>
<body>

<header>
    <div class="header-top">
        <h1>Separate Chaining Hash Table Visualizer</h1>
        <button class="btn-help" onclick="app.toggleModal()" title="Help / Algorithms">?</button>
    </div>
    <div class="gui">
        <div class="controls">
            <input type="text" id="inputValue" title="Enter any character" placeholder="#" maxlength="1" onkeydown="if(event.key==='Enter') app.handleInsert()">
            <button class="btn-insert" title="Insert a character" onclick="app.handleInsert()">Insert</button>
            <button class="btn-delete" title="Delete a character" onclick="app.handleDelete()">Delete</button>
            <button class="btn-search" title="Search a character" onclick="app.handleSearch()">Search</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>
            
            <button class="btn-random" title="Fill with random characters" onclick="app.handleRandomFill()">Random Fill</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

            <button class="btn-undo" title="Undo last operation" onclick="app.handleUndo()" id="btnUndo" disabled>Undo</button>
            <button class="btn-clear" title="Clear the table" onclick="app.handleClear()">Clear</button>
        </div>
        <div class="sub-controls">
            <label for="speedSlider">Slowdown:</label>
            <label title="Slide right to slow down the animation">
                <input type="range" id="speedSlider" min="1" max="5" step="0.1" value="1" oninput="app.updateSpeed()">
            </label>
            <button class="btn-pause" title="Pause or Resume" onclick="app.togglePause()" id="btnPause">Pause</button>
        </div>
    </div>
    <div id="status-bar">
        <span id="status-text">Ready. Use Mouse/Touch to Pan & Zoom.</span>
    </div>
</header>

<div id="canvas-container">
    <canvas id="htCanvas"></canvas>
    <div id="legend">
        <div class="legend-item"><div class="square" style="background:#99FFFF;"></div>&nbsp; Pointer Cell</div>
        <div class="legend-item"><div class="square" style="background:#B0F9B0;"></div>&nbsp; Data</div>
        <div class="legend-item"><div class="square" style="background:#CC99FF;"></div>&nbsp; Examining</div>
        <div class="legend-item"><div class="square" style="background:#00E676;"></div>&nbsp; Match/Hit</div>
        <div class="legend-item"><div class="square" style="background:#D32F2F; border:1px solid #D32F2F;"></div>&nbsp; Search Miss</div>
        <div class="legend-item"><div class="arrow-icon" style="color:#7F00FF;">&#8595;</div>&nbsp; Hash Index</div>
        <div class="legend-item"><div class="square" style="background:#FFD700;"></div>&nbsp; Rehash</div>
    </div>
    <div id="tooltip"></div>
</div>

<div id="author">Pepe Gallardo. Dpto. Lenguajes y Ciencias de la Computación. Universidad de Málaga</div>

<div id="helpModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="app.toggleModal()">&times;</span>
        <h2>Separate Chaining Hash Table</h2>
        
        <h3>Concept</h3>
        <p><strong>Separate Chaining</strong> resolves collisions by maintaining a linked list of nodes for each index in the array. If multiple keys hash to the same index, they are simply added to that index's list.
        To maintain performance, the <strong>Load Factor</strong> (size/capacity), which indicates the expected number of elements per list, is kept below a threshold (here, 2.0). If exceeded, the table is rehashed to a larger size.
        </p>

        <h3>Operations & Complexity</h3>
        <style>.complexity { font-family: monospace; background: #eee; padding: 2px 5px; border-radius: 4px; color: #c62828; font-size: 0.85rem; font-weight: bold; }</style>
        
        <ul>
            <li>
                <strong>Insert</strong> <span class="complexity">O(1) avg</span><br>
                Computes <code>hash(key)</code>. Traverses the list to check duplicates. If not found, inserts at the <strong>head</strong>.
                <br><em>Note: If Load Factor > maxLoadFactor, <strong>Rehashing</strong> occurs (table doubles size to nearest prime, all keys re-inserted), taking <span class="complexity">O(n)</span>.</em>
            </li>
            <li>
                <strong>Search</strong> <span class="complexity">O(1) avg</span><br>
                Calculates index and traverses the linked list. Time depends on Load Factor α.
            </li>
            <li>
                <strong>Delete</strong> <span class="complexity">O(1) avg</span><br>
                Finds the node and updates pointers to remove it.
            </li>
        </ul>
    </div>
</div>

<script>
const COLORS = {
    STRUCT_KEYS_BG: '#99FFFF',  
    STRUCT_STATS_BG: '#B0F9B0', 
    CELL_BG: '#99FFFF',     
    CELL_STROKE: '#FFFFFF', 
    DATA_BG: '#B0F9B0',     
    TEXT_RED: '#CC0000',    
    DOT: '#1668BD',         
    ARROW_REF: '#1668BD',   
    ARROW_PROBE: '#7F00FF', 
    EXAMINE_BG: '#CC99FF',  
    MISS_BG: '#D32F2F',     
    HIT_BG: '#00E676',      
    MISS_STROKE: '#D32F2F', 
    HASH_BOX_BG: '#CC99FF'
};

function isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 === 0 || num % 3 === 0) return false;
    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
}

function nextPrime(num) {
    if (num <= 1) return 2;
    let prime = num;
    let found = false;
    while (!found) {
        prime++;
        if (isPrime(prime)) found = true;
    }
    return prime;
}

class Node {
    constructor(key, next = null) {
        this.key = key;
        this.next = next;
        this.id = Math.random(); 
    }
}

class SeparateChainingHashTable {
    constructor(capacity = 5) { 
        this.capacity = capacity;
        this.table = new Array(capacity).fill(null);
        this.size = 0;
        this.maxLoadFactor = 2.0; 
        this.history = [];
    }

    cloneTable(table) {
        const newTable = new Array(table.length).fill(null);
        for(let i = 0; i < table.length; i++) {
            if (table[i]) {
                let curr = table[i];
                let newHead = new Node(curr.key);
                newHead.id = curr.id;
                let newCurr = newHead;
                curr = curr.next;
                while(curr) {
                    newCurr.next = new Node(curr.key);
                    newCurr.next.id = curr.id;
                    newCurr = newCurr.next;
                    curr = curr.next;
                }
                newTable[i] = newHead;
            }
        }
        return newTable;
    }

    serializeTable(table) {
        return table.map(head => {
            const list = [];
            let curr = head;
            while(curr) {
                list.push({ key: curr.key, id: curr.id });
                curr = curr.next;
            }
            return list;
        });
    }

    saveToHistory() {
        const state = {
            table: this.cloneTable(this.table),
            size: this.size,
            capacity: this.capacity,
            maxLoadFactor: this.maxLoadFactor
        };
        this.history.push(state);
        if (this.history.length > 20) this.history.shift();
    }

    restoreFromHistory() {
        if (this.history.length === 0) return null;
        const state = this.history.pop();
        this.table = state.table;
        this.size = state.size;
        this.capacity = state.capacity;
        this.maxLoadFactor = state.maxLoadFactor;
        return this;
    }

    hash(key) {
        const code = key.charCodeAt(0);
        return code % this.capacity;
    }

    getSnapshotData() {
        return {
            table: this.serializeTable(this.table),
            size: this.size,
            capacity: this.capacity,
            maxLoadFactor: this.maxLoadFactor,
            maxDepth: this.table.reduce((max, list) => {
                let d = 0;
                let curr = list;
                while(curr) { d++; curr = curr.next; }
                return Math.max(max, d);
            }, 0)
        };
    }

    // --- Logic ---

    performSearchLogic(key, recordSnapshot) {
        let idx = this.hash(key);
        
        recordSnapshot(this.getSnapshotData(), { 
            text: `Hash: '${key}' -> ${idx}`,
            hashCalc: { key: key, hash: idx },
            targetIndex: idx
        });

        if (this.table[idx] === null) {
            recordSnapshot(this.getSnapshotData(), { 
                text: `Index ${idx} is empty (Miss).`,
                hashCalc: { key: key, hash: idx },
                targetIndex: idx,
                missIndex: idx 
            });
            return { found: false, depth: 0, idx };
        }

        let curr = this.table[idx];
        let depth = 0;

        while (curr) {
            if (curr.key === key) {
                recordSnapshot(this.getSnapshotData(), { 
                    text: `Found '${key}' (Hit).`, 
                    hashCalc: { key: key, hash: idx },
                    targetIndex: idx,
                    highlightNode: { col: idx, depth: depth, type: 'HIT' }
                });
                return { found: true, depth, idx };
            } else {
                recordSnapshot(this.getSnapshotData(), { 
                    text: `Comparing with '${curr.key}'...`,
                    hashCalc: { key: key, hash: idx },
                    targetIndex: idx,
                    highlightNode: { col: idx, depth: depth, type: 'EXAMINE' }
                });
            }

            if (!curr.next) {
                recordSnapshot(this.getSnapshotData(), { 
                    text: `End of list. Key '${key}' NOT found (Miss).`, 
                    hashCalc: { key: key, hash: idx },
                    targetIndex: idx,
                    highlightNode: { col: idx, depth: depth, type: 'MISS_PTR' }
                });
                return { found: false, depth, idx };
            }

            curr = curr.next;
            depth++;
        }
    }

    insert(key, recordSnapshot) {
        this.saveToHistory();

        if ((this.size + 1) / this.capacity > this.maxLoadFactor) {
            this.rehash(recordSnapshot);
        }

        const result = this.performSearchLogic(key, recordSnapshot);
        
        if (result.found) {
            this.cleanUp(recordSnapshot);
            return; 
        }

        let idx = result.idx;
        
        const newNode = new Node(key, this.table[idx]);
        this.table[idx] = newNode;
        this.size++;
        
        recordSnapshot(this.getSnapshotData(), { 
            text: `Inserting '${key}' at head...`, 
            hashCalc: { key: key, hash: idx },
            targetIndex: idx,
            animation: 'slideDown',
            animationCol: idx,
            highlightNode: { col: idx, depth: 0, type: 'HIT' }
        });

        this.cleanUp(recordSnapshot);
    }

    search(key, recordSnapshot) {
        this.performSearchLogic(key, recordSnapshot);
        this.cleanUp(recordSnapshot);
    }

    delete(key, recordSnapshot) {
        this.saveToHistory();
        
        const result = this.performSearchLogic(key, recordSnapshot);
        
        if (!result.found) {
            this.cleanUp(recordSnapshot);
            return;
        }

        let idx = result.idx;
        
        const oldData = this.getSnapshotData();
        
        recordSnapshot(oldData, {
            text: `Removing '${key}'. Sliding up...`,
            hashCalc: { key: key, hash: idx },
            targetIndex: idx,
            animation: 'slideUp',
            animationCol: idx,
            animationDepth: result.depth 
        });

        let curr = this.table[idx];
        let prev = null;
        while(curr && curr.key !== key) {
            prev = curr;
            curr = curr.next;
        }
        if (prev) {
            prev.next = curr.next;
        } else {
            this.table[idx] = curr.next;
        }
        this.size--;

        recordSnapshot(this.getSnapshotData(), { 
            text: `Deleted '${key}'.`, 
            hashCalc: { key: key, hash: idx }
        });
        
        this.cleanUp(recordSnapshot);
    }

    rehash(recordSnapshot) {
        const oldCapacity = this.capacity;
        const oldTableRef = this.cloneTable(this.table); 
        const oldSerialized = this.serializeTable(oldTableRef); 
        
        this.capacity = nextPrime(this.capacity * 2);
        this.table = new Array(this.capacity).fill(null);
        this.size = 0;
        
        recordSnapshot(this.getSnapshotData(), { 
            text: `Load Factor > ${this.maxLoadFactor}. Rehashing ${oldCapacity} -> ${this.capacity}...`,
            rehashMode: true,
            phase: 'SETUP',
            oldTable: oldSerialized,
            oldCapacity: oldCapacity,
            processedIds: [] 
        });

        let allNodes = [];
        for(let i = 0; i < oldTableRef.length; i++) {
            let curr = oldTableRef[i];
            let depth = 0;
            while(curr) {
                allNodes.push({ key: curr.key, id: curr.id, oldIdx: i, oldDepth: depth });
                curr = curr.next;
                depth++;
            }
        }

        const processedIds = [];

        for (let nodeInfo of allNodes) {
            let key = nodeInfo.key;
            let newIdx = this.hash(key);
            
            const newNode = new Node(key, this.table[newIdx]);
            newNode.id = nodeInfo.id; 
            this.table[newIdx] = newNode;
            this.size++;

            recordSnapshot(this.getSnapshotData(), {
                text: `Moving '${key}'... (Index ${nodeInfo.oldIdx} -> ${newIdx})`,
                rehashMode: true,
                phase: 'FLYING',
                oldTable: oldSerialized,
                oldCapacity: oldCapacity,
                processedIds: [...processedIds], 
                flyingNode: { 
                    key: key, 
                    id: nodeInfo.id,
                    fromIdx: nodeInfo.oldIdx, 
                    fromDepth: nodeInfo.oldDepth,
                    toIdx: newIdx
                }
            });

            processedIds.push(nodeInfo.id);
        }

        recordSnapshot(this.getSnapshotData(), { 
            text: `Rehashing complete. New capacity: ${this.capacity}.`,
            isCleanup: true 
        });
    }

    cleanUp(recordSnapshot) {
        recordSnapshot(this.getSnapshotData(), { text: 'Ready.', isCleanup: true });
    }
}

class Visualizer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        
        // Centralized Dimensions Configuration
        this.layout = {
            arrayCellSize: 40,
            nodeWidth: 30,
            nodeBoxH: 30,
            nodePtrH: 20,
            nodeVerticalStep: 60, // nodeBoxH + nodePtrH + gap
            leftPanelW: 140,
            rehashGap: 180,
            baseY: -100
        };
        
        this.snapshots = [];
        this.currentSnapshotIndex = -1;
        this.state = 'IDLE';
        this.isPaused = false;
        this.morphProgress = 0;
        this.baseSpeed = 0.075;
        this.currentSpeedFactor = 1;
        this.pauseTimer = 0;
        
        // Camera System
        this.camera = { x: 0, y: 0, scale: 1, targetX: 0, targetY: 0, targetScale: 1 };
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.initialCamera = { x: 0, y: 0 };
        this.initialPinchDist = 0;
        this.initialScale = 1;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', e => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', e => this.onMouseUp(e));
        this.canvas.addEventListener('mouseleave', e => this.onMouseUp(e));
        this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });
        this.canvas.addEventListener('touchstart', e => this.onTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', e => this.onTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', e => this.onTouchEnd(e));

        window.onclick = (e) => { if (e.target == document.getElementById('helpModal')) app.toggleModal(); }
        this.lastTime = 0;
        requestAnimationFrame(t => this.loop(t));
    }

    resize() {
        const container = document.getElementById('canvas-container');
        this.canvas.width = container.offsetWidth;
        this.canvas.height = container.offsetHeight;
        if (this.snapshots.length > 0 && this.currentSnapshotIndex >= 0) {
            const bounds = this.getSnapshotBounds(this.snapshots[this.currentSnapshotIndex]);
            this.fitBoundsToScreen(bounds);
            this.camera.x = this.camera.targetX;
            this.camera.y = this.camera.targetY;
            this.camera.scale = this.camera.targetScale;
        }
    }

    setSpeed(val) { this.currentSpeedFactor = 1 / val; }
    togglePause() { this.isPaused = !this.isPaused; return this.isPaused; }

    // --- Core Layout & Bounds Logic (Auto-Fit) ---

    getSnapshotBounds(snap) {
        const meta = snap.meta || {};
        const data = snap.tableData;
        const L = this.layout;
        
        let minX, maxX, minY, maxY;

        if (meta.rehashMode) {
            // Rehash Layout
            const oldW = meta.oldCapacity * L.arrayCellSize;
            const newW = data.capacity * L.arrayCellSize;
            const totalRehashW = oldW + L.rehashGap + newW;
            const startX = -totalRehashW / 2;

            minX = startX - 20; 
            maxX = startX + totalRehashW + 20;

            // Determine max depth to calculate height
            const oldMaxDepth = meta.oldTable.reduce((m, l) => Math.max(m, l ? l.length : 0), 0);
            const globalMaxDepth = Math.max(data.maxDepth, oldMaxDepth);

            minY = L.baseY - 110; 
            maxY = L.baseY + L.arrayCellSize + 20 + (globalMaxDepth * L.nodeVerticalStep) + 120;

        } else {
            // Standard Layout
            const arrayW = data.capacity * L.arrayCellSize;
            const totalW = L.leftPanelW + arrayW;
            const startX = -totalW / 2 + L.leftPanelW;

            // MinX covers the structure panel on the left
            minX = startX - L.leftPanelW - 80;
            maxX = startX + arrayW + 20;

            minY = L.baseY - 160; 
            
            // Tighten bottom margin: maxDepth + 1 for potential pointers
            const visibleDepth = Math.max(0, data.maxDepth); 
            maxY = L.baseY + Math.max(110, L.arrayCellSize + 0 + (visibleDepth * L.nodeVerticalStep));
        }
        
        return { minX, maxX, minY, maxY };
    }

    fitBoundsToScreen(bounds) {
        const w = this.canvas.width;
        const h = this.canvas.height;
        
        const contentW = bounds.maxX - bounds.minX;
        const contentH = bounds.maxY - bounds.minY;
        const centerX = (bounds.minX + bounds.maxX) / 2;
        const centerY = (bounds.minY + bounds.maxY) / 2;

        const paddingX = 40;
        const paddingY = 40;

        const scale = Math.min(
            w / (contentW + paddingX),
            h / (contentH + paddingY),
            5 // Max zoom
        );
        
        this.camera.targetScale = scale;
        this.camera.targetX = centerX;
        this.camera.targetY = centerY;
    }

    enqueueOperation(snapshots) {
        if (snapshots.length === 0) return;

        // Progressive Zoom: Fit to union of Current + Next only
        let gMinX = Infinity, gMaxX = -Infinity, gMinY = Infinity, gMaxY = -Infinity;
        
        // 1. Current State
        if (this.currentSnapshotIndex >= 0 && this.currentSnapshotIndex < this.snapshots.length) {
            const b = this.getSnapshotBounds(this.snapshots[this.currentSnapshotIndex]);
            gMinX = Math.min(gMinX, b.minX); gMaxX = Math.max(gMaxX, b.maxX);
            gMinY = Math.min(gMinY, b.minY); gMaxY = Math.max(gMaxY, b.maxY);
        }

        // 2. First New Snapshot
        if (snapshots.length > 0) {
            const b = this.getSnapshotBounds(snapshots[0]);
            gMinX = Math.min(gMinX, b.minX); gMaxX = Math.max(gMaxX, b.maxX);
            gMinY = Math.min(gMinY, b.minY); gMaxY = Math.max(gMaxY, b.maxY);
        }

        if (gMinX === Infinity) {
             const b = this.getSnapshotBounds(snapshots[0]);
             gMinX = b.minX; gMaxX = b.maxX; gMinY = b.minY; gMaxY = b.maxY;
        }

        this.fitBoundsToScreen({ minX: gMinX, maxX: gMaxX, minY: gMinY, maxY: gMaxY });
        
        // 3. Queue Snapshots
        this.snapshots.push(...snapshots);
        if (this.currentSnapshotIndex === -1) this.currentSnapshotIndex = 0;

        // 4. Activate Camera
        if (this.state === 'IDLE' || this.state === 'WAITING' || this.state === 'MORPH') {
             this.state = 'CAMERA';
             const nextSnap = this.snapshots[this.currentSnapshotIndex];
             if (nextSnap.meta && nextSnap.meta.text) document.getElementById('status-text').innerText = nextSnap.meta.text;
        }
    }

    // --- Interaction ---

    screenToWorld(mx, my) {
        const w = this.canvas.width, h = this.canvas.height;
        return {
            x: this.camera.x + (mx - w/2) / this.camera.scale,
            y: this.camera.y + (my - h/2) / this.camera.scale
        };
    }

    checkHit(mx, my) {
        if (this.snapshots.length === 0 || this.currentSnapshotIndex < 0) return null;
        const snap = this.snapshots[this.currentSnapshotIndex];
        const data = snap.tableData;
        const meta = snap.meta || {};
        const L = this.layout;

        if(meta.rehashMode) return null; 

        const world = this.screenToWorld(mx, my);
        
        // Layout must match getSnapshotBounds / drawScene
        const arrayW = data.capacity * L.arrayCellSize;
        const totalW = L.leftPanelW + arrayW;
        const startX = -totalW / 2 + L.leftPanelW;
        const listTop = L.baseY + L.arrayCellSize + 20;

        for (let i = 0; i < data.capacity; i++) {
            const list = data.table[i];
            if (list && list.length > 0) {
                const cx = startX + i * L.arrayCellSize + L.arrayCellSize/2;
                let cy = listTop;
                for(let k = 0; k < list.length; k++) {
                    // Check intersection with the node box
                    if (world.x >= cx - L.nodeWidth/2 && world.x <= cx + L.nodeWidth/2 && 
                        world.y >= cy && world.y <= cy + L.nodeBoxH + L.nodePtrH) {
                        return { key: list[k].key, hash: app.ht.hash(list[k].key) };
                    }
                    cy += L.nodeVerticalStep; 
                }
            }
        }
        return null;
    }

    onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        
        const item = this.checkHit(mx, my);
        if (item) {
            document.getElementById('inputValue').value = item.key;
            return;
        }

        this.isDragging = true;
        this.dragStart = { x: mx, y: my };
        this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };
        this.canvas.style.cursor = 'grabbing';
    }

    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;

        const item = this.checkHit(mx, my);
        const tooltip = document.getElementById('tooltip');
        if (item) {
            this.canvas.style.cursor = 'pointer';
            tooltip.innerHTML = `Hash of <span class="tooltip-item">${item.key}</span> is <span class="tooltip-hash">${item.hash}</span>`;
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';
        } else {
            if(!this.isDragging) this.canvas.style.cursor = 'default';
            tooltip.style.display = 'none';
        }

        if (this.isDragging) {
            const dx = mx - this.dragStart.x;
            const dy = my - this.dragStart.y;
            this.camera.targetX = this.initialCamera.x - (dx / this.camera.scale);
            this.camera.targetY = this.initialCamera.y - (dy / this.camera.scale);
        }
    }

    onMouseUp(e) {
        this.isDragging = false;
        this.canvas.style.cursor = 'default';
    }

    onWheel(e) {
        e.preventDefault();
        const zoomIntensity = 0.001;
        const scroll = e.deltaY;
        let newScale = this.camera.targetScale * (1 - scroll * zoomIntensity);
        newScale = Math.min(Math.max(0.1, newScale), 5);

        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        const w = this.canvas.width, h = this.canvas.height;

        const worldX = this.camera.targetX + (mx - w / 2) / this.camera.targetScale;
        const worldY = this.camera.targetY + (my - h / 2) / this.camera.targetScale;

        this.camera.targetScale = newScale;
        this.camera.targetX = worldX - (mx - w / 2) / newScale;
        this.camera.targetY = worldY - (my - h / 2) / newScale;
    }

    getTouchDist(touches) { return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY); }

    onTouchStart(e) {
        if (e.touches.length === 1) {
            const t = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const mx = t.clientX - rect.left, my = t.clientY - rect.top;
            
            const item = this.checkHit(mx, my);
            const tooltip = document.getElementById('tooltip');

            if (item) {
                // Set value and Show Tooltip on Touch
                document.getElementById('inputValue').value = item.key;
                tooltip.innerHTML = `Hash of <span class="tooltip-item">${item.key}</span> is <span class="tooltip-hash">${item.hash}</span>`;
                tooltip.style.display = 'block';
                tooltip.style.left = (mx + 15) + 'px';
                tooltip.style.top = (my + 15) + 'px';
                return;
            } else {
                // Hide tooltip if touching empty space
                tooltip.style.display = 'none';
            }

            this.isDragging = true;
            this.dragStart = { x: mx, y: my };
            this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };
        } else if (e.touches.length === 2) {
            this.isDragging = false;
            this.initialPinchDist = this.getTouchDist(e.touches);
            this.initialScale = this.camera.targetScale;
        }
    }

    onTouchMove(e) {
        e.preventDefault();
        
        // Hide tooltip immediately when moving
        document.getElementById('tooltip').style.display = 'none';

        if (e.touches.length === 1 && this.isDragging) {
            const t = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const mx = t.clientX - rect.left, my = t.clientY - rect.top;
            const dx = mx - this.dragStart.x, dy = my - this.dragStart.y;
            this.camera.targetX = this.initialCamera.x - (dx / this.camera.scale);
            this.camera.targetY = this.initialCamera.y - (dy / this.camera.scale);
        } else if (e.touches.length === 2) {
            const dist = this.getTouchDist(e.touches);
            if (this.initialPinchDist > 0) {
                const scaleFactor = dist / this.initialPinchDist;
                this.camera.targetScale = Math.min(Math.max(0.1, this.initialScale * scaleFactor), 5);
            }
        }
    }

    onTouchEnd(e) { this.isDragging = false; this.initialPinchDist = 0; }

    loop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        // Inertia Camera Logic
        const camFactor = 1 - Math.exp(-10 * dt);
        this.camera.x += (this.camera.targetX - this.camera.x) * camFactor;
        this.camera.y += (this.camera.targetY - this.camera.y) * camFactor;
        this.camera.scale += (this.camera.targetScale - this.camera.scale) * camFactor;

        // State Machine
        if (this.state === 'CAMERA') {
            const dist = Math.hypot(this.camera.x - this.camera.targetX, this.camera.y - this.camera.targetY);
            // If camera is close enough, start morphing
            if (dist < 5 && Math.abs(this.camera.scale - this.camera.targetScale) < 0.05) {
                this.state = 'MORPH';
            }
        } 
        else if (this.state === 'MORPH' && !this.isPaused) {
            const snap = this.snapshots[this.currentSnapshotIndex];
            let moveSpeedModifier = 1.0;

            if (snap.meta && snap.meta.rehashMode && snap.meta.phase === 'FLYING') {
                moveSpeedModifier = 0.35; 
            }

            this.morphProgress += this.baseSpeed * this.currentSpeedFactor * moveSpeedModifier;

            if (this.morphProgress >= 1) {
                this.morphProgress = 1;
                this.state = 'WAITING';
                
                this.pauseTimer = 30 / this.currentSpeedFactor;
                if (snap.meta && snap.meta.pause) this.pauseTimer = 60;
                if (snap.meta && snap.meta.isCleanup) this.pauseTimer = 20;
                if (snap.meta && snap.meta.rehashMode && snap.meta.phase === 'FLYING') {
                    this.pauseTimer = 5 / this.currentSpeedFactor; 
                }
            }
        } 
        else if (this.state === 'WAITING' && !this.isPaused) {
            this.pauseTimer--;
            if (this.pauseTimer <= 0) {
                if (this.currentSnapshotIndex < this.snapshots.length - 1) {
                    this.currentSnapshotIndex++;
                    const nextSnap = this.snapshots[this.currentSnapshotIndex];
                    
                    // Progressive Zoom Update:
                    // Check bounds of the next step and adjust camera smoothly
                    const nextBounds = this.getSnapshotBounds(nextSnap);
                    this.fitBoundsToScreen(nextBounds);

                    this.morphProgress = 0;
                    this.state = 'MORPH';
                    if (nextSnap.meta && nextSnap.meta.text) document.getElementById('status-text').innerText = nextSnap.meta.text;
                    
                } else {
                    this.state = 'IDLE';
                    document.getElementById('status-text').innerText = "Ready.";
                }
            }
        }
        
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.snapshots.length === 0) return;

        const idx = Math.max(0, this.currentSnapshotIndex);
        const snap = this.snapshots[idx];
        const meta = snap.meta || {};

        this.ctx.save();
        // Camera Transform: Center World 0,0
        this.ctx.translate(this.canvas.width/2, this.canvas.height/2);
        this.ctx.scale(this.camera.scale, this.camera.scale);
        this.ctx.translate(-this.camera.x, -this.camera.y);

        this.drawScene(snap.tableData, meta);
        this.ctx.restore();
    }

    drawScene(data, meta) {
        const L = this.layout;
        
        // World Coordinates Calculation: Center everything around (0,0)
        // Standard View: Table + Panel centered
        const totalW = L.leftPanelW + data.capacity * L.arrayCellSize;
        const startX = -totalW / 2 + L.leftPanelW;
        
        if (meta.rehashMode) {
            // Rehash View: Old + Gap + New centered
            const oldW = meta.oldCapacity * L.arrayCellSize;
            const newW = data.capacity * L.arrayCellSize;
            const rehashTotalW = oldW + L.rehashGap + newW;
            const rehashStartX = -rehashTotalW / 2;
            
            this.drawRehashScene(data, meta, rehashStartX, L.baseY + 120);
            return;
        }

        this.drawStruct(startX - L.leftPanelW + 10, L.baseY, 40, data, startX);
        this.drawArrayAndLists(startX, L.baseY, L.arrayCellSize, data, meta);

        if (meta.hashCalc) {
            const fade = meta.isCleanup ? (1 - this.morphProgress) : 1;
            if (fade > 0) {
                this.ctx.globalAlpha = fade;
                const arrayCenterX = startX + (data.capacity * L.arrayCellSize) / 2;
                this.drawHashBox(arrayCenterX, L.baseY - 110, meta.hashCalc);
                this.ctx.globalAlpha = 1;
            }
        }
    }

    drawRehashScene(data, meta, startX, baseY) {
        const ctx = this.ctx;
        const L = this.layout;
        
        const oldTableX = startX;
        const newTableX = startX + (meta.oldCapacity * L.arrayCellSize) + L.rehashGap;

        // 1. OLD TABLE
        ctx.fillStyle = '#777'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
        ctx.fillText("Old Table", oldTableX + (meta.oldCapacity * L.arrayCellSize)/2, baseY - 30);

        const filteredOldTable = meta.oldTable.map(list => 
            list.filter(item => !meta.processedIds.includes(item.id) && (meta.flyingNode ? meta.flyingNode.id !== item.id : true))
        );
        
        const oldDataDummy = { capacity: meta.oldCapacity, table: filteredOldTable };
        this.drawArrayAndLists(oldTableX, baseY, L.arrayCellSize, oldDataDummy, { isCleanup: true });

        // 2. ARROW
        const arrowX1 = oldTableX + (meta.oldCapacity * L.arrayCellSize) + 20;
        const arrowX2 = newTableX - 20;
        this.drawArrow(arrowX1, baseY + L.arrayCellSize/2, arrowX2, baseY + L.arrayCellSize/2, '#555', 15);
        ctx.fillStyle = '#555'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
        ctx.fillText("Rehashing", (arrowX1+arrowX2)/2, baseY + L.arrayCellSize/2 - 10);

        // 3. NEW TABLE
        ctx.fillStyle = '#2E7D32'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
        ctx.fillText("New Table", newTableX + (data.capacity * L.arrayCellSize)/2, baseY - 30);

        let newDataForDraw = data;
        if (meta.phase === 'FLYING' && meta.flyingNode) {
            newDataForDraw = {
                ...data,
                table: data.table.map(list => list.filter(n => n.id !== meta.flyingNode.id))
            };
        }
        this.drawArrayAndLists(newTableX, baseY, L.arrayCellSize, newDataForDraw, { isCleanup: true });

        // 4. FLYING NODE
        if (meta.phase === 'FLYING' && meta.flyingNode) {
            const fNode = meta.flyingNode;
            
            const srcX = oldTableX + fNode.fromIdx * L.arrayCellSize + L.arrayCellSize/2;
            const srcY = baseY + L.arrayCellSize + 20 + fNode.fromDepth * L.nodeVerticalStep;
            
            const destList = data.table[fNode.toIdx];
            const destDepth = destList.findIndex(n => n.id === fNode.id); 
            
            const destX = newTableX + fNode.toIdx * L.arrayCellSize + L.arrayCellSize/2;
            const destY = baseY + L.arrayCellSize + 20 + (destDepth >= 0 ? destDepth : 0) * L.nodeVerticalStep;

            const t = this.morphProgress; 
            const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            
            const currX = srcX + (destX - srcX) * ease;
            const currY = srcY + (destY - srcY) * ease;
            
            this.ctx.globalAlpha = 1;
            this.drawSingleNode(currX, currY, fNode.key, '#FFD700', '#FFD700', '#000', 2); 
            
            if (t > 0.1) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(srcX, srcY + 15);
                ctx.lineTo(currX, currY + 15);
                ctx.strokeStyle = '#FFD700';
                ctx.stroke();
                ctx.restore();
            }
        }
    }

    drawStruct(x, y, w, data, arrowDestX) {
        const ctx = this.ctx;
        const h = 35; 

        ctx.textAlign = 'right'; ctx.font = '16px Arial'; ctx.fillStyle = '#000';
        ctx.fillText('table', x - 5, y + 23);
        ctx.fillStyle = COLORS.STRUCT_KEYS_BG;
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = '#fff'; ctx.strokeRect(x, y, w, h);
        
        const dotX = x + w/2; const dotY = y + h/2;
        ctx.beginPath(); ctx.arc(dotX, dotY, 5, 0, Math.PI*2);
        ctx.fillStyle = COLORS.DOT; ctx.fill();
        this.drawArrow(dotX, dotY, arrowDestX, dotY, COLORS.ARROW_REF, 10);

        ctx.textAlign = 'right'; ctx.fillStyle = '#000';
        ctx.fillText('size', x - 5, y + h + 23);
        ctx.fillStyle = COLORS.STRUCT_STATS_BG;
        ctx.fillRect(x, y + h, w, h);
        ctx.strokeStyle = '#fff'; ctx.strokeRect(x, y + h, w, h);
        ctx.textAlign = 'center'; ctx.fillStyle = COLORS.TEXT_RED; ctx.font = '22px Arial';
        ctx.fillText(data.size, x + w/2, y + h + 24);

        ctx.textAlign = 'right'; ctx.font = '14px Arial'; ctx.fillStyle = '#000';
        ctx.fillText('maxLoadFactor', x - 5, y + h*2 + 23);
        ctx.fillStyle = COLORS.STRUCT_STATS_BG;
        ctx.fillRect(x, y + h*2, w, h);
        ctx.strokeStyle = '#fff'; ctx.strokeRect(x, y + h*2, w, h);
        ctx.textAlign = 'center'; ctx.fillStyle = COLORS.TEXT_RED; ctx.font = '22px Arial';
        ctx.fillText(data.maxLoadFactor, x + w/2, y + h*2 + 24);
    }

    drawArrayAndLists(x, y, size, data, meta) {
        const ctx = this.ctx;
        const table = data.table;
        const listStartY = y + size + 20;
        const L = this.layout;

        const isAnimating = (this.state !== 'IDLE'); 

        for(let i = 0; i < data.capacity; i++) {
            const cx = x + i * size;
            const cy = y;

            // Index
            ctx.fillStyle = '#000'; ctx.font = '14px monospace'; ctx.textAlign = 'center';
            ctx.fillText(i, cx + size/2, cy - 8);

            // Cell
            ctx.fillStyle = COLORS.CELL_BG;
            if (meta.missIndex === i && !meta.isCleanup) ctx.fillStyle = COLORS.MISS_BG;

            ctx.fillRect(cx, cy, size, size);
            ctx.strokeStyle = COLORS.CELL_STROKE; ctx.lineWidth = 1;
            ctx.strokeRect(cx, cy, size, size);

            const dotX = cx + size/2;
            const dotY = cy + size/2;
            ctx.beginPath(); ctx.arc(dotX, dotY, 5, 0, Math.PI*2);
            ctx.fillStyle = (meta.missIndex === i && !meta.isCleanup) ? '#fff' : COLORS.DOT; 
            ctx.strokeStyle = ctx.fillStyle;
            ctx.fill();

            const list = table[i] || [];
            const hasList = list.length > 0;
            
            let showGhostInsert = (meta.animation === 'slideDown' && meta.animationCol === i && isAnimating);

            if (hasList) {
                this.drawArrow(dotX, dotY, dotX, listStartY, COLORS.ARROW_REF, 8);
                this.drawLinkedListNodes(dotX, listStartY, list, i, meta, isAnimating, this.morphProgress);
            } else {
                if (showGhostInsert) {
                    this.drawArrow(dotX, dotY, dotX, listStartY, COLORS.ARROW_REF, 8);
                    
                    const splitTime = 0.7;
                    let ghostAlpha = 0;
                    if (this.morphProgress > splitTime) {
                        ghostAlpha = (this.morphProgress - splitTime) / (1 - splitTime);
                    }
                    
                    if (ghostAlpha > 0) {
                        ctx.globalAlpha = ghostAlpha;
                        this.drawSingleNode(dotX, listStartY, meta.animationKey, COLORS.HIT_BG, COLORS.CELL_BG);
                        ctx.globalAlpha = 1;
                    }
                } else {
                    ctx.strokeStyle = (meta.missIndex === i && !meta.isCleanup) ? '#fff' : COLORS.DOT; 
                    ctx.lineWidth = 2; ctx.stroke();
                }
            }

            if (meta.targetIndex === i && !meta.isCleanup) {
                 this.drawArrow(dotX, dotY - 70, dotX, dotY - 42, COLORS.ARROW_PROBE, 8);
            }
        }
    }

    drawLinkedListNodes(centerX, startY, list, colIndex, meta, isAnimating, progress) {
        const ctx = this.ctx;
        const L = this.layout;

        const getVisualProps = (k) => {
            let y = startY + k * L.nodeVerticalStep;
            let alpha = 1;
            
            if (isAnimating && meta.animationCol === colIndex) {
                if (meta.animation === 'slideDown') {
                    const splitTime = 0.7;
                    if (k === 0) {
                        y = startY; 
                        if (progress < splitTime) {
                            alpha = 0; 
                        } else {
                            alpha = (progress - splitTime) / (1 - splitTime);
                        }
                    } else {
                        const slideProgress = Math.min(progress / splitTime, 1); 
                        y = startY + (k - 1 + slideProgress) * L.nodeVerticalStep;
                    }
                } 
                else if (meta.animation === 'slideUp') {
                    if (k === meta.animationDepth) {
                        alpha = 1 - progress; 
                    } else if (k > meta.animationDepth) {
                        y = startY + (k - progress) * L.nodeVerticalStep;
                    }
                }
            }
            return { y, alpha };
        };

        for(let k = 0; k < list.length; k++) {
            const node = list[k];
            const props = getVisualProps(k);
            
            if (props.alpha <= 0.01) continue; 

            ctx.globalAlpha = props.alpha;

            let bg = COLORS.DATA_BG;
            let ptrBg = COLORS.CELL_BG;
            let fgPtr = COLORS.DOT;
            let ptrBorder = '#fff';
            let ptrWidth = 1;

            if (!meta.isCleanup && meta.highlightNode && meta.highlightNode.col === colIndex && meta.highlightNode.depth === k) {
                const type = meta.highlightNode.type;
                if (type === 'HIT') bg = COLORS.HIT_BG;
                if (type === 'EXAMINE') bg = COLORS.EXAMINE_BG;
                if (type === 'MISS_PTR') {
                    ptrBg = COLORS.MISS_BG; 
                    fgPtr = '#fff';
                    ptrWidth = 2;
                }
            }
            if (node.highlight === 'HIT') bg = COLORS.HIT_BG;

            this.drawSingleNode(centerX, props.y, node.key, bg, ptrBg, ptrBorder, ptrWidth, fgPtr);

            if (k < list.length - 1) {
                const nextProps = getVisualProps(k+1);
                const dotY = props.y + L.nodeBoxH + L.nodePtrH/2;
                
                ctx.globalAlpha = Math.min(props.alpha, nextProps.alpha);
                
                let targetY = nextProps.y;
                
                if (isAnimating && meta.animation === 'slideUp' && k === meta.animationDepth - 1 && k+2 < list.length) {
                     const sliderProps = getVisualProps(k+2);
                     targetY = sliderProps.y;
                     ctx.globalAlpha = 1;
                }

                if (ctx.globalAlpha > 0.05) {
                    this.drawArrow(centerX, dotY, centerX, targetY, COLORS.ARROW_REF, 6);
                }
            } 
            
            ctx.globalAlpha = 1;
        }
    }

    drawSingleNode(centerX, y, val, bgData, bgPtr, ptrBorder='#fff', ptrWidth=1, fgPtr = COLORS.DOT) {
        const ctx = this.ctx;
        const L = this.layout;

        ctx.fillStyle = bgData;
        ctx.fillRect(centerX - L.nodeWidth/2, y, L.nodeWidth, L.nodeBoxH);
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
        ctx.strokeRect(centerX - L.nodeWidth/2, y, L.nodeWidth, L.nodeBoxH);
        ctx.fillStyle = COLORS.TEXT_RED; ctx.font = '20px Arial'; ctx.textAlign = 'center';
        ctx.fillText(val, centerX, y + 22);

        const ptrY = y + L.nodeBoxH;
        ctx.fillStyle = bgPtr;
        ctx.fillRect(centerX - L.nodeWidth/2, ptrY, L.nodeWidth, L.nodePtrH);
        ctx.strokeStyle = ptrBorder; ctx.lineWidth = ptrWidth;
        ctx.strokeRect(centerX - L.nodeWidth/2, ptrY, L.nodeWidth, L.nodePtrH);
        
        const dotY = ptrY + L.nodePtrH/2;
        ctx.beginPath(); ctx.arc(centerX, dotY, 4, 0, Math.PI*2);
        ctx.fillStyle = fgPtr; ctx.fill();
    }

    drawArrow(x1, y1, x2, y2, color, headSize=5) {
        const ctx = this.ctx;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
        const angle = Math.atan2(y2-y1, x2-x1);
        this.drawArrowHead(x2, y2, angle, color, headSize);
    }

    drawArrowHead(x, y, angle, color, size) {
        const ctx = this.ctx;
        ctx.fillStyle = color;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-size, -size/2);
        ctx.lineTo(-size, size/2);
        ctx.fill();
        ctx.restore();
    }

    drawHashBox(x, y, info) {
        const ctx = this.ctx;
        const w = 100; const h = 40;
        const boxX = x - w/2; const boxY = y;

        ctx.fillStyle = COLORS.TEXT_RED; ctx.font = '24px Arial'; ctx.textAlign = 'right';
        ctx.fillText(info.key, boxX - 40, boxY + 26);
        this.drawArrow(boxX - 35, boxY + 18, boxX - 1, boxY + 18, COLORS.ARROW_PROBE, 8);

        ctx.fillStyle = COLORS.HASH_BOX_BG;
        ctx.fillRect(boxX, boxY, w, h);
        ctx.fillStyle = '#000'; ctx.font = '20px Arial'; ctx.textAlign = 'center';
        ctx.fillText('hash', boxX + w/2, boxY + 26);

        this.drawArrow(boxX + w + 1, boxY + 18, boxX + w + 40, boxY + 18, COLORS.ARROW_PROBE, 8);
        ctx.fillStyle = '#000'; ctx.font = '24px Arial'; ctx.textAlign = 'left';
        ctx.fillText(info.hash, boxX + w + 45, boxY + 26);
    }
}

const app = {
    ht: new SeparateChainingHashTable(5),
    viz: null,

    init: function() { 
        this.viz = new Visualizer('htCanvas'); 
        
        const initialData = this.ht.getSnapshotData();
        
        this.viz.snapshots = [{ 
            tableData: initialData, 
            meta: { text: "Ready." } 
        }];
        this.viz.currentSnapshotIndex = 0;
        
        // Initial Auto-Fit
        const bounds = this.viz.getSnapshotBounds(this.viz.snapshots[0]);
        this.viz.fitBoundsToScreen(bounds);
        this.viz.camera.x = this.viz.camera.targetX;
        this.viz.camera.y = this.viz.camera.targetY;
        this.viz.camera.scale = this.viz.camera.targetScale;

        this.viz.draw();
        this.updateUI(); 
    },
    
    updateSpeed: function() { 
        this.viz.setSpeed(parseFloat(document.getElementById('speedSlider').value)); 
    },
    
    togglePause: function() {
        const isPaused = this.viz.togglePause();
        document.getElementById('btnPause').innerText = isPaused ? "Resume" : "Pause";
    },

    updateUI: function() {
        document.getElementById('btnUndo').disabled = (this.ht.history.length === 0);
    },

    runOp: function(fn) {
        if(this.viz.isPaused) this.togglePause();
        if(this.viz.state !== 'IDLE') return;

        const snaps = [];
        snaps.push({ tableData: this.ht.getSnapshotData(), meta: {} });
        fn((tableData, metaData) => { snaps.push({ tableData: tableData, meta: metaData }); });
        this.viz.enqueueOperation(snaps);
        this.updateUI();
    },

    handleInsert: function() {
        const el = document.getElementById('inputValue');
        const val = el.value.charAt(0); 
        if (val.length > 0) {
            this.runOp(record => this.ht.insert(val, record));
            el.value = ''; 
        }
    },

    handleDelete: function() {
        const el = document.getElementById('inputValue');
        const val = el.value.charAt(0);
        if (val.length > 0) {
            this.runOp(record => this.ht.delete(val, record));
            el.value = '';
        }
    },

    handleSearch: function() {
        const el = document.getElementById('inputValue');
        const val = el.value.charAt(0);
        if (val.length > 0) {
            this.runOp(record => this.ht.search(val, record));
        }
    },

    handleUndo: function() {
        const oldTable = this.ht.restoreFromHistory();
        if (oldTable) {
            this.viz.enqueueOperation([{ tableData: this.ht.getSnapshotData(), meta: { text: "Undo successful." } }]);
            this.updateUI();
        }
    },

    handleClear: function() {
        // Stop any ongoing animation immediately
        this.viz.state = 'IDLE'; 
        this.viz.currentSnapshotIndex = -1;
        this.viz.snapshots = [];

        this.ht = new SeparateChainingHashTable(5);
        const snap = { tableData: this.ht.getSnapshotData(), meta: { text: "Table cleared." } };
        
        // Directly push and fit, without smooth transition from broken state
        this.viz.snapshots = [snap];
        this.viz.currentSnapshotIndex = 0;
        const bounds = this.viz.getSnapshotBounds(snap);
        this.viz.fitBoundsToScreen(bounds);
        this.viz.draw();
        
        this.updateUI();
    },

    handleRandomFill: function() {
        this.handleClear();
        
        // Re-enable state for random fill
        this.viz.state = 'IDLE'; 
        
        const count = 9; 
        const snaps = [];
        const batchRecord = (data, meta) => snaps.push({tableData: data, meta: meta});
        snaps.push({ tableData: this.ht.getSnapshotData(), meta: { text: "Starting Random Fill..." } });
        
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split('');

        for (let i = chars.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [chars[i], chars[j]] = [chars[j], chars[i]];
        }

        for(let i=0; i<count; i++) {
            this.ht.insert(chars[i], batchRecord);
        }
        
        this.viz.enqueueOperation(snaps);
        this.updateUI();
    },

    toggleModal: function() {
        const m = document.getElementById('helpModal');
        m.style.display = (m.style.display === 'block') ? 'none' : 'block';
    }
};

window.onload = () => app.init();

</script>
</body>
</html>