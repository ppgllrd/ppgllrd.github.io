<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Min-Heap Visualizer</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: #f5f5f5;
            --border-color: #ddd;
            
            /* UI Colors */
            --btn-insert: #2E7D32; 
            --btn-delete: #c62828; 
            --btn-search: #1668BD; 
            --btn-undo: #6A1B9A;   
            --btn-gray: #546E7A;
            --btn-random: #EF6C00;
            --btn-heapify: #00838F; 
            --btn-mapping: #D84315; 
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex; flex-direction: column; 
            height: 100vh; height: 100dvh; 
            overflow: hidden; user-select: none;
        }

        header {
            padding: 10px 20px; background-color: var(--panel-bg);
            display: flex; flex-direction: column; gap: 10px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .header-top { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .gui { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        
        h1 { margin: 0; font-size: 1.2rem; color: #222; }
        
        .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .sub-controls { display: flex; gap: 15px; align-items: center; font-size: 0.9rem; color: #555; vertical-align: middle;}

        input[type="number"] {
            padding: 6px; border-radius: 4px; border: 1px solid #999;
            background: #fff; color: #000; width: 60px; text-align: center; font-weight: bold;
        }
        input[type="range"] { width: 100px; cursor: pointer; }

        button {
            padding: 6px 14px; border: none; border-radius: 4px; cursor: pointer;
            font-weight: 600; color: white; transition: filter 0.2s, transform 0.1s;
            font-size: 0.85rem; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }

        .btn-insert { background-color: var(--btn-insert); }
        .btn-delete { background-color: var(--btn-delete); }
        .btn-search { background-color: var(--btn-search); }
        .btn-undo { background-color: var(--btn-undo); }
        .btn-clear { background-color: var(--btn-gray); }
        .btn-random { background-color: var(--btn-random); }
        .btn-heapify { background-color: var(--btn-heapify); }
        .btn-mapping { background-color: var(--btn-mapping); } 
        .btn-pause { background-color: #455A64; width: 80px;}
        .btn-help { background-color: #607D8B; font-size: 1.1rem; padding: 4px 10px; border-radius: 50%; }

        #canvas-container {
            flex-grow: 1; position: relative; overflow: hidden;
            background-color: var(--bg-color);
            cursor: default; /* Changed from crosshair to default for dynamic cursor */
            min-height: 0;
        }
        canvas { display: block; width: 100%; height: 100%; -webkit-tap-highlight-color: transparent; }

        #legend {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255,255,255,0.95); padding: 10px;
            border: 1px solid #ddd; border-radius: 8px; font-size: 0.8rem;
            pointer-events: none; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; color: #333; }
        .dot { width: 14px; height: 14px; border-radius: 50%; }
        .square { width: 14px; height: 14px; border-radius: 2px; }
        .line-icon { width: 15px; height: 3px; border-radius: 2px; }
        .arrow-icon { font-size: 16px; font-weight: bold; color: #cc0000; }

        #status-bar {
            padding: 8px 2px 0px 0px; background-color: var(--panel-bg);
            font-size: 0.85rem; border-top: 1px solid var(--border-color);
            display: flex; justify-content: space-between; color: #555;
            flex-shrink: 0;
        }
        #status-text { font-weight: bold; color: #222; }

        #author { 
            width: 100%;
            background: #f4f7f6; 
            font-size: 0.75em; color: #777; text-align: center; line-height: 2.5;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }

        /* Modal */
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 8px; max-height: 80vh; overflow-y: auto; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: black; }
        h2 { color: #2E7D32; margin-top:0; }
        h3 { color: #1668BD; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 15px;}
        p, li { font-size: 0.95rem; line-height: 1.5; color: #333; }
        .complexity { font-family: monospace; background: #eee; padding: 2px 5px; border-radius: 4px; color: #c62828; }
        
        .node-sample {
            display: inline-block; width: 30px; height: 30px; border-radius: 50%;
            background: #B0F9B0; border: 2px solid #B0F9B0; /* Updated Sample Color */
            text-align: center; line-height: 26px; position: relative;
            font-family: Arial, sans-serif; font-weight: bold;
        }    
        .node-val { color: #D50000; font-size: 12px; }
    </style>
</head>
<body>

<header>
    <div class="header-top">
        <h1>Binary Min-Heap Visualizer</h1>
        <button class="btn-help" onclick="app.toggleModal()" title="Help / Algorithms">?</button>
    </div>
    <div class="gui">
        <div class="controls">
            <input type="number" id="inputValue" title="Enter a number" placeholder="#" onkeydown="if(event.key==='Enter') app.handleInsert()">
            <button class="btn-insert" title="Insert a value" onclick="app.handleInsert()">Insert</button>
            <button class="btn-delete" title="Delete the minimum element (Root)" onclick="app.handleExtractMin()">Delete Min</button>
            <button class="btn-search" title="Show minimum element" onclick="app.handleMinimum()">Minimum</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>
            
            <button class="btn-random" title="Sequential Insertion O(n log n)" onclick="app.handleRandomHeap()">Random</button>
            <button class="btn-heapify" title="Floyd's Algorithm O(n)" onclick="app.handleBuildHeap()">Build Heap</button>

            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>
            <button class="btn-mapping" title="Show how tree maps to array" onclick="app.handleShowMapping()">Array Mapping</button>
            
            <div style="width:1px; height:20px; background:#ccc; margin: 0 5px;"></div>

            <button class="btn-undo" title="Undo last operation" onclick="app.handleUndo()" id="btnUndo" disabled>Undo</button>
            <button class="btn-clear" title="Clear the heap" onclick="app.handleClear()">Clear</button>
        </div>
        <div class="sub-controls">
            <label for="speedSlider">Speed:</label>
            <label title="Slide right to slow down the animation">
                <input type="range" id="speedSlider" min="1" max="5" step="0.1" value="1" oninput="app.updateSpeed()">
            </label>
            <button class="btn-pause" title="Pause or Resume" onclick="app.togglePause()" id="btnPause">Pause</button>
        </div>
    </div>
    <div id="status-bar">
        <span id="status-text">Ready. Use Mouse/Touch to Pan & Zoom.</span>
    </div>
</header>

<div id="canvas-container">
    <canvas id="treeCanvas"></canvas>
    <div id="legend">
        <div class="legend-item">
            <div class="node-sample"><span class="node-val">V</span></div>&nbsp; Node
        </div>
        <div class="legend-item"><div class="dot" style="background:#CC99FF; border:1px solid #fff"></div>&nbsp; Insert / Move</div>
        <div class="legend-item"><div class="dot" style="background:#99FFFF; border:1px solid #fff"></div>&nbsp; Comparing</div>
        <div class="legend-item"><div class="dot" style="background:#00E676; border:1px solid #fff"></div>&nbsp; Satisfied</div>
        <div class="legend-item"><div class="dot" style="background:#FFFF66; border:1px solid #fff"></div>&nbsp; Heapified Subtree</div>
        <div class="legend-item"><div class="dot" style="background:#F44336; border:1px solid #fff"></div>&nbsp; Delete</div>
        <div class="legend-item"><div class="line-icon" style="background:#1668BD;"></div>&nbsp; Link</div>
    </div>
</div>

<div id="author">Pepe Gallardo. Dpto. Lenguajes y Ciencias de la Computación. Universidad de Málaga</div>

<!-- Help Modal -->
<div id="helpModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="app.toggleModal()">&times;</span>
        <h2>Binary Min-Heap</h2>
        
        <h3>Properties</h3>
        <p>A complete binary tree where each node satisfies the <strong>Min-Heap property</strong>: The key of the parent is less than or equal to the key of the children.</p>
        <p>The minimum element is always at the root.</p>
        
        <h3>Operations</h3>
        <ul>
            <li><strong>Insert:</strong> Add at the end (bottom-right) and "bubble up" (swap with parent). <span class="complexity">O(log n)</span></li>
            <li><strong>Delete Minimum:</strong> Remove root, move last element to root, and "bubble down" (swap with smallest child). <span class="complexity">O(log n)</span></li>
            <li><strong>Get Minimum:</strong> Minimum element is at the root. <span class="complexity">O(1)</span></li>
        </ul>
        
        <h3>Array Mapping</h3>
        <p>The heap is stored in an array level-by-level:</p>
        <ul>
            <li>Root is at index <code>0</code>.</li>
            <li>For any node at index <code>i</code>:
                <ul>
                    <li>Left Child: <code>2*i + 1</code></li>
                    <li>Right Child: <code>2*i + 2</code></li>
                    <li>Parent: <code>⌊(i-1)/2⌋</code></li>
                </ul>
            </li>
        </ul>

        <h3>Build Algorithms</h3>
        <p><strong>Random Heap (Sequential):</strong> Inserts n elements one by one.<br>
        Complexity: <span class="complexity">O(n log n)</span></p>
        
        <p><strong>Build Heap (Floyd's Algorithm):</strong> Treats array as a tree and heapifies subtrees from bottom up (last non-leaf node to root).<br>
        Complexity: <span class="complexity">O(n)</span> (More efficient!)</p>
    </div>
</div>

<script>
const COLORS = {
    DEFAULT: '#B0F9B0',    // Green
    STROKE: '#B0F9B0',     
  
    TEXT: '#CC0000',       // Red Text
    EDGE: '#1668BD',       // Blue Edges
    
    NEW: '#CC99FF',        // Purple (Insert/Move)
    SELECTED: '#99FFFF',   // Cyan (Selected child)
    COMPARING: '#99FFFF',     // Cyan (Parent in compare)
    SATISFIED: '#00E676', // Green (Condition met)
    HEAPIFIED: '#FFFF66',      // Yellow (Subtree done)
    DELETE: '#F44336',         // Red (Delete)
    
    ARROW: '#D50000',          // Red Arrow
    ARRAY_BG: '#FAFAFA',
    ARRAY_BORDER: '#1668BD',
    
    // Level Colors for mapping visualization
    LEVELS: [
        '#FFCC80', // Level 0 (Orange)
        '#F8BBD0', // Level 1 (Pink)
        '#BBDEFB', // Level 2 (Blue)
        '#E1BEE7', // Level 3 (Purple)
        '#B2DFDB', // Level 4 (Teal)
        '#F0F4C3', // Level 5 (Lime)
        '#CFD8DC'  // Level 6 (Gray)
    ]
};

class MinHeap {
    constructor() {
        this.heap = [];
        this.history = [];
    }

    saveToHistory() {
        const state = [...this.heap];
        this.history.push(state);
        if (this.history.length > 25) this.history.shift();
    }

    restoreFromHistory() {
        if (this.history.length === 0) return null;
        this.heap = this.history.pop();
        return [...this.heap];
    }

    parent(i) { return Math.floor((i - 1) / 2); }
    left(i) { return 2 * i + 1; }
    right(i) { return 2 * i + 2; }

    minimum(recordSnapshot) {
        if (this.heap.length === 0) {
            recordSnapshot([], { text: "Heap is empty." });
            return;
        }
        recordSnapshot([...this.heap], {
            text: `Minimum element is ${this.heap[0].val}`,
            highlights: [{ idx: 0, color: COLORS.NEW }],
            pause: true
        });
        recordSnapshot([...this.heap], { text: "Ready." });
    }

    insert(val, recordSnapshot) {
        this.saveToHistory();
        this.heap.push(val); 
        let curr = this.heap.length - 1;
        
        recordSnapshot([...this.heap], { 
            text: `Inserted ${val.val} at index ${curr}`,
            highlights: [{ idx: curr, color: COLORS.NEW }],
            pause: true
        });

        while (curr > 0) {
            let p = this.parent(curr);
            
            recordSnapshot([...this.heap], {
                text: `Comparing ${this.heap[curr].val} with parent ${this.heap[p].val}`,
                highlights: [
                    { idx: curr, color: COLORS.NEW },
                    { idx: p, color: COLORS.COMPARING }
                ],
                pause: true
            });

            if (this.heap[curr].val < this.heap[p].val) {
                [this.heap[curr], this.heap[p]] = [this.heap[p], this.heap[curr]];
                recordSnapshot([...this.heap], {
                    text: `Swapped because ${this.heap[p].val} < ${this.heap[curr].val}`,
                    highlights: [{ idx: p, color: COLORS.NEW }] 
                });
                curr = p;
            } else {
                recordSnapshot([...this.heap], { 
                    text: 'Order Satisfied (Parent <= Child)', 
                    highlights: [{ idx: curr, color: COLORS.SATISFIED }, { idx: p, color: COLORS.SATISFIED }],
                    pause: true
                });
                break;
            }
        }
        if (curr === 0) {
            recordSnapshot([...this.heap], { 
                text: 'Reached root, insertion complete.', 
                highlights: [{ idx: curr, color: COLORS.SATISFIED }],
                pause: true
            });
        }

        recordSnapshot([...this.heap], { text: 'Insert complete.' });
    }

    extractMin(recordSnapshot) {
        if (this.heap.length === 0) return;
        this.saveToHistory();

        const min = this.heap[0];
        const lastIdx = this.heap.length - 1;
        const last = this.heap[lastIdx];

        recordSnapshot([...this.heap], {
            text: `Extracting Min: ${min.val}`,
            highlights: [{ idx: 0, color: COLORS.DELETE }],
            pause: true
        });

        if (this.heap.length === 1) {
            this.heap.pop();
            recordSnapshot([], { text: 'Heap empty' });
            return;
        }

        recordSnapshot([...this.heap], {
            text: `Moving last element (${last.val}) to root...`,
            highlights: [{ idx: 0, color: COLORS.DELETE }, { idx: lastIdx, color: COLORS.NEW }],
            arrow: { from: lastIdx, to: 0 },
            pause: true
        });

        this.heap[0] = last;
        this.heap.pop(); 

        recordSnapshot([...this.heap], {
            text: `Replaced root with ${last.val}`,
            highlights: [{ idx: 0, color: COLORS.NEW }]
        });

        this.heapifyDown(0, recordSnapshot);
        recordSnapshot([...this.heap], { text: 'Extract Min complete.' });
    }

    buildHeap(inputArray, recordSnapshot) {
        this.heap = [...inputArray];
        let heapifiedSet = new Set();

        recordSnapshot([...this.heap], { text: "Initial Unsorted Array" });

        const startIdx = Math.floor(this.heap.length / 2) - 1;
        
        for (let i = startIdx + 1; i < this.heap.length; i++) {
            heapifiedSet.add(i);
        }
        
        if (heapifiedSet.size > 0) {
            recordSnapshot([...this.heap], {
                text: "Leaves are trivial heaps (Yellow)",
                heapifiedSet: new Set(heapifiedSet),
                pause: true
            });
        }

        for (let i = startIdx; i >= 0; i--) {
            recordSnapshot([...this.heap], {
                text: `Heapifying down from index ${i}`,
                highlights: [{ idx: i, color: COLORS.NEW }],
                heapifiedSet: new Set(heapifiedSet),
                pause: true
            });

            this.heapifyDown(i, recordSnapshot, heapifiedSet, true);

            const markSubtree = (idx) => {
                if (idx >= this.heap.length) return;
                heapifiedSet.add(idx);
                markSubtree(this.left(idx));
                markSubtree(this.right(idx));
            };
            markSubtree(i);

            recordSnapshot([...this.heap], {
                text: `Subtree at ${i} heapified`,
                heapifiedSet: new Set(heapifiedSet),
                pause: true
            });
        }

        recordSnapshot([...this.heap], { 
            text: "Heap construction complete.",
            heapifiedSet: new Set(heapifiedSet) 
        });
    }

    heapifyDown(index, recordSnapshot, persistentSet = null, isBuildHeap = false) {
        const size = this.heap.length;
        
        while (true) {
            let left = this.left(index);
            let right = this.right(index);
            let smallestChildIdx = -1;

            const getMeta = (txt, hls) => ({
                text: txt,
                highlights: hls,
                heapifiedSet: persistentSet ? new Set(persistentSet) : null,
                pause: true
            });

            if (left < size && right < size) {
                recordSnapshot([...this.heap], getMeta(
                    `Comparing children: ${this.heap[left].val} vs ${this.heap[right].val}`,
                    [{ idx: left, color: COLORS.SELECTED }, { idx: right, color: COLORS.SELECTED }]
                ));
                smallestChildIdx = (this.heap[left].val <= this.heap[right].val) ? left : right;
            } else if (left < size) {
                smallestChildIdx = left;
            } else {
                recordSnapshot([...this.heap], { 
                    text: 'Leaf reached', 
                    highlights: [{idx: index, color: COLORS.SATISFIED}],
                    heapifiedSet: persistentSet ? new Set(persistentSet) : null,
                    pause: true
                });
                break;
            }

            recordSnapshot([...this.heap], getMeta(
                `Comparing Parent (${this.heap[index].val}) vs Child (${this.heap[smallestChildIdx].val})`,
                [{ idx: index, color: COLORS.NEW }, { idx: smallestChildIdx, color: COLORS.SELECTED }]
            ));

            if (this.heap[smallestChildIdx].val < this.heap[index].val) {
                [this.heap[index], this.heap[smallestChildIdx]] = [this.heap[smallestChildIdx], this.heap[index]];
                let heapifiedColor = COLORS.DEFAULT;
                if (isBuildHeap) {
                    persistentSet.add(index);
                    heapifiedColor = COLORS.HEAPIFIED;
                }
                recordSnapshot([...this.heap], {
                    text: 'Swapped',
                    highlights: [{ idx: smallestChildIdx, color: COLORS.NEW }, { idx: index, color: heapifiedColor }],
                    heapifiedSet: persistentSet ? new Set(persistentSet) : null
                });
                index = smallestChildIdx;
            } else {
                recordSnapshot([...this.heap], {
                    text: 'Order Satisfied',
                    highlights: [
                        { idx: index, color: COLORS.SATISFIED },
                        { idx: smallestChildIdx, color: COLORS.SATISFIED }
                    ],
                    heapifiedSet: persistentSet ? new Set(persistentSet) : null,
                    pause: true
                });
                break;
            }
        }
    }

    // Nueva función para visualizar el mapeo de array
    visualizeArrayMapping(recordSnapshot) {
        if (this.heap.length === 0) {
            recordSnapshot([], { text: "Heap empty." });
            return;
        }

        const levelColorsMap = {}; // Map index -> color
        const depth = Math.floor(Math.log2(this.heap.length));

        // Estado inicial
        recordSnapshot([...this.heap], { text: "Starting Array Mapping visualization..." });

        for (let level = 0; level <= depth; level++) {
            const color = COLORS.LEVELS[level % COLORS.LEVELS.length];
            const startIdx = Math.pow(2, level) - 1;
            const endIdx = Math.pow(2, level + 1) - 2;

            // Marcar índices de este nivel
            for (let i = startIdx; i <= endIdx && i < this.heap.length; i++) {
                levelColorsMap[i] = color;
            }

            // Snapshot para mostrar el progreso de este nivel
            recordSnapshot([...this.heap], {
                text: `Mapping Level ${level} (Indices ${startIdx} to ${Math.min(endIdx, this.heap.length-1)})`,
                levelColors: {...levelColorsMap},
                pause: true
            });
        }

        // Estado final
        recordSnapshot([...this.heap], {
            text: "Mapping complete. Tree levels correspond to contiguous array segments.",
            levelColors: {...levelColorsMap}
        });
    }
}

class Visualizer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.camera = { scale: 1, targetScale: 1, x: 0, targetX: 0, y: 0, targetY: 0 };
        this.nodeRadius = 28;
        this.levelHeight = 80;
        this.arrayBoxSize = 45; 
        this.snapshots = [];
        this.currentSnapshotIndex = -1;
        this.lastDrawnNodes = [];
        this.lastDrawnArrayRects = [];
        
        this.state = 'IDLE';
        this.isPaused = false;
        this.morphProgress = 0;
        this.baseMorphSpeed = 3.0; // Time-based speed
        this.currentSpeedFactor = 1;
        this.pauseTimer = 0;
        
        // --- Navigation State (Zoom/Pan) ---
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.initialCamera = { x: 0, y: 0 };
        this.initialPinchDist = 0;
        this.initialScale = 1;
        this.hoveredObject = null;

        this.resize();
        
        // --- Event Listeners ---
        window.addEventListener('resize', () => this.resize());
        
        // Unified Mouse Events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.onMouseUp());
        this.canvas.addEventListener('mouseleave', () => this.onMouseLeave());
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
        
        // Unified Touch Events
        this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.onTouchEnd(e));
        
        // Modal close
        window.onclick = (e) => {
             if (e.target == document.getElementById('helpModal')) app.toggleModal();
        }

        this.lastTime = 0;
        requestAnimationFrame(t => this.loop(t));
    }

    // --- Input Handling ---

    checkHit(mx, my) {
        // Check Nodes
        for (let n of this.lastDrawnNodes) {
            const sx = (n.x * this.camera.scale) + this.camera.x;
            const sy = (n.y * this.camera.scale) + this.camera.y;
            const r = this.nodeRadius * this.camera.scale;
            if (Math.hypot(mx - sx, my - sy) < r) {
                return { type: 'node', val: n.val };
            }
        }
        // Check Array Boxes
        for (let cell of this.lastDrawnArrayRects) {
            const sx = (cell.x * this.camera.scale) + this.camera.x;
            const sy = (cell.y * this.camera.scale) + this.camera.y;
            const sw = cell.w * this.camera.scale;
            const sh = cell.h * this.camera.scale;
            if (mx >= sx && mx <= sx + sw && my >= sy && my <= sy + sh) {
                return { type: 'array', val: cell.val };
            }
        }
        return null;
    }

    onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        const hit = this.checkHit(mx, my);
        if (hit) {
            document.getElementById('inputValue').value = hit.val;
            // document.getElementById('inputValue').focus();
            return;
        }

        // Start Pan
        this.isDragging = true;
        this.dragStart = { x: mx, y: my };
        this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };
        this.canvas.style.cursor = 'grabbing';
    }

    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        const hit = this.checkHit(mx, my);
        this.hoveredObject = hit;

        if (this.isDragging) {
            this.canvas.style.cursor = 'grabbing';
        } else if (this.hoveredObject) {
            this.canvas.style.cursor = 'pointer';
        } else {
            this.canvas.style.cursor = 'default';
        }

        if (!this.isDragging) return;

        const dx = mx - this.dragStart.x;
        const dy = my - this.dragStart.y;
        this.camera.targetX = this.initialCamera.x + dx;
        this.camera.targetY = this.initialCamera.y + dy;
    }

    onMouseUp() {
        this.isDragging = false;
        this.canvas.style.cursor = this.hoveredObject ? 'pointer' : 'default';
    }

    onMouseLeave() {
        this.isDragging = false;
        this.canvas.style.cursor = 'default';
    }

    onWheel(e) {
        e.preventDefault(); 
        const zoomIntensity = 0.001;
        const scroll = e.deltaY;
        let newScale = this.camera.targetScale * (1 - scroll * zoomIntensity);
        newScale = Math.min(Math.max(0.2, newScale), 5);

        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const worldX = (mouseX - this.camera.targetX) / this.camera.targetScale;
        const worldY = (mouseY - this.camera.targetY) / this.camera.targetScale;

        this.camera.targetScale = newScale;
        this.camera.targetX = mouseX - worldX * newScale;
        this.camera.targetY = mouseY - worldY * newScale;
    }

    getTouchDistance(touches) {
        return Math.hypot(
            touches[0].clientX - touches[1].clientX,
            touches[0].clientY - touches[1].clientY
        );
    }

    onTouchStart(e) {
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const mx = touch.clientX - rect.left;
            const my = touch.clientY - rect.top;

            const hit = this.checkHit(mx, my);
            if (hit) {
                document.getElementById('inputValue').value = hit.val;
                // document.getElementById('inputValue').focus();
                return;
            }

            this.isDragging = true;
            this.dragStart = { x: mx, y: my };
            this.initialCamera = { x: this.camera.targetX, y: this.camera.targetY };

        } else if (e.touches.length === 2) {
            this.isDragging = false;
            this.initialPinchDist = this.getTouchDistance(e.touches);
            this.initialScale = this.camera.targetScale;
        }
    }

    onTouchMove(e) {
        e.preventDefault();

        if (e.touches.length === 1 && this.isDragging) {
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const mx = touch.clientX - rect.left;
            const my = touch.clientY - rect.top;

            const dx = mx - this.dragStart.x;
            const dy = my - this.dragStart.y;
            this.camera.targetX = this.initialCamera.x + dx;
            this.camera.targetY = this.initialCamera.y + dy;

        } else if (e.touches.length === 2) {
            const currentDist = this.getTouchDistance(e.touches);
            
            if (this.initialPinchDist > 0) {
                const scaleFactor = currentDist / this.initialPinchDist;
                let newScale = this.initialScale * scaleFactor;
                newScale = Math.min(Math.max(0.2, newScale), 5);

                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const worldCenterX = (centerX - this.camera.targetX) / this.camera.targetScale;
                const worldCenterY = (centerY - this.camera.targetY) / this.camera.targetScale;
                
                this.camera.targetScale = newScale;
                this.camera.targetX = centerX - worldCenterX * newScale;
                this.camera.targetY = centerY - worldCenterY * newScale;
            }
        }
    }

    onTouchEnd(e) {
        this.isDragging = false;
        this.initialPinchDist = 0;
    }

    // --- Core Visualization Methods ---

    resize() {
        this.canvas.width = document.getElementById('canvas-container').offsetWidth;
        this.canvas.height = document.getElementById('canvas-container').offsetHeight;
        if (this.snapshots.length > 0 && this.currentSnapshotIndex >= 0) {
            const snap = this.snapshots[this.currentSnapshotIndex];
            if(snap) {
                this.fitBoundsToScreen(this.calculateBounds(snap.heapData));
                this.camera.scale = this.camera.targetScale;
                this.camera.x = this.camera.targetX;
                this.camera.y = this.camera.targetY;
            }
        }
    }

    setSpeed(val) { this.currentSpeedFactor = 1 / val; }
    togglePause() { this.isPaused = !this.isPaused; return this.isPaused; }

    layoutTree(heapData) {
        if (!heapData || heapData.length === 0) return { nodes: [] };
        const nodes = [];
        const depth = Math.floor(Math.log2(heapData.length));
        const initialSpan = Math.pow(2, depth) * 60; 
        const traverse = (idx, x, y, span) => {
            if (idx >= heapData.length) return;
            nodes.push({ id: heapData[idx].id, val: heapData[idx].val, x: x, y: y, idx: idx });
            const nextSpan = span / 2;
            traverse(2 * idx + 1, x - nextSpan, y + this.levelHeight, nextSpan);
            traverse(2 * idx + 2, x + nextSpan, y + this.levelHeight, nextSpan);
        };
        traverse(0, 0, 50, initialSpan);
        return { nodes };
    }

    calculateBounds(heapData) {
        let bounds = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity, hasNodes: false };
        if (!heapData || heapData.length === 0) return bounds;
        const res = this.layoutTree(heapData);
        res.nodes.forEach(n => {
            bounds.hasNodes = true;
            bounds.minX = Math.min(bounds.minX, n.x);
            bounds.maxX = Math.max(bounds.maxX, n.x);
            bounds.minY = Math.min(bounds.minY, n.y);
            bounds.maxY = Math.max(bounds.maxY, n.y);
        });
        const arrWidth = heapData.length * this.arrayBoxSize;
        bounds.minX = Math.min(bounds.minX, -arrWidth/2);
        bounds.maxX = Math.max(bounds.maxX, arrWidth/2);
        bounds.maxY = Math.max(bounds.maxY, 200 + this.arrayBoxSize + 100);
        return bounds;
    }

    enqueueOperation(snapshots) {
        this.snapshots.push(...snapshots);
        let gBounds = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity, hasNodes: false };
        snapshots.forEach(s => {
            const b = this.calculateBounds(s.heapData);
            if(b.hasNodes) {
                gBounds.hasNodes = true;
                gBounds.minX = Math.min(gBounds.minX, b.minX);
                gBounds.maxX = Math.max(gBounds.maxX, b.maxX);
                gBounds.minY = Math.min(gBounds.minY, b.minY);
                gBounds.maxY = Math.max(gBounds.maxY, b.maxY);
            }
        });
        this.fitBoundsToScreen(gBounds);
        if (this.currentSnapshotIndex === -1 && this.snapshots.length > 0) {
            this.currentSnapshotIndex = 0;
        }
        if (this.state === 'IDLE' && this.snapshots.length > 0) {
            this.state = 'CAMERA';
        }
    }

    fitBoundsToScreen(bounds) {
        if (!bounds.hasNodes) {
            this.camera.targetScale = 1; this.camera.targetX = this.canvas.width / 2; this.camera.targetY = 100;
            return;
        }
        const padding = 80;
        const w = (bounds.maxX - bounds.minX) + padding;
        const h = (bounds.maxY - bounds.minY) + padding + 150; 
        const scale = Math.min(1.1, Math.min(this.canvas.width / w, this.canvas.height / h));
        const cx = (bounds.minX + bounds.maxX) / 2;
        const cy = bounds.minY; 
        this.camera.targetScale = scale;
        this.camera.targetX = (this.canvas.width / 2) - (cx * scale);
        this.camera.targetY = 100;
    }

    loop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        if (!this.isPaused) this.update(Math.min(dt, 0.1));
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }

    update(dt) {
        const camSpeed = 10.0;
        const factor = 1 - Math.exp(-camSpeed * dt);

        this.camera.scale += (this.camera.targetScale - this.camera.scale) * factor;
        this.camera.x += (this.camera.targetX - this.camera.x) * factor;
        this.camera.y += (this.camera.targetY - this.camera.y) * factor;

        if (this.state === 'CAMERA') {
            if (Math.abs(this.camera.scale - this.camera.targetScale) < 0.01) this.state = 'MORPH';
        } else if (this.state === 'MORPH') {
            this.morphProgress += this.baseMorphSpeed * this.currentSpeedFactor * dt;
            if (this.morphProgress >= 1) {
                this.morphProgress = 1;
                if (this.pauseAfterMorph) {
                    this.state = 'WAITING';
                    this.pauseTimer = 0.8 / this.currentSpeedFactor; // Seconds
                } else { this.nextStep(); }
            }
        } else if (this.state === 'WAITING') {
            this.pauseTimer -= dt; 
            if (this.pauseTimer <= 0) this.nextStep();
        }
    }

    nextStep() {
        if (this.currentSnapshotIndex < this.snapshots.length - 1) {
            this.currentSnapshotIndex++;
            const snap = this.snapshots[this.currentSnapshotIndex];
            if (snap.meta.text) document.getElementById('status-text').innerText = snap.meta.text;
            this.pauseAfterMorph = snap.meta.pause;
            this.morphProgress = 0;
            this.state = 'MORPH';
        } else {
            this.state = 'IDLE';
            document.getElementById('status-text').innerText = "Ready.";
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save();
        
        // Consistent Camera transform
        this.ctx.translate(this.canvas.width/2, this.canvas.height/2); 
        this.ctx.translate((this.camera.x - this.canvas.width/2), (this.camera.y - this.canvas.height/2));
        this.ctx.translate(-this.camera.x, -this.camera.y); 
        this.ctx.setTransform(this.camera.scale, 0, 0, this.camera.scale, this.camera.x, this.camera.y);

        if (this.snapshots.length === 0) { this.ctx.restore(); return; }

        const idx = this.currentSnapshotIndex;
        if (idx >= 0 && idx < this.snapshots.length) {
            let currentHeap, nextHeap, t, currentMeta;
            if (this.state === 'IDLE' || idx >= this.snapshots.length - 1) {
                currentHeap = this.snapshots[idx].heapData;
                nextHeap = currentHeap;
                t = 1;
                currentMeta = this.snapshots[idx].meta;
            } else {
                currentHeap = this.snapshots[idx].heapData;
                nextHeap = this.snapshots[idx + 1] ? this.snapshots[idx + 1].heapData : currentHeap;
                currentMeta = (this.morphProgress > 0.5 && this.snapshots[idx+1]) ? this.snapshots[idx+1].meta : this.snapshots[idx].meta;
                t = this.easeInOut(this.morphProgress);
            }

            const layoutA = this.layoutTree(currentHeap);
            const layoutB = this.layoutTree(nextHeap);
            const renderNodes = this.interpolateNodes(layoutA.nodes, layoutB.nodes, t, currentMeta);
            
            this.lastDrawnNodes = renderNodes;

            const refHeap = t < 0.5 ? currentHeap : nextHeap;
            const nodeMap = new Map(renderNodes.map(n => [n.id, n]));
            
            this.ctx.beginPath();
            this.ctx.strokeStyle = COLORS.EDGE;
            this.ctx.lineWidth = 3;
            refHeap.forEach((obj, index) => {
                if (index === 0) return;
                const parentIdx = Math.floor((index - 1) / 2);
                const parentObj = refHeap[parentIdx];
                const childNode = nodeMap.get(obj.id);
                const parentNode = parentObj ? nodeMap.get(parentObj.id) : null;
                if (childNode && parentNode) {
                    this.ctx.moveTo(parentNode.x, parentNode.y);
                    this.ctx.lineTo(childNode.x, childNode.y);
                }
            });
            this.ctx.stroke();

            refHeap.forEach((obj, index) => {
                const n = nodeMap.get(obj.id);
                if(!n) return;
                const leftIdx = 2 * index + 1;
                const rightIdx = 2 * index + 2;
                if (leftIdx >= refHeap.length) this.drawNullLink(n.x, n.y, 'L');
                if (rightIdx >= refHeap.length) this.drawNullLink(n.x, n.y, 'R');
            });

            renderNodes.forEach(n => this.drawNodeCircle(n.x, n.y, n.val, n.color));

            if (currentMeta && currentMeta.arrow) {
                const fromObj = refHeap[currentMeta.arrow.from];
                const toObj = refHeap[currentMeta.arrow.to];
                if(fromObj && toObj) {
                    const nFrom = nodeMap.get(fromObj.id);
                    const nTo = nodeMap.get(toObj.id);
                    if(nFrom && nTo) {
                        this.drawStraightArrow(nFrom.x, nFrom.y, nTo.x, nTo.y);
                    }
                }
            }

            this.drawArrayView(currentHeap, nextHeap, t, currentMeta);
        }
        this.ctx.restore();
    }

    interpolateNodes(nodesA, nodesB, t, meta) {
        const mapA = new Map(nodesA.map(n => [n.id, n]));
        const mapB = new Map(nodesB.map(n => [n.id, n]));
        const ids = new Set([...mapA.keys(), ...mapB.keys()]);
        const result = [];

        ids.forEach(id => {
            const nA = mapA.get(id); const nB = mapB.get(id);
            let x, y, val, color = COLORS.DEFAULT;
            
            const refHeap = (t > 0.5 && this.snapshots[this.currentSnapshotIndex+1]) ? this.snapshots[this.currentSnapshotIndex+1].heapData : this.snapshots[this.currentSnapshotIndex].heapData;
            const currentIdx = refHeap.findIndex(h => h.id === id);

            // Priority 1: Level Mapping Color
            if (meta && meta.levelColors && meta.levelColors[currentIdx]) {
                color = meta.levelColors[currentIdx];
            }
            // Priority 2: Heapified Set (only if no level color)
            else if (meta && meta.heapifiedSet && meta.heapifiedSet.has(currentIdx)) {
                color = COLORS.HEAPIFIED;
            }

            // Priority 3: Highlights (overrides all)
            if (meta && meta.highlights) {
                const hl = meta.highlights.find(h => h.idx === currentIdx);
                if (hl) color = hl.color;
            }

            if (nA && nB) {
                x = nA.x + (nB.x - nA.x) * t; y = nA.y + (nB.y - nA.y) * t; val = nB.val;
            } else if (!nA && nB) { 
                x = nB.x; y = nB.y; val = nB.val;
            } else if (nA && !nB) { 
                x = nA.x; y = nA.y; val = nA.val; if(t > 0.5) color = 'transparent';
            }
            if(color !== 'transparent') result.push({ id, x, y, val, color });
        });
        return result;
    }

    drawArrayView(heapA, heapB, t, meta) {
        const maxLen = Math.max(heapA.length, heapB.length);
        if(maxLen === 0) return;
        const depth = Math.floor(Math.log2(maxLen));
        const treeBottom = 50 + (depth * this.levelHeight) + 120;
        const boxSize = this.arrayBoxSize;
        const startX = -(maxLen * boxSize) / 2;
        this.lastDrawnArrayRects = [];

        const len = (t < 0.5) ? heapA.length : heapB.length;
        
        for(let i=0; i<len; i++) {
            const bx = startX + i * boxSize;
            this.ctx.fillStyle = '#222';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(i, bx + boxSize/2, treeBottom - 9); 
        }

        const mapA = new Map(heapA.map((d, i) => [d.id, i]));
        const mapB = new Map(heapB.map((d, i) => [d.id, i]));
        const ids = new Set([...mapA.keys(), ...mapB.keys()]);

        ids.forEach(id => {
            const idxA = mapA.has(id) ? mapA.get(id) : -1;
            const idxB = mapB.has(id) ? mapB.get(id) : -1;
            if (idxA === -1 && idxB === -1) return;

            let curIdx, val, opacity = 1;
            if (idxA !== -1 && idxB !== -1) {
                curIdx = idxA + (idxB - idxA) * t; val = heapA[idxA].val;
            } else if (idxA === -1) {
                curIdx = idxB; val = heapB[idxB].val; opacity = t;
            } else {
                curIdx = idxA; val = heapA[idxA].val; opacity = 1 - t;
            }

            const bx = startX + curIdx * boxSize;
            const by = treeBottom;
            
            this.lastDrawnArrayRects.push({ x: bx, y: by, w: boxSize, h: boxSize, val: val });

            this.ctx.globalAlpha = opacity;
            
            let color = COLORS.DEFAULT;
            let textColor = COLORS.TEXT;
            const refIdx = Math.round(curIdx);
            
            // Priority 1: Level Mapping Color
            if (meta && meta.levelColors && meta.levelColors[refIdx]) {
                color = meta.levelColors[refIdx];
            }
            // Priority 2: Heapified
            else if (meta && meta.heapifiedSet && meta.heapifiedSet.has(refIdx)) {
                color = COLORS.HEAPIFIED;
            }
            
            // Priority 3: Highlights
            if (meta && meta.highlights) {
                const hl = meta.highlights.find(h => h.idx === refIdx);
                if (hl) {
                    color = hl.color;
                }
                if (color === COLORS.DELETE || color == COLORS.SATISFIED) {
                    textColor = '#fff';
                }
            }

            this.ctx.fillStyle = color;
            this.ctx.fillRect(bx, by, boxSize, boxSize);
            
            // Array Border
            this.ctx.strokeStyle = '#fff';
            
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(bx, by, boxSize, boxSize);

            this.ctx.fillStyle = textColor;
            this.ctx.font = '21px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(val, bx + boxSize/2, by + boxSize/2);
            this.ctx.globalAlpha = 1;
        });
    }

    drawNullLink(x, y, side) {
        const r = this.nodeRadius;
        const spread = 12; const drop = 25; const dir = (side === 'L') ? -1 : 1;
        const startX = x + (r * 0.5 * dir); const startY = y + (r * 0.8);
        const endX = x + (r + spread) * dir; const endY = y + r + drop;
        this.ctx.beginPath(); this.ctx.strokeStyle = COLORS.EDGE; this.ctx.lineWidth = 3;
        this.ctx.moveTo(startX, startY); this.ctx.lineTo(endX, endY); this.ctx.stroke();
        const perpSize = 8;
        const dx = endX - startX; const dy = endY - startY;
        const angle = Math.atan2(dy, dx); const perpAngle = angle + Math.PI / 2;
        this.ctx.beginPath();
        this.ctx.moveTo(endX - perpSize * Math.cos(perpAngle), endY - perpSize * Math.sin(perpAngle));
        this.ctx.lineTo(endX + perpSize * Math.cos(perpAngle), endY + perpSize * Math.sin(perpAngle));
        this.ctx.stroke();
    }

    drawStraightArrow(x1, y1, x2, y2) {
        const ctx = this.ctx;
        const headlen = 15;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const sx = x1 + this.nodeRadius * Math.cos(angle);
        const sy = y1 + this.nodeRadius * Math.sin(angle);
        const ex = x2 - this.nodeRadius * Math.cos(angle);
        const ey = y2 - this.nodeRadius * Math.sin(angle);

        ctx.beginPath();
        ctx.strokeStyle = COLORS.ARROW;
        ctx.lineWidth = 3;
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();

        ctx.beginPath();
        ctx.fillStyle = COLORS.ARROW;
        ctx.moveTo(ex, ey);
        ctx.lineTo(ex - headlen * Math.cos(angle - Math.PI/6), ey - headlen * Math.sin(angle - Math.PI/6));
        ctx.lineTo(ex - headlen * Math.cos(angle + Math.PI/6), ey - headlen * Math.sin(angle + Math.PI/6));
        ctx.fill();
    }

    drawNodeCircle(x, y, val, color) {
        const r = this.nodeRadius;
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI * 2);
        this.ctx.fillStyle = color;
        this.ctx.fill();
        
        let stroke = '#fff';
        let textCol = '#fff';
        
        this.ctx.fillStyle = COLORS.TEXT; // Red Text
        if (color === COLORS.DEFAULT) {
            this.ctx.strokeStyle = COLORS.STROKE; 
            
        } else {
            // Highlights have white border
            this.ctx.strokeStyle = '#fff';
            // this.ctx.fillStyle = '#fff';
        }

        if (color === COLORS.DELETE || color === COLORS.SATISFIED) {
            this.ctx.fillStyle = '#fff';
        }

        this.ctx.lineWidth = 3;
        this.ctx.stroke();
        
        this.ctx.font = '22px Arial';
        this.ctx.textAlign = 'center'; 
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(val, x, y+1);
    }

    easeInOut(t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }
}

const app = {
    heap: new MinHeap(),
    viz: null,
    uidCounter: 0,
    init: function() { this.viz = new Visualizer('treeCanvas'); this.updateUI(); },
    updateSpeed: function() { this.viz.setSpeed(parseFloat(document.getElementById('speedSlider').value)); },
    togglePause: function() {
        const isPaused = this.viz.togglePause();
        const btn = document.getElementById('btnPause');
        btn.innerText = isPaused ? "Resume" : "Pause";
    },
    createItem: function(val) { return { val: val, id: this.uidCounter++ }; },
    handleInsert: function() {
        const val = parseInt(document.getElementById('inputValue').value);
        if (!isNaN(val)) { this.runOp(rec => this.heap.insert(this.createItem(val), rec)); document.getElementById('inputValue').value = ''; }
    },
    handleExtractMin: function() { this.runOp(rec => this.heap.extractMin(rec)); },
    handleMinimum: function() { this.runOp(rec => this.heap.minimum(rec)); },
    handleUndo: function() {
        if (this.heap.history.length === 0) return;
        const oldHeap = this.heap.restoreFromHistory();
        this.viz.enqueueOperation([{ heapData: JSON.parse(JSON.stringify(oldHeap)), meta: { text: "Undo successful" } }]);
        this.updateUI();
    },
    handleClear: function() {
        this.heap = new MinHeap();
        this.viz.snapshots = [];
        this.viz.currentSnapshotIndex = -1;
        this.viz.camera.targetScale = 1;
        this.viz.draw();
        this.updateUI();
    },
    handleRandomHeap: function() {
        this.handleClear();
        const snaps = []; snaps.push({ heapData: [], meta: {} });
        const count = 12;
        for(let i=0; i<count; i++) {
            const item = this.createItem(Math.floor(Math.random() * 100) + 1);
            this.heap.insert(item, (data, meta) => { snaps.push({ heapData: JSON.parse(JSON.stringify(data)), meta }); });
        }
        snaps.push({ heapData: JSON.parse(JSON.stringify(this.heap.heap)), meta: { text: "Random Heap Ready" } }); 
        this.viz.enqueueOperation(snaps);
        this.updateUI();
    },
    handleBuildHeap: function() {
        this.handleClear();
        const input = [];
        for(let i=0; i<13; i++) input.push(this.createItem(Math.floor(Math.random() * 100) + 1));
        this.runOp(rec => this.heap.buildHeap(input, rec));
    },
    handleShowMapping: function() {
        // Si el heap está vacío, construimos uno aleatorio instantáneamente
        if (this.heap.heap.length === 0) {
            const count = 15; 
            for(let i=0; i<count; i++) {
                const item = this.createItem(Math.floor(Math.random() * 100) + 1);
                // Pasamos una función vacía como callback para que NO registre snapshots
                // De esta forma la inserción es interna e instantánea.
                this.heap.insert(item, () => {});
            }
        }
        this.runOp(rec => this.heap.visualizeArrayMapping(rec));
    },
    toggleModal: function() {
        const m = document.getElementById('helpModal');
        m.style.display = (m.style.display === 'block') ? 'none' : 'block';
    },
    runOp: function(fn) {
        if(this.viz.isPaused) this.togglePause();
        if (this.viz.state !== 'IDLE') return;
        const snaps = [];
        snaps.push({ heapData: JSON.parse(JSON.stringify(this.heap.heap)), meta: {} });
        fn((data, meta) => snaps.push({ heapData: JSON.parse(JSON.stringify(data)), meta }));
        this.viz.enqueueOperation(snaps);
        this.updateUI();
    },
    updateUI: function() { document.getElementById('btnUndo').disabled = (this.heap.history.length === 0); }
};

window.onload = () => app.init();
</script>
</body>
</html>