<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Changed Title -->
    <title>Visualización Barajado Fisher-Yates</title>
    <style>
        /* --- ESTILOS GENERALES --- */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f4;
        }

        h1,
        h2 {
            color: #333;
            text-align: center;
        }


        /* Contenedor principal de la visualización */
        #visualization-container {
            position: relative;
            height: 280px;
            width: 90%;
            max-width: 800px;
            border: 1px solid #ccc;
            background-color: #fff;
            padding: 10px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 80px;
        }

        /* Contenedor de las barras del array */
        #array-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 95%;
            width: 100%;
            position: relative;
            gap: 2px;
            bottom: 5px;
        }

        /* Estilo base para cada barra representando un elemento del array */
        .bar {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            background-color: steelblue;
            /* Color por defecto: no procesado */
            flex-grow: 1;
            flex-basis: 0;
            max-width: 50px;
            text-align: center;
            color: white;
            font-size: 12px;
            position: relative;
            /* Necesario para posicionar el índice absoluto */
            transition: background-color 0.4s ease, height 0.3s ease, transform 0.3s ease-in-out; /* Added transform transition */
            box-sizing: border-box;
            border: 1px solid #eee;
            outline: 2px solid transparent;
            outline-offset: -2px;
            padding-bottom: 5px;
            margin-bottom: 5px;
            bottom: 10px;
            /* Espacio debajo para el índice */
        }

        /* Estilo para el valor numérico mostrado DENTRO de la barra */
        .bar-value {
            color: white;
            font-weight: bold;
            font-size: 10px;
            z-index: 1;
            text-shadow: 1px 1px 2px black;
            position: absolute;
            /* Posición relativa a la barra padre */
            bottom: 5px;
            /* Colocar encima del espacio para el índice */
            left: 0;
            width: 100%;
            text-align: center;
        }

        /* --- CONTENEDOR Y ESTILOS PARA ÍNDICES NUMÉRICOS BAJO LAS BARRAS --- */
        #index-container {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            bottom: 75px;
            /* Posicionado justo debajo de las barras */
            left: 10px;
            right: 10px;
            height: 20px;
            gap: 2px;
            /* Mismo espacio que las barras */
            pointer-events: none;
            /* No interfiere con clics */
            z-index: 5;
        }

        .index-label {
            flex-grow: 1;
            flex-basis: 0;
            max-width: 50px;
            /* Coincide con max-width de barras */
            text-align: center;
            font-size: 10px;
            color: #666;
            font-weight: bold;
        }

        /* --- ESTADOS DE LAS BARRAS DURANTE EL BARAJADO --- */
        /* Barra en la posición 'i' (elemento actual a intercambiar) */
        .bar.bar-i {
            background-color: mediumpurple !important;
            z-index: 10;
        }

        /* Borde naranja para indicar la barra 'p' candidata elegida al azar */
        .bar.bar-p-candidate {
            outline-width: 3px;
            z-index: 10;
            outline-color: orange !important;
        }

        /* Borde rojo para indicar elementos a punto de intercambiarse (durante el flash) */
        .bar.bar-red-border {
            outline-width: 3px;
            z-index: 10;
            /* Asegura que el borde sea visible */
            outline-color: red !important;
        }

        /* Barra ya fijada en su posición final barajada (a la izquierda de 'i') */
        .bar.bar-fixed {
            background-color: mediumseagreen !important; /* Changed from mediumseagreen */
            outline-color: transparent !important; /* Sin borde especial */
        }

        /* Usado para el efecto de parpadeo (flash) de los bordes */
        .bar.bar-flash-off {
            outline-color: transparent !important;
        }


        /* --- CONTENEDOR Y ESTILOS DE PUNTEROS (i, p) --- */
        #pointers-container {
            position: absolute;
            bottom: 15px;
            /* Posicionado debajo de los índices */
            left: 0;
            width: 100%;
            height: 70px; /* Altura suficiente para los 2 punteros */
            pointer-events: none;
            /* No interfiere con clics */
        }

        .pointer {
            position: absolute;
            transform: translateX(-50%);
            /* Centrado horizontalmente */
            background-color: rgba(50, 50, 50, 0.8);
            /* Base oscura */
            color: white;
            padding: 1px 3px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            /* Evita que el texto se parta */
            transition: left 0.4s ease-in-out;
            /* Animación de movimiento */
            visibility: hidden;
            /* Oculto por defecto */
            z-index: 20;
            /* Por encima de las barras e índices */
            min-width: 15px;
            text-align: center;
        }

        /* Flecha indicadora del puntero */
        .pointer::before {
            content: '';
            position: absolute;
            left: 50%;
            top: -7px;
            /* Posiciona la flecha sobre el cuadro */
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            /* El color del borde inferior se define por puntero */
        }

        #pointer-i {
            background-color: mediumpurple;
            bottom: 25px; /* Posición ajustada */
        }

        #pointer-i::before {
            border-bottom: 7px solid mediumpurple;
        }

        /* Pointer 'p' (replaces 'j') */
        #pointer-p {
            background-color: rgba(255, 165, 0, 0.8); /* Orange for 'p' */
            bottom: 0; /* Posición más baja */
        }

        #pointer-p::before {
            border-bottom: 7px solid rgba(255, 165, 0, 0.8);
        }
        /* Removed #pointer-posMin */


        /* --- CONTROLES (Botones, Sliders) --- */
        #controls-container {
            margin: 20px 0;
            padding: 15px;
            background-color: #eee;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            width: 90%;
            max-width: 800px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Estilo general para TODOS los botones dentro del contenedor */
        #controls-container button {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid #ccc; /* Borde por defecto */
            border-radius: 4px;
            background-color: #f8f8f8; /* Fondo por defecto (gris claro) */
            color: #333; /* Color de texto por defecto */
            font-size: 14px;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; /* Añadida transición de color */
        }

        /* Estilo para botones desactivados */
        #controls-container button:disabled {
            background-color: #cccccc;
            color: #888;
            cursor: not-allowed;
            border-color: #bbb;
        }

        /* --- Colores específicos para los botones principales --- */
        #start-pause-btn {
            background-color: #60a5fa; /* Azul */
            color: white;
            border-color: #3b82f6;
        }
        #step-btn {
            background-color: #fbbf24; /* Amarillo/Naranja */
            color: white;
            border-color: #f59e0b;
        }
        #reset-btn {
            background-color: #f87171; /* Rojo */
            color: white;
            border-color: #ef4444;
        }

        /* --- Efectos HOVER específicos para los botones principales --- */
        #start-pause-btn:hover:not(:disabled) {
            background-color: #3b82f6; /* Azul más oscuro */
            border-color: #2563eb;
        }
        #step-btn:hover:not(:disabled) {
            background-color: #f59e0b; /* Amarillo/Naranja más oscuro */
            border-color: #d97706;
        }
        #reset-btn:hover:not(:disabled) {
            background-color: #ef4444; /* Rojo más oscuro */
            border-color: #dc2626;
        }

        /* Estilos para los botones de tamaño y los otros (mantienen el hover gris por defecto si se desea) */
         #controls-container .size-control button:hover:not(:disabled),
         #controls-container #random-array-btn:hover:not(:disabled),
         #controls-container #manual-input-btn:hover:not(:disabled) {
            background-color: #e0e0e0; /* Hover gris claro para otros botones */
            border-color: #aaa;
         }


        .size-control label { margin-right: 5px; }
        .size-control span {
            min-width: 25px; text-align: center; padding: 5px 8px; background-color: white;
            border: 1px solid #ccc; border-radius: 3px; display: inline-block;
        }
        .size-control button { font-weight: bold; padding: 4px 8px; min-width: 25px; }
        .speed-control label { margin-right: 5px; }
        .speed-control input[type="range"] { cursor: pointer; width: 100px; }

        /* --- CONTENEDOR DE CÓDIGO --- */
        #code-container {
            width: 90%;
            max-width: 800px;
            margin-top: 20px;
            background-color: #2d2d2d; /* Fondo oscuro */
            color: #ccc; /* Texto claro */
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            line-height: 1;
            overflow-x: auto; /* Scroll horizontal si el código es largo */
            visibility: hidden;
            display: none;
        }

        #code-container h2 {
            color: #eee; margin: 0 0 10px 0; font-size: 16px;
            border-bottom: 1px solid #555; padding-bottom: 5px;
        }

        #code-listing span[data-line] {
            padding: 2px 0; display: inline-block; width: 100%; border-radius: 3px;
            transition: background-color 0.3s ease; line-height: normal; white-space: pre;
        }

        #code-listing span[data-line].highlight-line {
            background-color: rgba(255, 255, 100, 0.25); /* Amarillo translúcido */
        }

        /* --- COLOREADO DE SINTAXIS (Ejemplo básico) --- */
        #code-listing .syntax-keyword { color: #569cd6; }
        #code-listing .syntax-type { color: #4ec9b0; }
        #code-listing .syntax-function { color: #dcdcaa; }
        #code-listing .syntax-operator { color: #b5cea8; }
        #code-listing .syntax-comment { color: #6a9955; font-style: italic; }
        #code-listing .syntax-variable { color: #9cdcfe; }
        #code-listing .syntax-generic { color: #4ec9b0; }
        #code-listing .syntax-package { color: #ce9178; }
        #code-listing .syntax-number { color: #b5cea8; }
        #code-listing .syntax-class { color: #4ec9b0; } /* Added for Random */
        #code-listing .syntax-method { color: #dcdcaa; } /* Added for int method */

        #desc-container {
            width: 90%;
            max-width: 800px;
            background-color: #ededed;
            color: #000;
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            line-height: 1.4; /* Mejorado para legibilidad */
            overflow-x: auto;
            text-align: justify;
        }
    </style>
</head>

<body>
    <!-- Changed Title -->
    <h1>Visualización Barajado Fisher-Yates</h1>
    <div id="visualization-container">
        <div id="array-container"></div>
        <div id="index-container"></div>
        <div id="pointers-container">
            <div class="pointer" id="pointer-i">i</div>
            <!-- Renamed pointer-j to pointer-p -->
            <div class="pointer" id="pointer-p">p</div>
            <!-- Removed pointer-posMin -->
        </div>
    </div>
    <div id="controls-container">
        <div class="control-group">
            <button id="start-pause-btn">Iniciar</button>
            <button id="step-btn">Paso Siguiente</button>
            <button id="reset-btn">Resetear</button>
        </div>
        <div class="control-group speed-control">
            <label for="speed-slider">Velocidad:</label>
            <input type="range" id="speed-slider" min="0" max="100" value="50">
        </div>
        <div class="control-group size-control">
            <label>Tamaño:</label>
            <button id="decrease-size-btn">-</button>
            <span id="size-display">10</span>
            <button id="increase-size-btn">+</button>
        </div>
        <div class="control-group">
            <button id="random-array-btn">Generar Ordenado</button> <!-- Changed Button Text -->
            <button id="manual-input-btn">Introducir Datos</button>
        </div>
    </div>
    <div id="desc-container">
        El algoritmo de Fisher-Yates, también conocido como algoritmo de barajado, reorganiza los elementos de un array de manera aleatoria. Para ello, recorre el array
        desde el primer índice hasta el penúltimo, utilizando un índice <b>i</b>. En cada iteración, selecciona un índice aleatorio <b>p</b> dentro del rango que va desde
        <b>i</b> (incluido) hasta el último índice del array (también incluido). Luego, intercambia los elementos ubicados en las posiciones <b>i</b> y <b>p</b>. El
        algoritmo emplea un generador de números pseudoaleatorios, que puede inicializarse con una semilla para asegurar que el barajado sea reproducible. Gracias a su
        diseño, el algoritmo garantiza que, al finalizar, cada elemento del array tiene exactamente la misma probabilidad de estar en cualquier posición, logrando una distribución
        uniforme y completamente aleatoria de los elementos.
    </div>
    <div id="code-container">
        <!-- Changed Algorithm Title -->
        <h2>Algoritmo Fisher-Yates (Scala):</h2>
        <!-- Updated Code Block -->
        <pre><code id="code-listing">
<span data-line="0"><span class="syntax-keyword">import</span> <span class="syntax-package">scala.util.Random</span></span>
<span data-line="1"></span>
<span data-line="2"><span class="syntax-keyword">def</span> <span class="syntax-function">baraja</span>[<span class="syntax-generic">A</span>](<span class="syntax-variable">xs</span>: <span class="syntax-type">Array</span>[<span class="syntax-generic">A</span>], <span class="syntax-variable">semilla</span>: <span class="syntax-type">Int</span>): <span class="syntax-type">Unit</span> <span class="syntax-operator">=</span></span>
<span data-line="3">  <span class="syntax-keyword">val</span> <span class="syntax-variable">azar</span> <span class="syntax-operator">=</span> <span class="syntax-keyword">new</span> <span class="syntax-class">Random</span>(<span class="syntax-variable">semilla</span>) <span class="syntax-comment">// 1. Crear generador</span></span>
<span data-line="4"></span>
<span data-line="5">  <span class="syntax-comment">// Función auxiliar para intercambiar (igual que antes)</span></span>
<span data-line="6">  <span class="syntax-keyword">def</span> <span class="syntax-function">swap</span>(<span class="syntax-variable">arr</span>: <span class="syntax-type">Array</span>[<span class="syntax-generic">A</span>], <span class="syntax-variable">p1</span>: <span class="syntax-type">Int</span>, <span class="syntax-variable">p2</span>: <span class="syntax-type">Int</span>): <span class="syntax-type">Unit</span> <span class="syntax-operator">=</span> ...</span>
<span data-line="7"></span>
<span data-line="8">  <span class="syntax-keyword">for</span> <span class="syntax-variable">i</span> <span class="syntax-operator">&lt;-</span> 0 <span class="syntax-keyword">until</span> <span class="syntax-variable">xs</span><span class="syntax-operator">.</span><span class="syntax-variable">length</span> <span class="syntax-operator">-</span> 1 <span class="syntax-keyword">do</span> <span class="syntax-comment">// 2. Iterar i desde 0 hasta n-2</span></span>
<span data-line="9">    <span class="syntax-comment">// 3. Elegir p al azar entre i (inclusive) y n (exclusive)</span></span>
<span data-line="10">    <span class="syntax-keyword">val</span> <span class="syntax-variable">p</span> <span class="syntax-operator">=</span> <span class="syntax-variable">azar</span><span class="syntax-operator">.</span><span class="syntax-method">nextInt</span>(<span class="syntax-variable">xs</span><span class="syntax-operator">.</span><span class="syntax-variable">length</span> <span class="syntax-operator">-</span> <span class="syntax-variable">i</span>) <span class="syntax-operator">+</span> <span class="syntax-variable">i</span></span>
<span data-line="11">    <span class="syntax-comment">// Corrección: nextInt(N) da 0..N-1. Queremos i..n-1.</span></span>
<span data-line="12">    <span class="syntax-comment">// Rango tiene tamaño (n-1) - i + 1 = n - i.</span></span>
<span data-line="13">    <span class="syntax-comment">// azar.nextInt(n - i) da 0..(n - i - 1). Sumando i -> i..(n - 1).</span></span>
<span data-line="14"></span>
<span data-line="15">    <span class="syntax-function">swap</span>(<span class="syntax-variable">xs</span>, <span class="syntax-variable">i</span>, <span class="syntax-variable">p</span>)      <span class="syntax-comment">// 4. Intercambiar elemento en i con elemento en p</span></span>
<span data-line="16"></span>
<span data-line="17"><span class="syntax-comment">// 5. El array xs está ahora barajado</span></span>
        </code></pre>
    </div>

    <script>
        // --- CONTENIDO DEL SCRIPT (sin cambios respecto a tu versión anterior) ---
        (function () { // IIFE

            // --- Referencias a Elementos del DOM ---
            const arrayContainer = document.getElementById('array-container');
            const indexContainer = document.getElementById('index-container');
            const pointersContainer = document.getElementById('pointers-container');
            const pointerI = document.getElementById('pointer-i');
            // Renamed pointerJ to pointerP
            const pointerP = document.getElementById('pointer-p');
            // Removed pointerPosMin reference
            const codeListing = document.getElementById('code-listing');
            const codeLines = codeListing.querySelectorAll('span[data-line]');
            const startPauseBtn = document.getElementById('start-pause-btn');
            const stepBtn = document.getElementById('step-btn');
            const resetBtn = document.getElementById('reset-btn');
            const speedSlider = document.getElementById('speed-slider');
            const decreaseSizeBtn = document.getElementById('decrease-size-btn');
            const increaseSizeBtn = document.getElementById('increase-size-btn');
            const sizeDisplay = document.getElementById('size-display');
            const randomArrayBtn = document.getElementById('random-array-btn');
            const manualInputBtn = document.getElementById('manual-input-btn');
            const codeContainer = document.getElementById('code-container');
             


            // --- Variables de Estado ---
            let array = [];
            let originalArray = [];
            let bars = [];
            let timeouts = [];
            let animationSpeed = 500;
            let arraySize = 10;
            const minSize = 3;
            const maxSize = 30;
            let state = getDefaultState(); // Use new default state
            let lastHighlightInfo = null;
            const POINTER_ANIMATION_DURATION = 400;
            // Simple pseudo-random number generator for deterministic behavior if needed
            // let pseudoRandomSeed = Date.now(); // Can be fixed for reproducibility
            // function pseudoRandomInt(min, max) { // min inclusive, max exclusive
            //     pseudoRandomSeed = (pseudoRandomSeed * 9301 + 49297) % 233280;
            //     const rnd = pseudoRandomSeed / 233280;
            //     return min + Math.floor(rnd * (max - min));
            // }
            // Using Math.random() for simplicity now

            /**
             * Devuelve el objeto de estado inicial por defecto para el algoritmo Fisher-Yates.
             * @returns {object} Estado inicial.
             */
            function getDefaultState() {
                return {
                    i: -1,          // Índice del bucle externo
                    p: -1,          // Índice aleatorio elegido
                    // Removed j, posMin, prevJ
                    fixedUntil: -1, // Índice hasta el cual el array está "fijo" (shuffled part) - replaces sortedUntil
                    phase: 'idle',  // Fase actual ('idle', 'outer_loop', 'generate_p', 'delay_after_p', 'swapping', 'finished')
                    currentLine: -1,
                    isRunning: false,
                    isPaused: false,
                    isFinished: false,
                    isSwapping: false
                };
            }

            function init() {
                updateSizeDisplay();
                setupEventListeners();
                handleSpeedChange();
                setTimeout(generateAndReset, 50);
            }

            function setupEventListeners() {
                startPauseBtn.onclick = handleStartPause;
                stepBtn.onclick = () => requestStep(true);
                resetBtn.onclick = resetAlgorithm;
                speedSlider.oninput = handleSpeedChange;
                randomArrayBtn.onclick = generateAndReset; // Button now generates ordered array
                manualInputBtn.onclick = promptForArrayData;
                increaseSizeBtn.onclick = incrementSize;
                decreaseSizeBtn.onclick = decrementSize;
            }

            function calculateSpeed(sliderValue) {
                const min = 50;
                const max = 1500;
                const norm = parseInt(sliderValue, 10) / 100;
                return Math.round(max - norm * (max - min));
            }

            function updateSizeDisplay() {
                sizeDisplay.textContent = arraySize;
                increaseSizeBtn.disabled = arraySize >= maxSize;
                decreaseSizeBtn.disabled = arraySize <= minSize;
            }

            function incrementSize() {
                if (arraySize < maxSize) {
                    arraySize++;
                    updateSizeDisplay();
                    generateAndReset();
                }
            }

            function decrementSize() {
                if (arraySize > minSize) {
                    arraySize--;
                    updateSizeDisplay();
                    generateAndReset();
                }
            }

            /** Genera un nuevo array ORDENADO y resetea la visualización. */
            function generateAndReset() {
                const newA = [];
                // Generate consecutive numbers starting from a random small number
                const startValue = Math.floor(Math.random() * 21) + 10; // e.g., 10-30
                for (let k = 0; k < arraySize; k++) {
                    newA.push(startValue + k);
                }
                originalArray = newA.slice();
                console.log("Array generado (ordenado):", originalArray);
                resetAlgorithm();
            }

            function promptForArrayData() {
                const currentData = originalArray.join(',');
                const input = prompt(`Introduce los números separados por comas (${minSize}-${maxSize} elementos):`, currentData);
                if (input === null) return;
                const parsed = input.split(',')
                    .map(s => parseInt(s.trim(), 10))
                    .filter(n => !isNaN(n) && n >= 0); // Allow 0+

                if (parsed.length < minSize || parsed.length > maxSize) {
                    alert(`Número de elementos inválido. Debe estar entre ${minSize} y ${maxSize}.`);
                    return;
                }
                originalArray = parsed;
                arraySize = parsed.length;
                updateSizeDisplay();
                console.log("Array manual:", originalArray);
                resetAlgorithm();
            }

            function resetAlgorithm() {
                console.log("Reseteando algoritmo: Fisher-Yates Shuffle");
                state.isFinished = true; // Mark as finished first to stop any pending operations
                clearTimeouts();
                // If swapping, force reset state immediately
                if (state.isSwapping) {
                    state.isSwapping = false;
                 }
                // Use setTimeout to allow UI to potentially update/cancel before resetting visuals
                setTimeout(resetVisuals, 50);
            }


            function resetVisuals() {
                console.log("Reseteando visuales");
                state = getDefaultState(); // Use new default state
                lastHighlightInfo = null;
                clearTimeouts(); // Clear again just in case
                array = originalArray.slice();
                updateSizeDisplay();
                // Clear existing bars and styles explicitly
                if (bars && bars.length > 0) {
                    bars.forEach(b => {
                        if (b.parentNode) {
                            b.parentNode.removeChild(b);
                        }
                    });
                 }
                 bars = [];
                 arrayContainer.innerHTML = ''; // Clear container
                 if (indexContainer) indexContainer.innerHTML = ''; // Clear indices

                 // Hide pointers initially
                 if (pointerI) pointerI.style.visibility = 'hidden';
                 if (pointerP) pointerP.style.visibility = 'hidden';


                renderArray(); // Re-render the array
                highlightCodeLine(-1); // Clear code highlight
                updateControls(); // Update buttons state
            }


            function renderArray() {
                 // Check if container is cleared (sanity check)
                 if (arrayContainer.children.length > 0) {
                     console.warn("RenderArray called before container cleared?");
                     arrayContainer.innerHTML = '';
                     if(indexContainer) indexContainer.innerHTML = '';
                     bars = [];
                 }

                if (array.length === 0) {
                    updateAllPointers();
                    return;
                }

                const maxValue = Math.max(...array.map(val => Math.abs(val)), 1); // Use absolute for max, handle empty/zero

                for (let idx = 0; idx < array.length; idx++) {
                    const value = array[idx];
                    const bar = document.createElement('div');
                    bar.className = 'bar'; // Start with base class ONLY
                    const height = Math.max(5, (Math.abs(value) / maxValue) * 95); // Use absolute for height
                    bar.style.height = height + '%';
                    bar.setAttribute('data-index', idx);
                    bar.setAttribute('data-value', value);

                     // Set initial background color if needed (though default CSS handles it)
                     // bar.style.backgroundColor = 'steelblue'; // Default color

                    const barValueSpan = document.createElement('span');
                    barValueSpan.className = 'bar-value';
                    barValueSpan.textContent = value;
                    bar.appendChild(barValueSpan);

                    arrayContainer.appendChild(bar);
                    bars.push(bar);

                    if (indexContainer) {
                        const indexLabel = document.createElement('span');
                        indexLabel.className = 'index-label';
                        indexLabel.textContent = idx;
                        indexContainer.appendChild(indexLabel);
                    }
                }
                // Apply highlighting based on the current state AFTER creating all bars
                bars.forEach((bar, idx) => {
                     // Reset classes to ensure clean slate before applying current state
                     bar.className = 'bar';
                    applyHighlighting(bar, idx, lastHighlightInfo);
                });

                updateAllPointers();
            }


            /** Update pointer position (common function) */
             function updatePointer(pointerElement, index) {
                if (!pointerElement) return; // Skip if element doesn't exist

                if (index < 0 || index >= bars.length || !bars[index]) {
                    pointerElement.style.visibility = 'hidden';
                    return;
                }
                const bar = bars[index];
                if (!bar) { // Comprobación extra por si acaso
                     pointerElement.style.visibility = 'hidden';
                     return;
                 }
                 // Ensure bar is attached and has dimensions
                 if (bar.offsetParent === null) {
                     // Bar might not be fully rendered yet, maybe defer?
                     // For now, just hide the pointer if bar is not visible/layouted
                     pointerElement.style.visibility = 'hidden';
                     return;
                 }

                const center = bar.offsetLeft + bar.offsetWidth / 2;
                pointerElement.style.left = center + 'px';
                pointerElement.style.visibility = 'visible';
            }

            /** Update positions of i and p pointers */
            function updateAllPointers() {
                // Defer pointer updates slightly if bars might not be ready
                 setTimeout(() => {
                    updatePointer(pointerI, state.i);
                    updatePointer(pointerP, state.p);
                 }, 0); // Execute after current rendering cycle
            }


            /**
             * Applies highlighting based on Fisher-Yates state.
             * @param {HTMLElement} bar - The bar element.
             * @param {number} k - The index of the bar.
             * @param {object|null} highlightInfo - Additional info (type, indices).
             */
             function applyHighlighting(bar, k, highlightInfo) {
                if (!bar) return; // Safety check

                // Store original classes if needed, or just manage additions/removals
                let baseClass = 'bar';
                bar.className = baseClass; // Reset to base class first

                // Reset explicit outline color safely
                bar.style.outlineColor = ''; // Reset outline

                const infoType = highlightInfo ? highlightInfo.type : null;
                const current_i = state.i;
                const current_p = state.p;
                const current_fixedUntil = state.fixedUntil;
                const isFinished = state.isFinished;

                // 1. Bars that are "fixed" in their shuffled position (or final state)
                if (isFinished || k <= current_fixedUntil) {
                    bar.classList.add('bar-fixed');
                     // Handle flash overlay on fixed bars if needed
                    if (infoType === 'before_swap_visual' && (k === highlightInfo.idx1 || k === highlightInfo.idx2)) {
                        bar.classList.add('bar-red-border');
                        // Ensure flash state is managed
                        if (highlightInfo.flashOff) {
                            bar.classList.add('bar-flash-off');
                        } else {
                             bar.classList.remove('bar-flash-off');
                        }
                    }
                    return; // Primary state is fixed
                }

                 // 2. Special highlighting during pre-swap flash
                if (infoType === 'before_swap_visual' && (k === highlightInfo.idx1 || k === highlightInfo.idx2)) {
                    bar.classList.add('bar-red-border');
                     if (highlightInfo.flashOff) {
                        bar.classList.add('bar-flash-off');
                    } else {
                        bar.classList.remove('bar-flash-off');
                     }
                } else {
                    // 3. Normal highlighting during shuffling (not flashing)
                    if (k === current_i) {
                        bar.classList.add('bar-i'); // Current element 'i'
                    }
                     // Highlight 'p' candidate with orange border
                     // Apply only if p is valid and not the same as i (unless i also has its own style)
                    if (k === current_p && current_p !== -1 && (state.phase === 'generate_p' || state.phase === 'delay_after_p' || state.phase === 'swapping')) {
                         // Avoid double outline if i and p are the same during swap prep
                         if (!bar.classList.contains('bar-red-border')) {
                             bar.classList.add('bar-p-candidate');
                         }
                    }
                    // Ensure flash class is removed if not flashing
                    bar.classList.remove('bar-flash-off');
                }
            }


             function highlightState(highlightInfo) {
                lastHighlightInfo = highlightInfo;
                // Force redraw of all bars with new state
                 bars.forEach((bar, idx) => applyHighlighting(bar, idx, lastHighlightInfo));
                 // Pointers updated separately based on state.i, state.p
                 updateAllPointers();
            }

            function highlightCodeLine(lineNumber) {
                if (lineNumber === state.currentLine) return;

                codeLines.forEach(line => line.classList.remove('highlight-line'));

                if (lineNumber >= 0 && lineNumber < codeLines.length) {
                    const lineElement = codeLines[lineNumber]; // Access directly by index
                    if (lineElement) {
                         lineElement.classList.add('highlight-line');
                         // Optionally scroll into view
                         // lineElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                     }
                }
                state.currentLine = lineNumber;
            }

             /** Flash borders (reusable function - slight adaptation for applyHighlighting) */
             function flashBorders(index1, index2, repetitions, duration, callback) {
                let count = 0;
                const totalToggles = repetitions * 2;
                let flashOff = false; // State for toggling

                function toggle() {
                    // Check conditions to stop flashing
                    if (!state.isSwapping || count >= totalToggles || state.isFinished) {
                         // Cleanup: Ensure bars are reset to their correct non-flashing state
                         lastHighlightInfo = { type: 'after_flash_cleanup', fixed: state.fixedUntil, i: state.i, p: state.p };
                         if (bars[index1]) applyHighlighting(bars[index1], index1, lastHighlightInfo);
                         if (bars[index2]) applyHighlighting(bars[index2], index2, lastHighlightInfo);
                         // Ensure pointers are correct after potential state change during flash
                         updateAllPointers();
                        if (callback) callback();
                        return;
                    }

                    flashOff = !flashOff; // Toggle the flash state

                    // Update highlighting with flash state
                    const currentHighlightInfo = {
                        type: 'before_swap_visual',
                        idx1: index1,
                        idx2: index2,
                        flashOff: flashOff // Pass the current flash state
                    };
                    lastHighlightInfo = currentHighlightInfo; // Update global highlight info

                     if (bars[index1]) applyHighlighting(bars[index1], index1, currentHighlightInfo);
                     if (bars[index2]) applyHighlighting(bars[index2], index2, currentHighlightInfo);


                    count++;
                    timeouts.push(setTimeout(toggle, duration));
                }

                 // Initial highlight before starting the toggling flash
                 const initialHighlightInfo = { type: 'before_swap_visual', idx1: index1, idx2: index2, flashOff: false };
                 lastHighlightInfo = initialHighlightInfo;
                 if (bars[index1]) applyHighlighting(bars[index1], index1, initialHighlightInfo);
                 if (bars[index2]) applyHighlighting(bars[index2], index2, initialHighlightInfo);

                 // Start the flashing sequence after a tiny delay
                timeouts.push(setTimeout(toggle, 5));
            }


            /**
             * Executes a single step of the Fisher-Yates shuffle.
             * @returns {boolean} True if auto-execution should continue.
             */
            function fisherYatesStep() {
                // Prevent step execution if finished or reset is pending
                 if (state.isFinished || state.phase === 'resetting') return false;
                 // Prevent step if swapping (unless forced, handled elsewhere)
                 if (state.isSwapping) return false;


                let continueAuto = true;

                switch (state.phase) {
                    case 'idle':
                        highlightCodeLine(3); // val azar = ...
                        state.i = -1;
                        state.p = -1;
                        state.fixedUntil = -1; // Reset fixed marker
                        state.phase = 'outer_loop';
                        // Update visuals to clear pointers/highlights from previous run
                        highlightState({ type: 'init' });
                        break;

                    case 'outer_loop':
                        // Before incrementing i, mark the previous i as fixed if applicable
                        if (state.i >= 0) {
                           state.fixedUntil = state.i;
                        }

                        state.i++; // Advance 'i'

                         // Loop goes until n-2 (i.e., < n-1)
                        if (state.i >= array.length - 1) {
                            state.phase = 'finished';
                             // Update visuals one last time before finishing
                             highlightState({ type: 'pre_finish', fixed: state.fixedUntil });
                        } else {
                            highlightCodeLine(8); // for i <- ...
                            state.p = -1; // Reset p for this iteration
                            // Update visuals: show new 'i', mark fixed part, clear old 'p'
                            highlightState({ type: 'start_outer', i: state.i, fixed: state.fixedUntil });
                            state.phase = 'generate_p';
                        }
                        break;

                    case 'generate_p':
                        highlightCodeLine(10); // val p = ...
                        // Calculate random p: i <= p < n
                        const rangeSize = array.length - state.i;
                        // Ensure rangeSize is at least 1 if i is the last element (though loop should prevent this)
                        if (rangeSize <= 0) {
                             console.error("Error en rango de p:", state.i, array.length);
                             state.phase = 'finished'; // Avoid infinite loop/error
                             break;
                        }
                        const randomOffset = Math.floor(Math.random() * rangeSize);
                        state.p = state.i + randomOffset;
                        console.log(`i=${state.i}, n=${array.length}, Chose p=${state.p}`);

                        // Highlight the chosen 'p' bar and update pointers
                        highlightState({ type: 'p_selected', i: state.i, p: state.p, fixed: state.fixedUntil });

                        // Add a small delay to show 'p' before swapping
                        state.phase = 'delay_after_p';
                        continueAuto = false; // Pause auto execution briefly
                        timeouts.push(setTimeout(() => {
                            // Check state hasn't changed (e.g., reset, paused)
                            if (!state.isPaused && state.phase === 'delay_after_p' && !state.isFinished) {
                                requestStep(false); // Request next step automatically
                            }
                        }, POINTER_ANIMATION_DURATION * 0.7)); // Shorter delay than pointer move
                        break;

                     case 'delay_after_p':
                         // Ensure p is still valid before moving to swap
                         if (state.p < 0) {
                             console.warn("Estado inválido en delay_after_p, p no establecido.");
                             state.phase = 'outer_loop'; // Go back? Or finish?
                             break;
                         }
                        // Transition to swapping phase after the delay
                        state.phase = 'swapping';
                         // Execute swap phase immediately - need to call fisherYatesStep again
                         // but ensure continueAuto reflects the result of the swap phase call
                         continueAuto = fisherYatesStep();
                         return continueAuto; // Return result of swap phase execution


                    case 'swapping':
                        highlightCodeLine(15); // swap(xs, i, p)
                        const index1 = state.i;
                        const index2 = state.p;

                         // Validate indices before attempting swap
                        if (index1 < 0 || index1 >= array.length || index2 < 0 || index2 >= array.length) {
                            console.error(`Índices inválidos para intercambio: i=${index1}, p=${index2}`);
                            state.phase = 'finished'; // Treat as error state
                            continueAuto = false;
                            break;
                        }


                        // Only swap if p is different from i
                        if (index1 !== index2) {
                            state.isSwapping = true; // Set swapping flag
                            updateControls(); // Disable controls during swap

                            // Initial highlight before flash starts
                            highlightState({ type: 'before_swap_visual', idx1: index1, idx2: index2, fixed: state.fixedUntil, flashOff: false });

                            const flashDuration = Math.max(30, animationSpeed * 0.15);
                            const flashRepetitions = 2;

                            flashBorders(index1, index2, flashRepetitions, flashDuration, () => {
                                // This callback executes AFTER the flash completes

                                // Double-check state hasn't been reset during flash
                                if (!state.isSwapping || state.isFinished) {
                                     console.log("Intercambio cancelado o finalizado durante el flash.");
                                     if (state.isSwapping) state.isSwapping = false; // Ensure flag is cleared
                                     updateControls();
                                     // If finished, proceed to finish step
                                     if (state.phase === 'finished') fisherYatesStep();
                                     return;
                                 }

                                const pauseAfterFlash = Math.max(50, animationSpeed * 0.1);
                                timeouts.push(setTimeout(() => {
                                     // Check state again before starting animation
                                     if (!state.isSwapping || state.isFinished) {
                                         console.log("Intercambio cancelado o finalizado antes de la animación.");
                                          if (state.isSwapping) state.isSwapping = false;
                                          updateControls();
                                          if (state.phase === 'finished') fisherYatesStep();
                                         return;
                                     }

                                    // Perform the animated swap
                                    animateSwap_Fixed(index1, index2, () => {
                                        // This callback executes AFTER the swap animation completes

                                         // Check state one last time
                                         if (!state.isSwapping && !state.isFinished) {
                                             // This case should ideally not happen if isSwapping was true before animation
                                             console.warn("Estado de intercambio inconsistente después de animación.");
                                         }

                                         state.isSwapping = false; // Clear swapping flag *after* animation

                                         // Determine next state *after* swap is fully complete
                                         if (state.i >= array.length - 2) { // Check if i reached the end
                                             state.phase = 'finished';
                                         } else {
                                             state.phase = 'outer_loop'; // Go to next 'i'
                                         }

                                        // Update visuals post-swap (now includes marking 'i' as fixed)
                                        // We already updated fixedUntil before incrementing i in 'outer_loop'
                                        // So just need to reflect current i, p (which is now irrelevant), and fixed
                                        highlightState({ type: 'after_swap_completed', fixed: state.fixedUntil, i: state.i, p: -1 }); // Hide p after swap
                                        updateControls(); // Re-enable controls

                                         // If finished, execute finished step
                                         if (state.phase === 'finished') {
                                            fisherYatesStep();
                                        } else if (state.isRunning && !state.isPaused) {
                                            // If running auto, request next step
                                            requestStep(false);
                                        }
                                    }); // End animateSwap callback
                                }, pauseAfterFlash)); // End setTimeout after flash
                            }); // End flashBorders callback
                            continueAuto = false; // Pause auto-run during swap process
                        } else {
                            // No swap needed (i === p)
                            console.log("Intercambio no necesario: i === p en índice", index1);
                            // No visual change needed beyond normal state update
                            // The element at 'i' will be marked fixed in the next 'outer_loop' start

                             // Determine next state immediately
                            if (state.i >= array.length - 2) {
                                state.phase = 'finished';
                            } else {
                                state.phase = 'outer_loop'; // Go to next 'i'
                            }
                             // Update visuals to reflect 'i' and 'p' briefly, then move on
                             highlightState({ type: 'after_swap_no_change', fixed: state.fixedUntil, i: state.i, p: state.p });
                             // No pause needed here, can continue if auto-running
                             continueAuto = true;
                        }
                        break;

                    case 'finished':
                        highlightCodeLine(17); // Final comment line
                        state.fixedUntil = array.length - 1; // Mark all as fixed/shuffled
                        state.isFinished = true;
                        state.isRunning = false;
                        state.isPaused = false; // Ensure not paused
                        state.i = -1; // Hide i pointer
                        state.p = -1; // Hide p pointer at the end
                        highlightState({ type: 'final', fixed: state.fixedUntil });
                        console.log("Barajado completado.");
                        updateControls();
                        continueAuto = false;
                        break;

                    default:
                        console.error("Estado desconocido:", state.phase);
                        state.phase = 'finished'; // Go to finished state on error
                        continueAuto = false;
                        break;

                }

                // Update controls unless swapping (handled in callbacks) or resetting
                 if (!state.isSwapping && state.phase !== 'resetting') {
                    updateControls();
                }
                // Update pointers based on current state indices (i, p)
                updateAllPointers();

                return continueAuto; // Indicate if the next step should be scheduled automatically
            }

            /**
             * Animate swap (reusable function - slight modification for clarity).
             * Note: The actual swap in the `array` happens *during* the animation.
             */
            function animateSwap_Fixed(index1, index2, callback) {
                console.log("Animando intercambio:", index1, "y", index2);
                 // Check if bars exist before proceeding
                 if (!bars[index1] || !bars[index2]) {
                     console.error("Error: Barras no encontradas para intercambio animado:", index1, index2);
                     // If bars are missing, skip animation logic and call callback immediately
                     // Ensure swapping state is reset if this happens unexpectedly
                     if (state.isSwapping) {
                         state.isSwapping = false;
                         updateControls(); // Update controls if state changes
                     }
                     if (callback) callback();
                     return;
                 }

                const bar1 = bars[index1];
                const bar2 = bars[index2];
                const bar1ValueSpan = bar1.querySelector('.bar-value');
                const bar2ValueSpan = bar2.querySelector('.bar-value');

                 // Ensure elements are valid before getting properties
                 if (!bar1ValueSpan || !bar2ValueSpan) {
                     console.error("Error: Spans de valor no encontrados en barras:", index1, index2);
                     // Proceed without text update? Or abort? Let's abort safely.
                     if (state.isSwapping) {
                         state.isSwapping = false;
                         updateControls();
                     }
                     if (callback) callback();
                     return;
                 }


                const moveDuration = Math.max(animationSpeed * 0.7, 180); // Slightly faster move
                const transitionTransform = `transform ${moveDuration / 1000}s ease-in-out`;

                // Apply transition ONLY for transform temporarily
                bar1.style.transition = transitionTransform;
                bar2.style.transition = transitionTransform;

                const distance = bar2.offsetLeft - bar1.offsetLeft;

                 // Check if distance is valid
                 if (isNaN(distance)) {
                     console.error("Error calculando distancia para animación", bar1.offsetLeft, bar2.offsetLeft);
                      if (state.isSwapping) {
                         state.isSwapping = false;
                         updateControls();
                     }
                     if (callback) callback();
                     return;
                 }


                // Apply transform to move bars visually
                bar1.style.transform = `translateX(${distance}px)`;
                bar2.style.transform = `translateX(${-distance}px)`;

                // --- Perform logical swap in the array HERE ---
                const tempValue = array[index1];
                array[index1] = array[index2];
                array[index2] = tempValue;
                // --- Logical swap done ---

                // Update data attributes immediately (optional but good practice)
                bar1.setAttribute('data-value', array[index1]);
                bar2.setAttribute('data-value', array[index2]);


                // After the move animation finishes:
                timeouts.push(setTimeout(() => {
                    // Check if state changed (e.g., reset called during animation)
                    if (!state.isSwapping || state.isFinished) {
                        console.log("Animación de intercambio cancelada o finalizada prematuramente.");
                        // Attempt to restore styles if needed, though resetVisuals might handle it
                         bar1.style.transition = '';
                         bar1.style.transform = '';
                         bar2.style.transition = '';
                         bar2.style.transform = '';
                         // Do NOT call the original callback if cancelled
                        return;
                    }

                    // Get the NEW values and calculate NEW heights for the bars
                    // based on their NEW logical positions after the swap
                    const v1_new_logical = array[index1]; // Value now at index1
                    const v2_new_logical = array[index2]; // Value now at index2
                    const maxValue = Math.max(...(array.length > 0 ? array.map(Math.abs) : [1])) || 1; // Use absolute for max
                    const h1_new = Math.max(5, (Math.abs(v1_new_logical) / maxValue) * 95) + '%'; // Use absolute for height
                    const h2_new = Math.max(5, (Math.abs(v2_new_logical) / maxValue) * 95) + '%'; // Use absolute for height

                    // Remove the specific transform transition and reset transform
                    // This visually "snaps" the bars to their new physical locations
                    // while allowing height/text changes to happen (potentially with default CSS transition)
                    bar1.style.transition = 'none'; // Disable transform transition temporarily
                    bar2.style.transition = 'none';

                    // Update height and text content
                    bar1.style.height = h1_new;
                    bar1ValueSpan.textContent = v1_new_logical;
                    bar1.style.transform = ''; // Reset transform

                    bar2.style.height = h2_new;
                    bar2ValueSpan.textContent = v2_new_logical;
                    bar2.style.transform = ''; // Reset transform

                     // Force reflow/repaint might be needed in some browsers to ensure styles apply correctly
                     void bar1.offsetHeight;
                     void bar2.offsetHeight;

                    // Restore default transitions from CSS after a tiny delay
                    // Ensures subsequent non-transform transitions (like background-color) work
                    setTimeout(() => {
                         // Check state again before restoring transition, in case reset happened
                         if (!state.isFinished && bar1.style) {
                             bar1.style.transition = '';
                         }
                         if (!state.isFinished && bar2.style) {
                             bar2.style.transition = '';
                         }

                         // Execute the callback provided *after* styles are potentially restored
                        if (callback) {
                             callback(); // This will typically set isSwapping=false and continue execution
                        } else {
                             // Fallback: ensure swapping state is reset if no callback
                             // Should not happen with current logic, but good safeguard
                             if (state.isSwapping) {
                                 state.isSwapping = false;
                                 updateControls();
                             }
                        }

                    }, 10); // Short delay before restoring general transitions

                }, moveDuration)); // Wait for the transform animation to complete
            }


            // --- Control Logic (mostly reusable) ---

             function handleStartPause() {
                 // If finished, the button acts as "Reiniciar" (Reset)
                if (state.isFinished) {
                    resetAlgorithm();
                    // Optional: Automatically start after reset?
                    // setTimeout(() => {
                    //     state.isRunning = true;
                    //     state.isPaused = false;
                    //     state.isFinished = false;
                    //     state.phase = 'idle';
                    //     requestStep(false);
                    //     updateControls();
                    // }, 150); // Delay after reset visuals
                    return;
                }

                // If currently running -> Pause
                if (state.isRunning) {
                    state.isPaused = true;
                    state.isRunning = false;
                    clearTimeouts(); // Stop any scheduled next step
                    console.log("Algoritmo pausado.");
                }
                // If paused or idle -> Start/Resume
                else {
                    state.isPaused = false;
                    state.isRunning = true;
                    // If was idle, ensure state is ready to start
                     if (state.phase === 'idle') {
                         state.isFinished = false; // Ensure not marked finished
                     }
                     console.log("Algoritmo iniciado/continuado.");
                     // Request the next step (or the first step if idle)
                    requestStep(false);
                }
                updateControls();
            }


            function requestStep(forceManualStep) {
                clearTimeouts(); // Clear any pending automatic step timeout

                 // Ignore step requests if a reset is in progress
                 if (state.phase === 'resetting') {
                     console.log("Petición de paso ignorada: reseteando.");
                     return;
                 }

                // If forcing a manual step:
                if (forceManualStep) {
                    // 1. Pause automatic execution if it was running
                    if (state.isRunning) {
                        state.isPaused = true;
                        state.isRunning = false;
                        console.log("Pausa forzada por paso manual.");
                    }
                     // 2. If currently swapping, we cannot force a step over it. Wait.
                     if (state.isSwapping) {
                         console.log("Petición de paso manual ignorada: esperando fin de intercambio.");
                         updateControls(); // Update button states (step should be disabled)
                         return;
                     }
                     // 3. If finished, do nothing (Reset button should be used)
                     if (state.isFinished) {
                         console.log("Petición de paso manual ignorada: algoritmo finalizado.");
                         updateControls();
                         return;
                     }
                    // 4. Execute one step
                    console.log("Ejecutando paso manual.");
                    fisherYatesStep(); // Execute one step of the algorithm
                    updateControls(); // Update buttons after the step
                }
                // If triggering an automatic step (not forced manual):
                else {
                    // 1. Only proceed if actually running and not paused
                    if (state.isRunning && !state.isPaused) {
                         // 2. Do not step automatically if swapping is in progress
                         if (state.isSwapping) {
                             console.log("Paso automático diferido: esperando fin de intercambio.");
                             // Swap completion callback will eventually call requestStep(false) again
                             return;
                         }
                         // 3. If finished, stop.
                         if (state.isFinished) {
                             console.log("Ejecución automática detenida: algoritmo finalizado.");
                             updateControls();
                             return;
                         }

                        // 4. Execute one step and check if it signals to continue automatically
                        const continueAuto = fisherYatesStep();

                        // 5. If the step allows continuation and we are still running/not paused/not finished/not swapping
                        if (continueAuto && state.isRunning && !state.isPaused && !state.isFinished && !state.isSwapping) {
                            // Schedule the *next* automatic step
                            timeouts.push(setTimeout(() => requestStep(false), animationSpeed));
                        } else {
                            // Otherwise, update controls based on the new state (paused, finished, waiting for swap)
                            updateControls();
                        }
                    } else {
                         // If state is not running or is paused, update controls but don't proceed
                         updateControls();
                     }
                }
            }



            function clearTimeouts() {
                timeouts.forEach(clearTimeout);
                timeouts = [];
            }

            function handleSpeedChange() {
                 const newSpeed = calculateSpeed(speedSlider.value);
                 // Update speed only if it actually changes to avoid unnecessary restarts
                 if (newSpeed !== animationSpeed) {
                     animationSpeed = newSpeed;
                     console.log("Velocidad cambiada a:", animationSpeed);
                     // If running automatically, clear the old timeout and set a new one with the updated speed
                     if (state.isRunning && !state.isPaused && !state.isSwapping && !state.isFinished) {
                         clearTimeouts();
                         timeouts.push(setTimeout(() => requestStep(false), animationSpeed));
                     }
                 }
            }


            function updateControls() {
                const isRunningAuto = state.isRunning && !state.isPaused;
                // Considered busy if running automatically OR if an uninterruptible swap is happening
                const isBusy = isRunningAuto || state.isSwapping;
                 // Can reset unless currently in the middle of a swap animation/logic
                 const canReset = !state.isSwapping;
                 // Can modify array only when completely idle or fully finished
                 const canModifyArray = (state.phase === 'idle' && !state.isRunning && !state.isPaused && !state.isSwapping) || state.isFinished;


                // Start/Pause/Resume/Restart Button
                if (state.isFinished) {
                    startPauseBtn.textContent = 'Reiniciar';
                    startPauseBtn.disabled = false; // Always enabled when finished (acts as Reset)
                } else if (isRunningAuto) {
                    startPauseBtn.textContent = 'Pausar';
                    startPauseBtn.disabled = false; // Can always pause if running
                } else if (state.isPaused) {
                    startPauseBtn.textContent = 'Continuar';
                    startPauseBtn.disabled = state.isSwapping; // Cannot continue if paused *during* a swap (shouldn't happen ideally)
                } else { // Idle state
                    startPauseBtn.textContent = 'Iniciar';
                    startPauseBtn.disabled = false; // Can always start from idle
                }

                 // Step Button
                 // Disabled if finished, if running automatically, or if currently swapping
                 stepBtn.disabled = state.isFinished || isRunningAuto || state.isSwapping;

                 // Reset Button
                 // Disabled only if currently swapping (to avoid interrupting animation cleanly)
                 // Enabled in all other states (idle, running, paused, finished)
                 resetBtn.disabled = !canReset;


                 // Modification Controls (Size, Generate, Manual Input)
                 randomArrayBtn.disabled = !canModifyArray || isBusy; // Also check isBusy for safety
                 manualInputBtn.disabled = !canModifyArray || isBusy;
                 increaseSizeBtn.disabled = arraySize >= maxSize || !canModifyArray || isBusy;
                 decreaseSizeBtn.disabled = arraySize <= minSize || !canModifyArray || isBusy;


                // Speed Slider
                // Disabled if running automatically or swapping
                speedSlider.disabled = isBusy;
            }


            // --- Start ---
            // Ensure DOM is fully loaded before initializing
             document.addEventListener('DOMContentLoaded', init);


        })(); // End IIFE
    </script>

</body>

</html>