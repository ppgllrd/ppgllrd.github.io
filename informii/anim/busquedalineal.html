<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualización Búsqueda Lineal v5</title>
    <style>
        /* --- ESTILOS CSS --- */
        /* Estilos generales para el cuerpo y títulos */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f4;
        }

        h1,
        h2,
        #target-value-display {
            color: #333;
            text-align: center;
        }

        /* Estilo para mostrar el valor buscado y el resultado */
        #target-value-display {
            margin-top: -10px;
            margin-bottom: 10px;
            font-size: 16px;
            min-height: 1.2em;
        }

        #target-value-display span {
            color: #e67e22;
            font-weight: bold;
        }

        #target-value-display .result-found {
            color: darkgreen;
            font-weight: bold;
        }

        #target-value-display .result-not-found {
            color: darkred;
            font-weight: bold;
        }

        #target-value-display .index-value {
            color: #333;
            font-weight: bold;
        }

        /* Contenedor principal de la visualización */
        #visualization-container {
            position: relative;
            /* Margen inferior aumentado para dejar espacio a índices y punteros */
            margin-bottom: 90px;
            height: 280px;
            width: 90%;
            max-width: 800px;
            border: 1px solid #ccc;
            background-color: #fff;
            padding: 10px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }

        /* Contenedor de las barras del array */
        #array-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 95%;
            width: 100%;
            position: relative;
            gap: 2px;
            bottom: 5px;
        }

        /* Estilo base para cada barra representando un elemento del array */
        .bar {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            background-color: steelblue;
            /* Color por defecto: no comprobado */
            flex-grow: 1;
            flex-basis: 0;
            max-width: 50px;
            text-align: center;
            color: white;
            font-size: 12px;
            position: relative;
            /* Necesario para posicionar el índice absoluto */
            transition: background-color 0.4s ease, height 0.3s ease;
            box-sizing: border-box;
            border: 1px solid #eee;
            outline: 2px solid transparent;
            outline-offset: -2px;
            padding-bottom: 5px;
            margin-bottom: 5px;
            bottom: 10px;
            /* Espacio debajo para el índice */
        }

        /* Estilo para el valor numérico mostrado DENTRO de la barra */
        .bar-value {
            color: white;
            font-weight: bold;
            font-size: 10px;
            z-index: 1;
            text-shadow: 1px 1px 2px black;
            position: absolute;
            /* Posición relativa a la barra padre */
            bottom: 5px;
            /* Colocar encima del espacio para el índice */
            left: 0;
            width: 100%;
            text-align: center;
        }

        /* Estilo para el índice mostrado DEBAJO de la barra */
        .bar-index {
            position: absolute;
            bottom: -20px;
            /* Posición debajo de la barra */
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #666;
            font-weight: bold;
            /* Color gris oscuro para el índice */
            z-index: 1;
        }

        /* --- Clases de Estado Específicas de la Búsqueda Lineal --- */
        /* Estilo para barras ya comprobadas y no encontradas (gris claro) */
        .bar.bar-checked-not-found {
            background-color: #d3d3d3 !important;
        }

        .bar.bar-checked-not-found .bar-value {
            color: #777;
            text-shadow: none;
        }

        .bar.bar-checked-not-found .bar-index {
            color: #888;
        }

        /* Índice atenuado */

        /* Estilo para la barra actual ('i') durante la comparación (verde) */
        .bar.bar-comparing {
            background-color: mediumseagreen !important;
            z-index: 5;
        }

        .bar.bar-comparing .bar-value {
            color: white;
            text-shadow: 1px 1px 1px black;
        }

        .bar.bar-comparing .bar-index {
            color: mediumseagreen;
        }

        /* Índice más claro sobre verde */


        /* Estilo para la barra cuando se encuentra el elemento (dorado) */
        .bar.bar-found {
            background-color: gold !important;
            z-index: 10;
        }

        .bar.bar-found .bar-value {
            color: black;
            text-shadow: none;
        }

        .bar.bar-found .bar-index {
            color: #333;
        }

        /* Índice oscuro sobre dorado */

        /* --- Estilos para los Punteros --- */
        /* Contenedor para el puntero 'i', posicionado debajo de barras e índices */
        #pointers-container {
            position: absolute;
            bottom: -70px;
            left: 0;
            width: 100%;
            height: 50px;
            pointer-events: none;
            z-index: 20;
        }

        /* Estilo base de un puntero */
        .pointer {
            position: absolute;
            transform: translateX(-50%);
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            padding: 1px 3px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            transition: left 0.4s ease-in-out;
            visibility: hidden;
            min-width: 15px;
            text-align: center;
        }

        /* Pseudo-elemento para crear el triángulo del puntero */
        .pointer::before {
            content: '';
            position: absolute;
            left: 50%;
            top: -7px;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
        }

        /* Puntero 'i': Verde (índice de escaneo/comparación) */
        #pointerI {
            background-color: rgba(0, 128, 0, 0.8);
            bottom: 20px;
            /* Posicionado debajo de los índices */
        }

        #pointerI::before {
            border-bottom: 7px solid rgba(0, 128, 0, 0.8);
        }


        /* --- Estilos para Controles y Código Fuente --- */
        #controls-container {
            margin: 20px 0;
            padding: 15px;
            background-color: #eee;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            width: 90%;
            max-width: 800px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #controls-container button {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f8f8f8;
            color: #333;
            font-size: 14px;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        #controls-container button:hover:not(:disabled) {
            background-color: #e0e0e0;
            border-color: #aaa;
        }

        #controls-container button:disabled {
            background-color: #cccccc;
            color: #888;
            cursor: not-allowed;
            border-color: #bbb;
        }

        #start-pause-btn {
            background-color: #60a5fa;
            color: white;
            border-color: #3b82f6;
        }

        #step-btn {
            background-color: #fbbf24;
            color: white;
            border-color: #f59e0b;
        }

        #reset-btn {
            background-color: #f87171;
            color: white;
            border-color: #ef4444;
        }

        .size-control label {
            margin-right: 5px;
        }

        .size-control span {
            min-width: 25px;
            text-align: center;
            padding: 5px 8px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 3px;
            display: inline-block;
        }

        .size-control button {
            font-weight: bold;
            padding: 4px 8px;
            font-weight: bold;
            min-width: 25px;
        }

        .speed-control label {
            margin-right: 5px;
        }

        .speed-control input[type="range"] {
            cursor: pointer;
            width: 100px;
        }

        .target-control label {
            margin-right: 5px;
        }

        .target-control input[type="number"] {
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 60px;
            font-size: 14px;
            text-align: center;
        }

        .target-control input[type="number"]:disabled {
            background-color: #eee;
            cursor: not-allowed;
        }

        /* --- CONTENEDOR DE CÓDIGO --- */
        #code-container {
            width: 90%;
            max-width: 800px;
            margin-top: 20px;
            background-color: #2d2d2d;
            /* Fondo oscuro */
            color: #ccc;
            /* Texto claro */
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            line-height: 1;
            overflow-x: auto;
            /* Scroll horizontal si el código es largo */
        }

        #code-container h2 {
            color: #eee;
            margin: 0 0 10px 0;
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        /* Estilo para cada línea de código */
        #code-listing span[data-line] {
            padding: 2px 0;
            display: inline-block;
            width: 95%;
            border-radius: 3px;
            transition: background-color 0.3s ease;
            line-height: normal;
            white-space: pre;
            /* Mantiene espacios y saltos de línea */
        }

        #code-listing span[data-line].highlight-line {
            background-color: rgba(255, 255, 100, 0.25);
        }

        /* Estilos para el resaltado de sintaxis del código Scala */
        #code-listing .syntax-keyword {
            color: #569cd6;
        }

        #code-listing .syntax-type {
            color: #4ec9b0;
        }

        #code-listing .syntax-function {
            color: #dcdcaa;
        }

        #code-listing .syntax-operator {
            color: #b5cea8;
        }

        #code-listing .syntax-comment {
            color: #6a9955;
            font-style: italic;
        }

        #code-listing .syntax-variable {
            color: #9cdcfe;
        }

        #code-listing .syntax-generic {
            color: #4ec9b0;
        }

        #code-listing .syntax-package {
            color: #ce9178;
        }

        #code-listing .syntax-number {
            color: #b5cea8;
        }

        #code-listing .syntax-literal {
            color: #ce9178;
        }

        #code-listing .syntax-parameter {
            color: #c586c0;
        }
    </style>
</head>

<body>
    <h1>Visualización Búsqueda Lineal</h1>
    <div id="target-value-display">Buscando: <span id="target-value">?</span></div>

    <div id="visualization-container">
        <div id="array-container"></div>
        <div id="pointers-container">
            <div class="pointer" id="pointerI">i</div>
        </div>
    </div>

    <div id="controls-container">
        <div class="control-group">
            <button id="start-pause-btn" disabled>Iniciar</button>
            <button id="step-btn" disabled>Paso Siguiente</button>
            <button id="reset-btn">Resetear</button>
        </div>
        <div class="control-group speed-control">
            <label for="speed-slider">Velocidad:</label>
            <input type="range" id="speed-slider" min="0" max="100" value="50">
        </div>
        <div class="control-group size-control">
            <label>Tamaño:</label>
            <button id="decrease-size-btn">-</button>
            <span id="size-display">10</span>
            <button id="increase-size-btn">+</button>
        </div>
        <div class="control-group">
            <button id="random-array-btn">Generar</button>
            <button id="manual-input-btn">Introducir Datos</button>
        </div>
        <div class="control-group target-control">
            <label for="target-input">Objetivo:</label>
            <input type="number" id="target-input">
        </div>
    </div>

    <div id="code-container">
        <h2>Algoritmo (Scala):</h2>
        <pre><code id="code-listing">
    <span data-line="0"><span class="syntax-keyword">def</span> <span class="syntax-function">búsquedaLineal</span>[<span class="syntax-generic">A</span>](<span class="syntax-variable">x</span>: <span class="syntax-generic">A</span>, <span class="syntax-variable">xs</span>: <span class="syntax-type">Array</span>[<span class="syntax-generic">A</span>]): <span class="syntax-type">Option</span>[<span class="syntax-type">Int</span>] <span class="syntax-operator">=</span></span>
    <span data-line="1">  <span class="syntax-keyword">var</span> <span class="syntax-variable">índice</span>: <span class="syntax-type">Option</span>[<span class="syntax-type">Int</span>] <span class="syntax-operator">=</span> <span class="syntax-literal">None</span></span>
    <span data-line="2">  <span class="syntax-keyword">var</span> <span class="syntax-variable">i</span> <span class="syntax-operator">=</span> <span class="syntax-number">0</span></span>
    <span data-line="3">  <span class="syntax-keyword">while</span> <span class="syntax-variable">índice</span><span class="syntax-operator">.</span><span class="syntax-variable">isEmpty</span> <span class="syntax-operator">&amp;&amp;</span> <span class="syntax-variable">i</span> <span class="syntax-operator">&lt;</span> <span class="syntax-variable">xs</span><span class="syntax-operator">.</span><span class="syntax-variable">length</span> <span class="syntax-keyword">do</span></span>
    <span data-line="4">    <span class="syntax-keyword">if</span> <span class="syntax-variable">xs</span>(<span class="syntax-variable">i</span>) <span class="syntax-operator">==</span> <span class="syntax-variable">x</span> <span class="syntax-keyword">then</span></span>
    <span data-line="5">      <span class="syntax-variable">índice</span> <span class="syntax-operator">=</span> <span class="syntax-function">Some</span>(<span class="syntax-variable">i</span>) <span class="syntax-comment">  // encontrado!</span></span>
    <span data-line="6">    <span class="syntax-keyword">else</span></span>
    <span data-line="7">      <span class="syntax-variable">i</span> <span class="syntax-operator">+=</span> <span class="syntax-number">1</span> <span class="syntax-comment">            // seguir buscando</span></span>
    <span data-line="8">  <span class="syntax-variable">índice</span></span>
        </code></pre>
    </div>

    <script>
        (function () { // Envoltura IIFE para encapsular el código y evitar conflictos globales

            // --- Selección de Elementos del DOM ---
            // Guarda referencias a los elementos HTML necesarios para interactuar con la UI.
            const arrayContainer = document.getElementById('array-container');
            const pointersContainer = document.getElementById('pointers-container');
            const pointerI = document.getElementById('pointerI');
            const codeListing = document.getElementById('code-listing');
            const codeLines = codeListing.querySelectorAll('span[data-line]');
            const startPauseBtn = document.getElementById('start-pause-btn');
            const stepBtn = document.getElementById('step-btn');
            const resetBtn = document.getElementById('reset-btn');
            const speedSlider = document.getElementById('speed-slider');
            const decreaseSizeBtn = document.getElementById('decrease-size-btn');
            const increaseSizeBtn = document.getElementById('increase-size-btn');
            const sizeDisplay = document.getElementById('size-display');
            const randomArrayBtn = document.getElementById('random-array-btn');
            const manualInputBtn = document.getElementById('manual-input-btn');
            const targetInput = document.getElementById('target-input');
            const targetValueDisplay = document.getElementById('target-value-display');
            const targetValueSpan = document.getElementById('target-value');

            // --- Variables de Estado Globales ---
            // Almacenan el estado actual del algoritmo, la visualización y los datos.
            let array = [];                 // El array de datos actual (puede no estar ordenado)
            let originalArray = [];         // Copia del array generado para poder resetear
            let bars = [];                  // Referencias a los elementos DOM de las barras
            let timeouts = [];              // Almacena IDs de timeouts para pausas y cancelaciones
            let animationSpeed = 500;       // Velocidad base de la animación (ms), ajustable por slider
            let arraySize = 10;             // Tamaño actual del array
            const minSize = 1;              // Tamaño mínimo permitido para el array
            const maxSize = 40;             // Tamaño máximo permitido para el array
            let state = getDefaultState();  // Objeto que encapsula el estado lógico del algoritmo
            let lastHighlightInfo = null;   // Información para aplicar estilos visuales a las barras
            let targetValue = null;         // El valor que se busca en el array
            const POINTER_ANIMATION_DURATION = 400; // Duración (ms) de la transición CSS del puntero

            /**
             * Devuelve un objeto representando el estado inicial o reseteado del algoritmo de búsqueda lineal.
             * @returns {object} Estado inicial.
             */
            function getDefaultState() {
                return {
                    i: -1,                      // Índice actual de la búsqueda, empieza antes del primer elemento
                    foundIndex: null,           // Almacena el índice si se encuentra, null si no
                    currentValueAtIndexI: null, // Valor actual en la posición 'i' (xs[i])
                    phase: 'idle',              // Fase actual de la máquina de estados del algoritmo
                    currentLine: -1,            // Línea de código resaltada (-1 = ninguna)
                    isRunning: false,           // ¿Está la animación automática en ejecución?
                    isPaused: false,            // ¿Está la animación automática pausada?
                    isFinished: false,          // ¿Ha terminado el algoritmo (encontrado o no)?
                    isComparing: false          // ¿Está en la fase visual de comparar el elemento en 'i'?
                };
            }

            // --- Inicialización y Manejadores de Eventos ---

            /**
             * Función principal de inicialización. Configura la UI y genera el primer array.
             * Se ejecuta cuando el contenido del DOM está completamente cargado.
             */
            function init() {
                updateSizeDisplay();
                setupEventListeners();
                handleSpeedChange();
                setTimeout(generateAndReset, 50); // Genera array y objetivo iniciales poco después de cargar
            }

            /**
             * Asigna las funciones manejadoras a los eventos de los controles (botones, slider, input).
             */
            function setupEventListeners() {
                startPauseBtn.onclick = handleStartPause;
                stepBtn.onclick = () => requestStep(true); // El 'true' indica paso manual
                resetBtn.onclick = resetAlgorithm;
                speedSlider.oninput = handleSpeedChange;
                randomArrayBtn.onclick = generateAndReset;
                manualInputBtn.onclick = promptForArrayData;
                increaseSizeBtn.onclick = incrementSize;
                decreaseSizeBtn.onclick = decrementSize;
                targetInput.oninput = handleTargetInput; // Se activa al cambiar el valor objetivo
            }

            /**
             * Calcula la duración de la animación (ms) a partir del valor del slider.
             * Mapea el rango del slider [0, 100] a un rango de velocidades [max, min].
             * @param {string|number} sliderValue - Valor actual del slider (0-100).
             * @returns {number} Duración de la animación en milisegundos.
             */
            function calculateSpeed(sliderValue) { const min = 50, max = 1500, norm = parseInt(sliderValue, 10) / 100; return Math.round(max - norm * (max - min)); }

            /**
             * Actualiza el texto que muestra el tamaño actual del array y
             * habilita/deshabilita los botones de incremento/decremento según los límites.
             */
            function updateSizeDisplay() { sizeDisplay.textContent = arraySize; increaseSizeBtn.disabled = arraySize >= maxSize; decreaseSizeBtn.disabled = arraySize <= minSize; }

            /**
             * Incrementa el tamaño del array (si no ha alcanzado el máximo) y genera uno nuevo.
             */
            function incrementSize() { if (arraySize < maxSize) { arraySize++; updateSizeDisplay(); generateAndReset(); } }

            /**
             * Decrementa el tamaño del array (si no ha alcanzado el mínimo) y genera uno nuevo.
             */
            function decrementSize() { if (arraySize > minSize) { arraySize--; updateSizeDisplay(); generateAndReset(); } }

            // --- Generación de Array y Establecimiento del Objetivo ---

            /**
             * Genera un nuevo array con valores aleatorios (no necesariamente ordenado),
             * resetea la visualización y establece un nuevo objetivo aleatorio.
             */
            function generateAndReset() {
                const newA = [];
                for (let k = 0; k < arraySize; k++) { newA.push(Math.floor(Math.random() * 90) + 10); }
                originalArray = newA.slice();
                resetAlgorithm(true); // Reset completo, usando el nuevo array
                setRandomTargetValue(); // Elige un nuevo objetivo
            }

            /**
             * Muestra un prompt para que el usuario introduzca los datos del array manualmente.
             * Valida la entrada, actualiza el array y resetea la visualización.
             */
            function promptForArrayData() {
                const cur = originalArray.join(',');
                const inp = prompt(`Introducir datos (${minSize}-${maxSize}), separados por comas:`, cur);
                if (inp === null) return; // Si el usuario cancela
                // Parsea la entrada, filtra valores no numéricos y valida el tamaño
                const p = inp.split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n) && n >= 0);
                if (p.length < minSize || p.length > maxSize) { alert(`Tamaño inválido. Debe estar entre ${minSize} y ${maxSize}.`); return; }
                originalArray = p; arraySize = p.length; updateSizeDisplay();
                resetAlgorithm(true); // Reset completo con los datos manuales
                setRandomTargetValue(); // Elige un nuevo objetivo
            }

            /**
             * Se ejecuta cuando el valor del campo de entrada del objetivo cambia.
             * Actualiza la variable `targetValue` y el mensaje mostrado.
             * Si el algoritmo había terminado, lo resetea para permitir una nueva búsqueda.
             */
            function handleTargetInput() {
                const value = targetInput.value;
                // Actualiza el mensaje superior (mientras no haya terminado)
                if (!state.isFinished) {
                    setTargetDisplayMessage(`Buscando: <span id="target-value">${value === '' || isNaN(parseInt(value)) ? '?' : value}</span>`);
                }
                // Parsea y actualiza el valor objetivo interno
                if (value === '') { targetValue = null; }
                else {
                    const parsedTarget = parseInt(value, 10);
                    if (!isNaN(parsedTarget)) {
                        targetValue = parsedTarget;
                        // Si ya había terminado, resetea para buscar de nuevo el nuevo objetivo
                        if (state.isFinished) { resetAlgorithm(false); } // Reset parcial, sin regenerar array
                    } else { targetValue = null; } // Valor inválido
                }
                updateControls(); // Habilita/deshabilita botones según si hay objetivo válido
            }

            /**
             * Establece el contenido HTML del área que muestra el valor buscado y el resultado.
             * @param {string} htmlMessage - El mensaje HTML a mostrar.
             */
            function setTargetDisplayMessage(htmlMessage) {
                targetValueDisplay.innerHTML = htmlMessage;
            }

            /**
             * Elige un valor objetivo aleatorio. Con ~70% de probabilidad elige un valor
             * existente en el array, y con ~30% elige uno probablemente no existente.
             */
            function setRandomTargetValue() {
                let randomTarget;
                if (originalArray.length === 0) { randomTarget = ''; }
                else {
                    const shouldFind = Math.random() > 0.3; // 70% prob. de elegir uno existente
                    if (shouldFind) {
                        // Elige un valor aleatorio del array
                        const randomIndex = Math.floor(Math.random() * originalArray.length);
                        randomTarget = originalArray[randomIndex];
                    } else {
                        // Genera un valor que probablemente no esté en el array
                        const minVal = Math.min(...originalArray);
                        const maxVal = Math.max(...originalArray);
                        const coinFlip = Math.random();
                        // Elige aleatoriamente entre un valor fuera de rango o uno dentro del rango 0-110
                        if (coinFlip < 0.5) {
                            randomTarget = Math.random() > 0.5 ? minVal - (Math.floor(Math.random() * 5) + 1) : maxVal + (Math.floor(Math.random() * 5) + 1);
                        } else {
                            randomTarget = Math.floor(Math.random() * 110); // Valor aleatorio 0-109
                        }
                        randomTarget = Math.max(0, randomTarget); // Asegura que no sea negativo
                    }
                }
                targetInput.value = randomTarget;
                // Dispara manualmente el evento 'input' para que handleTargetInput se ejecute
                targetInput.dispatchEvent(new Event('input', { bubbles: true }));
            }

            // --- Lógica de Reseteo ---

            /**
             * Inicia el proceso de reseteo del algoritmo y la visualización.
             * Marca el estado como finalizado y programa el reseteo visual.
             * @param {boolean} [fullReset=true] - Indica si se debe usar el `originalArray` (true) o el `array` actual (false).
             */
            function resetAlgorithm(fullReset = true) {
                state.isFinished = true; // Marca como terminado para detener cualquier animación
                clearTimeouts(); // Cancela timeouts pendientes
                setTimeout(() => resetVisuals(fullReset), 50); // Ejecuta el reseteo visual tras un breve instante
            }

            /**
             * Restaura el estado lógico y visual a sus valores iniciales.
             * @param {boolean} fullReset - Si es true, copia el array original. Si es false, usa el array actual (útil al cambiar solo el objetivo).
             */
            function resetVisuals(fullReset = true) {
                state = getDefaultState(); // Restaura el objeto de estado
                lastHighlightInfo = null; // Limpia información de resaltado
                clearTimeouts();
                // Selecciona qué array usar
                if (fullReset) {
                    array = originalArray.slice();
                } else {
                    // Usa el array actual si existe, si no, el original (caso inicial)
                    array = array.length > 0 ? array.slice() : originalArray.slice();
                }
                handleTargetInput(); // Actualiza el mensaje del objetivo
                updateSizeDisplay();
                // Limpia visualmente las barras antiguas
                if (bars && bars.length > 0) { bars.forEach(b => { b.className = 'bar'; b.style = ''; }); }
                renderArray(); // Renderiza el estado inicial del array
                pointerI.style.visibility = 'hidden'; // Asegura que el puntero esté oculto
                highlightCodeLine(-2); // Limpia resaltado de código (-2 es un valor seguro)
                updateControls(); // Actualiza el estado de los botones
            }

            // --- Renderizado y Actualizaciones Visuales ---

            /**
             * (Re)dibuja las barras del array en el contenedor HTML.
             * Crea los elementos DOM (barra, valor, índice) si no existen.
             * Actualiza altura, valor e índice de cada barra.
             * Aplica estilos (colores) según el estado actual del algoritmo.
             */
            function renderArray() {
                arrayContainer.innerHTML = ''; // Limpia el contenedor
                bars = []; // Resetea el array de referencias a barras
                if (array.length === 0) { return; } // No hacer nada si el array está vacío
                const maxV = Math.max(...array) || 1; // Obtiene el valor máximo para la altura relativa

                for (let idx = 0; idx < array.length; idx++) {
                    const val = array[idx];
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    const h = Math.max(5, (val / maxV) * 95); // Altura mínima del 5%
                    bar.style.height = h + '%';

                    // Crea el span para el valor
                    const bv = document.createElement('span');
                    bv.className = 'bar-value';
                    bv.textContent = val;
                    bar.appendChild(bv);

                    // Crea el span para el índice
                    const bi = document.createElement('span');
                    bi.className = 'bar-index';
                    bi.textContent = idx; // Muestra el índice numérico
                    bar.appendChild(bi);

                    // Guarda atributos para posible referencia futura (aunque no se usan aquí)
                    bar.setAttribute('data-index', idx);
                    bar.setAttribute('data-value', val);
                    bars.push(bar); // Guarda la referencia al elemento DOM
                    arrayContainer.appendChild(bar);
                }
                // Aplica los estilos a las barras recién creadas o actualizadas
                bars.forEach((bar, idx) => { applyHighlighting(bar, idx, lastHighlightInfo); });
                updateAllPointers(); // Actualiza la posición del puntero 'i'
            }


            // --- Lógica de Posicionamiento de Punteros ---

            /**
             * Actualiza la posición horizontal del puntero 'i' para que apunte
             * al centro de la barra correspondiente al índice dado.
             * Maneja el caso especial cuando 'i' se sale del final del array (no encontrado).
             * @param {HTMLElement} pointerElement - El elemento DOM del puntero ('pointerI').
             * @param {number} index - El índice actual ('state.i').
             * @returns {boolean} - True si el puntero es visible, false si está oculto.
             */
            function updatePointer(pointerElement, index) {
                const barCount = bars.length;
                const POINTER_OFFSET = 5; // Desplazamiento para la posición final "fuera de límites"

                // Caso normal: El índice está dentro de los límites del array
                if (index >= 0 && index < barCount && bars[index]) {
                    const bar = bars[index];
                    const center = bar.offsetLeft + bar.offsetWidth / 2; // Centro de la barra
                    pointerElement.style.left = center + 'px';
                    pointerElement.style.visibility = 'visible';
                    return true;
                }

                // Caso final "No encontrado": Muestra el puntero justo después de la última barra
                if (index >= barCount && barCount > 0) {
                    const lastBar = bars[barCount - 1];
                    // Calcula una posición a la derecha de la última barra
                    const position = lastBar.offsetLeft + 1.3 * lastBar.offsetWidth + POINTER_OFFSET;
                    pointerElement.style.left = position + 'px';
                    pointerElement.style.visibility = 'visible';
                    return true;
                }

                // Por defecto (incluye el estado inicial i = -1), oculta el puntero
                pointerElement.style.visibility = 'hidden';
                return false;
            }


            /**
             * Llama a `updatePointer` para el único puntero utilizado ('i').
             */
            function updateAllPointers() {
                updatePointer(pointerI, state.i);
            }

            // --- Aplicación de Estilos a las Barras ---

            /**
             * Aplica las clases CSS adecuadas a una barra específica según el estado actual
             * del algoritmo (comparando, encontrado, comprobado-no-encontrado).
             * @param {HTMLElement} bar - El elemento DOM de la barra a estilizar.
             * @param {number} k - El índice de esta barra en el array.
             * @param {object | null} highlightInfo - Información adicional sobre el estado (no usado aquí).
             */
            function applyHighlighting(bar, k, highlightInfo) {
                // Limpia clases de estado previas
                bar.classList.remove('bar-checked-not-found', 'bar-comparing', 'bar-found');
                bar.style.outlineColor = ''; // Limpia posible borde de comparación

                // Obtiene el estado relevante
                const current_i = state.i;
                const foundIdx = state.foundIndex;
                const isComparing = state.isComparing;
                const isFinished = state.isFinished;

                // 1. Elemento Encontrado (Dorado): Tiene la máxima prioridad
                if (foundIdx === k) {
                    bar.classList.add('bar-found');
                    return; // No aplicar otros estilos si ya se encontró
                }

                // 2. Elemento Siendo Comparado (Verde):
                // Se aplica si es el índice actual 'i', estamos en fase de comparación, y aún no se ha encontrado.
                if (k === current_i && isComparing && foundIdx === null) {
                    bar.classList.add('bar-comparing');
                    return; // No marcar como 'comprobado' mientras se compara
                }

                // 3. Elemento Ya Comprobado y No Encontrado (Gris):
                // Se aplica si el índice 'k' es menor que el índice actual 'i' (y la búsqueda ha empezado)
                // O si la búsqueda ha terminado sin encontrar el elemento.
                const isChecked = current_i >= 0 && k < current_i;
                const isNotFoundFinished = isFinished && foundIdx === null;

                // Asegura no aplicar gris si el elemento fue el encontrado
                if ((isChecked || isNotFoundFinished)) {
                    bar.classList.add('bar-checked-not-found');
                }

                // Si ninguna condición se cumple, la barra mantiene su color azul por defecto.
            }

            /**
             * Guarda la información de resaltado (si la hay) y fuerza un re-renderizado
             * completo del array para aplicar los estilos visuales.
             * @param {object | null} highlightInfo - Información sobre el estado actual para `applyHighlighting`.
             */
            function highlightState(highlightInfo) {
                lastHighlightInfo = highlightInfo;
                renderArray(); // Redibuja barras y actualiza punteros
            }

            /**
             * Resalta una línea específica en el bloque de código fuente.
             * @param {number} lineNumber - El número de línea (data-line) a resaltar. -1 o -2 para limpiar.
             */
            function highlightCodeLine(lineNumber) {
                // Evita trabajo innecesario si la línea ya está resaltada
                if (lineNumber === state.currentLine) return;
                // Limpia resaltado anterior
                codeLines.forEach(line => line.classList.remove('highlight-line'));
                // Aplica nuevo resaltado si es un número de línea válido
                if (lineNumber >= 0) {
                    const el = codeListing.querySelector(`span[data-line="${lineNumber}"]`);
                    if (el) el.classList.add('highlight-line');
                }
                state.currentLine = lineNumber; // Guarda la línea actual
            }

            // --- Lógica del Algoritmo Búsqueda Lineal (Máquina de Estados) ---

            /**
             * Ejecuta un paso lógico del algoritmo de búsqueda lineal.
             * Utiliza una máquina de estados (`state.phase`) para controlar el flujo.
             * @returns {boolean} True si la animación debe continuar automáticamente, false si debe detenerse.
             */
            function linearSearchStep() {
                // Detener si ya terminó o si no hay un objetivo válido
                if (state.isFinished || targetValue === null || isNaN(targetValue)) {
                    if (targetValue === null || isNaN(targetValue)) {
                        // Si se detiene por objetivo inválido, asegura que no siga corriendo
                        state.isRunning = false; state.isPaused = false; updateControls();
                    }
                    return false; // No continuar
                }

                let continueAuto = true; // Asume que la animación continúa por defecto

                // Máquina de estados
                switch (state.phase) {
                    case 'idle': // Estado inicial antes de empezar
                        highlightCodeLine(1); // var índice = None
                        // Reinicia variables internas del estado
                        state.foundIndex = null; state.isComparing = false; state.currentValueAtIndexI = null;
                        state.i = -1; // 'i' empieza conceptualmente antes del array
                        updateAllPointers(); // Asegura que el puntero 'i' esté oculto
                        state.phase = 'init_i'; // Siguiente fase: inicializar 'i'
                        break;

                    case 'init_i': // Inicializar el índice 'i'
                        highlightCodeLine(2); // var i = 0
                        state.i = 0; // Pone 'i' en el primer elemento
                        highlightState({ type: 'set_i' }); // Renderiza para mostrar el puntero en i=0
                        state.phase = 'start_while'; // Siguiente fase: comprobar condición del bucle
                        break;

                    case 'start_while': // Evaluar la condición del bucle while
                        highlightCodeLine(3); // while índice.isEmpty && i < xs.length
                        state.isComparing = false; // Desactiva resaltado de comparación anterior
                        // Actualiza visualización (pone en gris la barra anterior si aplica) ANTES de evaluar
                        highlightState({ type: 'check_while', i: state.i });

                        // Comprueba si debe continuar el bucle
                        if (state.foundIndex === null && state.i < array.length) {
                            state.phase = 'compare'; // Condición verdadera: ir a comparar
                        } else {
                            // Condición falsa: la búsqueda termina
                            state.phase = state.foundIndex !== null ? 'found_exit' : 'not_found_exit';
                        }
                        break;

                    case 'compare': // Comparar el elemento actual xs[i] con el objetivo
                        highlightCodeLine(4); // if xs(i) == x
                        // Comprobación de seguridad: ¿está 'i' dentro de los límites?
                        if (state.i < 0 || state.i >= array.length) {
                            state.phase = 'not_found_exit'; // Error inesperado
                            break;
                        }
                        state.currentValueAtIndexI = array[state.i]; // Obtiene el valor actual
                        state.isComparing = true; // Activa flag para resaltado verde
                        highlightState({ type: 'comparing', i: state.i, val: state.currentValueAtIndexI }); // Resalta barra 'i' en verde

                        // Decide la siguiente fase según la comparación
                        if (state.currentValueAtIndexI === targetValue) {
                            state.phase = 'found'; // ¡Encontrado!
                        } else {
                            state.phase = 'increment_i'; // No encontrado: ir a incrementar 'i'
                        }
                        break;

                    case 'found': // El elemento ha sido encontrado
                        highlightCodeLine(5); // índice = Some(i)
                        state.foundIndex = state.i; // Guarda el índice donde se encontró
                        state.isComparing = false; // Desactiva resaltado verde
                        highlightState({ type: 'element_found', foundIndex: state.foundIndex }); // Resalta barra en dorado
                        state.phase = 'found_exit'; // Siguiente fase: salir
                        break;

                    case 'increment_i': // Corresponde al bloque 'else' - preparar incremento de 'i'
                        highlightCodeLine(6); // else line (implícito)
                        state.isComparing = false; // Desactiva resaltado verde
                        // Pone en gris la barra recién comprobada (en state.i) ANTES de mover el puntero
                        highlightState({ type: 'before_increment', i: state.i });

                        // Pausa breve para que se vea el cambio a gris
                        state.phase = 'do_increment';
                        continueAuto = false; // Pausar animación automática
                        timeouts.push(setTimeout(() => {
                            // Continuar solo si sigue corriendo y en la fase correcta
                            if (state.isRunning && !state.isPaused && state.phase === 'do_increment') {
                                requestStep(false);
                            }
                        }, animationSpeed * 0.2)); // Pausa corta
                        break;

                    case 'do_increment': // Ejecutar la instrucción i += 1
                        highlightCodeLine(7); // i += 1
                        state.i++; // Incrementa el índice
                        // Actualiza posición del puntero, pero no cambia colores de barras aún
                        highlightState({ type: 'incremented_i', i: state.i });

                        // Pausa para permitir que la animación del puntero se complete
                        state.phase = 'delay_after_increment';
                        continueAuto = false; // Pausar animación automática
                        timeouts.push(setTimeout(() => {
                            // Continuar solo si sigue corriendo y en la fase correcta
                            if (state.isRunning && !state.isPaused && state.phase === 'delay_after_increment') {
                                requestStep(false);
                            }
                        }, POINTER_ANIMATION_DURATION)); // Duración de la animación CSS
                        break;

                    case 'delay_after_increment': // Estado intermedio tras la pausa de animación del puntero
                        // Volver al inicio del bucle para evaluar la condición con la nueva 'i'
                        state.phase = 'start_while';
                        highlightCodeLine(3); // Resalta 'while' de nuevo
                        // Actualiza visualización (necesario si 'i' se salió de los límites)
                        highlightState({ type: 'check_while', i: state.i });
                        break;

                    case 'found_exit': // El bucle terminó porque se encontró el elemento
                        highlightCodeLine(8); // índice (línea de retorno)
                        state.isFinished = true; state.isRunning = false; state.isComparing = false;
                        // Muestra mensaje de éxito
                        setTargetDisplayMessage(`<span class="result-found">Encontrado</span> en índice: <span class="index-value">${state.foundIndex}</span> (índice: Some(${state.foundIndex}))`);
                        updateControls(); // Actualiza botones
                        continueAuto = false; // Detener animación
                        break;
                    case 'not_found_exit': // El bucle terminó porque 'i' alcanzó el final del array
                        highlightCodeLine(8); // índice (línea de retorno)
                        state.isFinished = true; state.isRunning = false; state.isComparing = false;
                        // Actualiza visualización para mostrar 'i' fuera de límites
                        highlightState({ type: 'element_not_found', i: state.i });
                        // Muestra mensaje de fracaso
                        setTargetDisplayMessage(`<span class="result-not-found">No encontrado</span> (índice: None)`);
                        updateControls(); // Actualiza botones
                        continueAuto = false; // Detener animación
                        break;

                } // Fin switch

                // Actualiza controles si la animación se detuvo por pausa o fin
                if (!state.isRunning && !state.isFinished) { updateControls(); }
                return continueAuto; // Devuelve si se debe continuar automáticamente
            }


            // --- Lógica de Control de la Animación ---

            /**
             * Maneja clics en el botón Iniciar/Pausar/Continuar/Reiniciar.
             * Adapta su comportamiento según el estado actual (`state.isFinished`, `state.isRunning`).
             */
            function handleStartPause() {
                // Si terminó -> Reiniciar (reset parcial manteniendo array y objetivo)
                if (state.isFinished) {
                    resetAlgorithm(false);
                    // Iniciar automáticamente la búsqueda tras un breve retraso
                    setTimeout(() => {
                        if (targetValue !== null && !isNaN(targetValue)) { // Solo si hay objetivo válido
                            state.isRunning = true; state.isPaused = false; state.phase = 'idle';
                            requestStep(false); // Inicia ejecución automática
                        }
                        updateControls();
                    }, 100);
                    return;
                }
                // Si está corriendo -> Pausar
                if (state.isRunning) {
                    state.isPaused = true; state.isRunning = false; clearTimeouts();
                }
                // Si está pausado o inactivo -> Iniciar/Continuar
                else {
                    if (targetValue === null || isNaN(targetValue)) return; // No hacer nada sin objetivo válido
                    state.isPaused = false; state.isRunning = true;
                    requestStep(false); // Inicia o continúa la ejecución automática
                }
                updateControls(); // Actualiza texto y estado del botón
            }

            /**
             * Solicita la ejecución de un paso del algoritmo, ya sea manual o automático.
             * Maneja la programación del siguiente paso si es automático.
             * @param {boolean} force - True indica un paso manual forzado por el usuario.
             */
            function requestStep(force) {
                clearTimeouts(); // Cancela cualquier paso automático programado

                // Ignora si no hay un objetivo válido
                if (targetValue === null || isNaN(targetValue)) {
                    // Si estaba corriendo, detenerlo
                    if (state.isRunning) { state.isRunning = false; state.isPaused = false; updateControls(); }
                    return;
                }

                if (force) { // Paso manual
                    if (state.isRunning) { // Si corría automáticamente, pausarlo primero
                        state.isPaused = true; state.isRunning = false;
                        updateControls();
                    } else if (!state.isFinished) { // Si estaba pausado/inactivo, ejecutar un paso
                        linearSearchStep(); // Ejecuta la lógica del algoritmo
                        updateControls(); // Actualiza botones tras el paso
                    }
                } else if (state.isRunning && !state.isPaused) { // Paso automático
                    if (state.isFinished) { updateControls(); return; } // No hacer nada si ya terminó
                    const continueAuto = linearSearchStep(); // Ejecuta la lógica del algoritmo
                    const isWaitingForTimeout = timeouts.length > 0; // ¿Hay una pausa interna activa?
                    // Si el paso indica continuar, no hay pausa interna, y sigue corriendo...
                    if (continueAuto && !isWaitingForTimeout && state.isRunning && !state.isPaused && !state.isFinished) {
                        // Programar el siguiente paso automático
                        timeouts.push(setTimeout(() => requestStep(false), animationSpeed));
                    } else if (state.isFinished || state.isPaused) {
                        // Si terminó o se pausó, solo actualizar controles
                        updateControls();
                    }
                }
            }

            /**
             * Cancela todos los timeouts que estén pendientes en el array `timeouts`.
             */
            function clearTimeouts() { timeouts.forEach(clearTimeout); timeouts = []; }

            /**
             * Se ejecuta cuando el valor del slider de velocidad cambia.
             * Actualiza la variable `animationSpeed`.
             */
            function handleSpeedChange() { animationSpeed = calculateSpeed(speedSlider.value); }

            /**
             * Actualiza el estado (habilitado/deshabilitado) y el texto de los botones
             * de control basándose en el estado actual del algoritmo (`state`).
             */
            function updateControls() {
                const isRunningAuto = state.isRunning && !state.isPaused;
                const isBusy = isRunningAuto; // Consideramos 'ocupado' si corre automáticamente
                const hasValidTarget = targetValue !== null && !isNaN(targetValue);

                // Habilitar/deshabilitar botones
                stepBtn.disabled = !hasValidTarget || state.isFinished || isBusy;
                startPauseBtn.disabled = !hasValidTarget || state.isFinished; // Deshabilitado sin objetivo o si terminó

                resetBtn.disabled = isBusy; // Deshabilitado mientras corre
                randomArrayBtn.disabled = isBusy;
                manualInputBtn.disabled = isBusy;
                targetInput.disabled = isBusy; // No cambiar tamaño/objetivo mientras corre
                increaseSizeBtn.disabled = arraySize >= maxSize || isBusy;
                decreaseSizeBtn.disabled = arraySize <= minSize || isBusy;
                speedSlider.disabled = isBusy;

                // Actualizar texto del botón principal
                if (state.isFinished) { startPauseBtn.textContent = 'Reiniciar'; }
                else if (isRunningAuto) { startPauseBtn.textContent = 'Pausar'; }
                else { startPauseBtn.textContent = (state.phase === 'idle') ? 'Iniciar' : 'Continuar'; }

                // Asegurar que Iniciar/Paso estén deshabilitados sin objetivo válido
                if (!hasValidTarget) {
                    startPauseBtn.disabled = true;
                    stepBtn.disabled = true;
                }
            }

            // --- Punto de Entrada ---
            // Espera a que el DOM esté completamente cargado antes de ejecutar la inicialización.
            document.addEventListener('DOMContentLoaded', init);

        })(); // Fin de la envoltura IIFE
    </script>

</body>

</html>