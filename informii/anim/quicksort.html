<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualización Quicksort (Árbol Recursivo)</title>
    <style>
        /* --- Estilos (Sin cambios) --- */
        body{font-family:sans-serif;display:flex;flex-direction:column;align-items:center;padding:20px;background-color:#f4f4f4;min-height:100vh}h1{text-align:center;margin-bottom:20px}#controls{margin-bottom:20px;display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;width:95%;max-width:800px}
        #status,#explanation{font-size:1em;text-align:center;min-height:1.5em;width:90%;max-width:800px;background-color:#e9e9e9;padding:10px;border-radius:5px;margin-top:10px}#explanation{font-style:italic;color:#333;margin-bottom:20px}
        #code-area{width:90%;max-width:800px;margin-top:20px;padding-bottom:20px}#code-area h2{text-align:center;margin-bottom:5px;font-size:1.1em}#code-container{background-color:#2d2d2d;color:#ccc;padding:5px 5px;border-radius:5px;font-family:'Courier New',Courier,monospace;font-size:.9em;line-height:.6;white-space:pre;overflow-x:auto}.code-line{display:block;transition:background-color .3s ease;border-radius:3px;padding:0 5px;margin:0}.highlight-line{background-color:#555;color:#fff;font-weight:700}
        button,label,input[type=range],input[type=number]{padding:8px 12px;font-size:14px;cursor:pointer}label{cursor:default}
        #visualization-area{width:95%;max-width:1000px;display:flex;flex-direction:column;align-items:center;margin-bottom:20px}#tree-visualization{width:100%;height:250px;margin-bottom:15px;border:1px solid #b0b0b0;background-color:#fdfdfd;overflow:auto}#array-visualization{width:100%;display:flex;flex-direction:column;align-items:center}#visualization-container{display:flex;align-items:flex-end;height:200px;width:100%;margin-top:10px;padding:10px;border:1px solid #ccc;background-color:#fff;box-shadow:2px 2px 5px rgba(0,0,0,.1);min-height:100px;overflow-x:auto;position:relative;box-sizing:border-box}#indices-container{display:flex;align-items:flex-start;height:20px;width:100%;padding:0 10px;box-sizing:border-box;margin-top:5px;overflow:hidden}
        .tree-node{transition:fill .3s ease,stroke .3s ease}.tree-node-pending{fill:#f0f0f0;stroke:#ccc}.tree-node-active{fill:#fffacd;stroke:orange;stroke-width:3}.tree-node-partitioned{fill:#add8e6;stroke:#4682b4}.tree-node-completed{fill:#90ee90;stroke:#2e8b57}.tree-edge{stroke:#888;stroke-width:1.5}.node-text{font-size:11px;font-family:sans-serif;text-anchor:middle;dominant-baseline:middle;pointer-events:none;fill:#333}
        .bar{display:inline-block;background-color:steelblue;margin:0 1px;width:20px;position:relative;bottom:0;transition:background-color .3s ease,height .3s ease,border .2s ease;overflow:visible;flex-shrink:0;box-sizing:border-box}.index-label{display:inline-block;text-align:center;font-size:11px;color:#333;margin:0 1px;width:20px;line-height:20px;flex-shrink:0}.bar-value{position:absolute;top:-20px;left:50%;transform:translateX(-50%);font-size:11px;color:#222;background-color:rgba(255,255,255,.7);padding:3px 6px;border-radius:2px;white-space:nowrap;z-index:5}.bar::after{content:attr(data-value);position:absolute;top:-20px;left:50%;transform:translateX(-50%);background-color:rgba(0,0,0,.8);color:#fff;padding:3px 6px;border-radius:3px;font-size:12px;white-space:nowrap;opacity:0;visibility:hidden;transition:opacity .2s,visibility .2s;z-index:15}.bar:hover::after{opacity:1;visibility:visible}
        .bar-active-subarray{background-color:#e8e8e8 !important}.bar-pivot-final{background-color:cyan !important;border:1px solid navy}.bar-partitioned-lt{background-color:lightgreen !important}.bar-partitioned-gt{background-color:lightsalmon !important}.bar-fully-sorted{background-color:mediumseagreen !important;border:none}

    </style>
</head>
<body>

    <h1>Visualización Quicksort (Árbol Recursivo)</h1>

    <div id="controls">
        <button id="btn-reset">Generar Nuevo Array</button>
        <button id="btn-manual-input">Introducir</button>
        <label for="array-size">Tamaño:</label>
        <!-- 1. Quitar readonly -->
        <input type="number" id="array-size" value="15" min="5" max="40" step="1">
         <label for="speed">Velocidad:</label>
        <input type="range" id="speed" min="50" max="1000" value="500" step="50">
        <button id="btn-start">Iniciar Quicksort</button>
        <button id="btn-step">Paso Siguiente</button>
        <button id="btn-pause" disabled>Pausar</button>
    </div>

    <div id="visualization-area">
        <div id="tree-visualization">
            <svg id="tree-svg" width="100%" height="100%" style="min-width: 600px;"></svg>
        </div>
        <div id="array-visualization">
            <div id="visualization-container"></div>
            <div id="indices-container"></div>
        </div>
    </div>

    <div id="status">Listo para empezar. Genera un array o introduce valores.</div>
    <div id="explanation">Visualización de las llamadas recursivas y el resultado de la partición en Quicksort.</div>

    <div id="code-area">
        <h2>Código del Algoritmo (Scala):</h2>
        <div id="code-container">
             <code id="code-display">
<span id="line-qs-1" class="code-line">def quickSort[A](xs: Array[A])(using ord: Ordering[A]): Unit =</span>
<span id="line-qs-2" class="code-line">  import ord.*</span>
<span id="line-qs-3" class="code-line"> </span>
<span id="line-qs-4" class="code-line">  def aux(izq: Int, der: Int): Unit =</span>
<span id="line-qs-5" class="code-line">    if izq < der then</span>
<span id="line-qs-6" class="code-line">      // --- Partición (Simulada) ---</span>
<span id="line-qs-7" class="code-line">      val posPivot = parte(izq, der)</span>
<span id="line-qs-8" class="code-line">      // ---------------------------</span>
<span id="line-qs-9" class="code-line">      aux(izq, posPivot - 1)</span>
<span id="line-qs-10" class="code-line">      aux(posPivot + 1, der)</span>
<span id="line-qs-11" class="code-line">    // else: Caso base (izq >= der)</span>
<span id="line-qs-12" class="code-line"></span>
<span id="line-qs-13" class="code-line"> // Llamada inicial</span>
<span id="line-qs-14" class="code-line"> aux(0, xs.length - 1)</span>
            </code>
        </div>
    </div>

    <script>
        // --- Variables Globales (sin cambios) ---
        var arraySizeInput = document.getElementById('array-size'); var visualizationContainer = document.getElementById('visualization-container'); var indicesContainer = document.getElementById('indices-container'); var treeSvg = document.getElementById('tree-svg'); var codeDisplay = document.getElementById('code-display'); var statusDiv = document.getElementById('status'); var explanationDiv = document.getElementById('explanation'); var speedSlider = document.getElementById('speed'); var btnReset = document.getElementById('btn-reset'); var btnStart = document.getElementById('btn-start'); var btnStep = document.getElementById('btn-step'); var btnPause = document.getElementById('btn-pause'); var btnManualInput = document.getElementById('btn-manual-input');
        if (!visualizationContainer || !indicesContainer || !treeSvg || !statusDiv || !explanationDiv || !btnStart || !btnManualInput) { console.error("FATAL: Elementos DOM no encontrados."); if (statusDiv) statusDiv.textContent = "Error crítico."; }
        var array = []; var callStack = []; var treeNodes = {}; var nextNodeId = 0; var currentIzq = -1, currentDer = -1, currentNodeId = -1; var currentPivot = -1; var sortedStatus = []; var isSorting = false, isPaused = false, isStepMode = false, timeoutId = null, currentStepAction = null, delay = 500, animationDuration = 100; var currentHighlightedLine = null, currentBarWidth = 20, currentBarMargin = 1; var lastHighlightInfo = null;
        const NODE_WIDTH = 60; const NODE_HEIGHT = 30; const LEVEL_HEIGHT = 60; const HORIZ_SPACING_FACTOR = 1.2;

        // --- Funciones Algoritmo (sin cambios) ---
        function intercambiar(p1, p2) { var temp = array[p1]; array[p1] = array[p2]; array[p2] = temp; }
        function simulatePartition(izq, der) { if (izq >= der) return izq; let cen = izq + Math.floor((der - izq) / 2); let pivotValue = array[cen]; intercambiar(cen, der); let p = izq; for (let i = izq; i < der; i++) { if (array[i] <= pivotValue) { intercambiar(i, p); p++; } } intercambiar(p, der); return p; }

        // --- Funciones de Control del Algoritmo (sin cambios) ---
        function quickSortStep() { if (!isSorting || (isPaused && !isStepMode)) return; if (isStepMode && timeoutId) { clearTimeout(timeoutId); timeoutId = null; } clearTimeout(timeoutId); timeoutId = null; if (currentStepAction) { currentStepAction(); } else { if (callStack.length === 0 && currentNodeId === -1) { finishSort(); } else { currentStepAction = processNextNode; quickSortStep(); } } if (isSorting && !isPaused && !isStepMode && currentStepAction && !timeoutId) { timeoutId = setTimeout(quickSortStep, delay); } if (isStepMode) { isPaused = true; isStepMode = false; updateButtonStates(); } }
        function startQuickSortTree() { highlightCodeLine('line-qs-14'); callStack = []; treeNodes = {}; nextNodeId = 0; sortedStatus = new Array(array.length).fill(false); currentIzq = -1; currentDer = -1; currentNodeId = -1; currentPivot = -1; treeSvg.innerHTML = ''; if (array.length > 0) { let rootId = createTreeNode(0, array.length - 1, null, 0); callStack.push([0, array.length - 1, rootId]); treeNodes[rootId].status = 'pending'; drawTree(); statusDiv.textContent = "Iniciando Quicksort."; explanationDiv.textContent = `Añadido nodo raíz [0, ${array.length - 1}] a la pila.`; } else { statusDiv.textContent = "Array vacío."; explanationDiv.textContent = ""; } currentStepAction = processNextNode; if (isSorting && !isPaused && !isStepMode) { timeoutId = setTimeout(quickSortStep, delay * 0.5); } else if (isStepMode) { isPaused = true; isStepMode = false; updateButtonStates(); } }
        function processNextNode() { highlightCodeLine('line-qs-4'); if (callStack.length === 0) { currentStepAction = null; finishSort(); return; } [currentIzq, currentDer, currentNodeId] = callStack.pop(); currentPivot = -1; treeNodes[currentNodeId].status = 'active'; statusDiv.textContent = `Procesando nodo ${currentNodeId}: [${currentIzq}, ${currentDer}].`; explanationDiv.textContent = `Resaltando rango en árbol y barras...`; drawTree(); drawArray({ type: 'show_subarray', izq: currentIzq, der: currentDer }); lastHighlightInfo = { type: 'show_subarray', izq: currentIzq, der: currentDer }; timeoutId = setTimeout(() => { if (!isSorting) return; highlightCodeLine('line-qs-5'); statusDiv.textContent = `Evaluando if ${currentIzq} < ${currentDer}.`; if (currentIzq < currentDer) { explanationDiv.textContent = `Verdadero. Se particionará [${currentIzq}, ${currentDer}].`; currentStepAction = performPartitionTree; } else { explanationDiv.textContent = `Falso (Caso Base). Nodo ${currentNodeId}: [${currentIzq}, ${currentDer}] completado.`; highlightCodeLine('line-qs-11'); treeNodes[currentNodeId].status = 'completed'; markSubArraySorted(currentIzq, currentDer); currentStepAction = processNextNode; } if (isSorting && !isPaused && !isStepMode) { timeoutId = setTimeout(quickSortStep, delay); } else if (isStepMode) { isPaused = true; isStepMode = false; updateButtonStates(); } }, isStepMode ? 50 : delay * 0.8); }
        function performPartitionTree() { highlightCodeLine('line-qs-7'); statusDiv.textContent = `Nodo ${currentNodeId}: Particionando [${currentIzq}, ${currentDer}]... (Simulado)`; explanationDiv.textContent = `Llamada simulada a 'parte'.`; currentPivot = simulatePartition(currentIzq, currentDer); treeNodes[currentNodeId].pivotPos = currentPivot; treeNodes[currentNodeId].status = 'partitioned'; if(currentPivot >= 0 && currentPivot < sortedStatus.length) { sortedStatus[currentPivot] = true; } drawArray({ type: 'partition_done', izq: currentIzq, der: currentDer, pivot: currentPivot }); lastHighlightInfo = { type: 'partition_done', izq: currentIzq, der: currentDer, pivot: currentPivot }; drawTree(); statusDiv.textContent = `Nodo ${currentNodeId}: Partición completada.`; explanationDiv.textContent = `Pivote final en ${currentPivot}. Preparando llamadas recursivas.`; timeoutId = setTimeout(() => { if (!isSorting) return; currentStepAction = createAndPushChildren; if (isSorting && !isPaused && !isStepMode) { timeoutId = setTimeout(quickSortStep, delay * 1.1); } else if (isStepMode) { isPaused = true; isStepMode = false; updateButtonStates(); } }, isStepMode ? 50 : delay * 1.1); }
        function createAndPushChildren() { let parentNode = treeNodes[currentNodeId]; let leftId = null, rightId = null; let rightIzq = currentPivot + 1; let rightDer = currentDer; let leftIzq = currentIzq; let leftDer = currentPivot - 1; statusDiv.textContent = `Nodo ${currentNodeId}: Creando y añadiendo hijos a la pila.`; explanationDiv.textContent = ""; if (rightIzq < rightDer) { highlightCodeLine('line-qs-10'); rightId = createTreeNode(rightIzq, rightDer, currentNodeId, parentNode.depth + 1); treeNodes[rightId].status = 'pending'; callStack.push([rightIzq, rightDer, rightId]); explanationDiv.textContent += `Añadido hijo derecho [${rightIzq}, ${rightDer}] (Nodo ${rightId}). `; } else { markSubArraySorted(rightIzq, rightDer); explanationDiv.textContent += `Rango derecho [${rightIzq}, ${rightDer}] es caso base. `; } if (leftIzq < leftDer) { highlightCodeLine('line-qs-9'); leftId = createTreeNode(leftIzq, leftDer, currentNodeId, parentNode.depth + 1); treeNodes[leftId].status = 'pending'; callStack.push([leftIzq, leftDer, leftId]); explanationDiv.textContent += `Añadido hijo izquierdo [${leftIzq}, ${leftDer}] (Nodo ${leftId}). `; } else { markSubArraySorted(leftIzq, leftDer); explanationDiv.textContent += `Rango izquierdo [${leftIzq}, ${leftDer}] es caso base. `; } parentNode.childrenIds = [leftId, rightId]; drawTree(); currentIzq = -1; currentDer = -1; currentNodeId = -1; currentPivot = -1; drawArray({ type: 'subproblems_pushed' }); lastHighlightInfo = { type: 'subproblems_pushed' }; currentStepAction = processNextNode; if (isSorting && !isPaused && !isStepMode) { timeoutId = setTimeout(quickSortStep, delay * 0.8); } else if (isStepMode) { isPaused = true; isStepMode = false; updateButtonStates(); } }
        function createTreeNode(izq, der, parentId, depth) { const id = nextNodeId++; treeNodes[id] = { id: id, izq: izq, der: der, parentId: parentId, childrenIds: [null, null], status: 'pending', depth: depth, x: 0, y: 0, pivotPos: -1 }; return id; }
        function markSubArraySorted(izq, der) { for (let k = izq; k <= der; k++) { if (k >= 0 && k < sortedStatus.length) { sortedStatus[k] = true; } } drawArray(lastHighlightInfo ? {...lastHighlightInfo, type: 'marked_sorted'} : { type: 'marked_sorted' }); }

        // --- Funciones de Visualización (sin cambios) ---
        function drawArray(highlightInfo) { if (!visualizationContainer || !indicesContainer) return; var containerHeight = visualizationContainer.clientHeight; var containerWidth = visualizationContainer.clientWidth; var effectiveWidth = containerWidth - parseFloat(getComputedStyle(visualizationContainer).paddingLeft) - parseFloat(getComputedStyle(visualizationContainer).paddingRight); var effectiveHeight = containerHeight - parseFloat(getComputedStyle(visualizationContainer).paddingTop) - parseFloat(getComputedStyle(visualizationContainer).paddingBottom); if (effectiveHeight <= 0) effectiveHeight = 100; if (effectiveWidth <= 0) effectiveWidth = 500; visualizationContainer.innerHTML = ''; indicesContainer.innerHTML = ''; if (!array || array.length === 0) return; var maxValue = 0; for (let k = 0; k < array.length; k++) { if (typeof array[k] === 'number' && !isNaN(array[k]) && array[k] > maxValue) maxValue = array[k]; } if (maxValue <= 0) maxValue = 1; var calculatedWidth = Math.floor(effectiveWidth / array.length); currentBarMargin = 1; currentBarWidth = Math.max(3, calculatedWidth - (currentBarMargin * 2)); if (array.length > 40) { currentBarMargin = 0.5; currentBarWidth = Math.max(1, Math.floor(effectiveWidth / array.length) - (currentBarMargin*2)); } else if (array.length > 30) { currentBarMargin = 0.5; currentBarWidth = Math.max(2, Math.floor(effectiveWidth / array.length) - (currentBarMargin*2)); } for (var k = 0; k < array.length; k++) { if (typeof array[k] !== 'number' || isNaN(array[k])) continue; var bar = document.createElement('div'); bar.className = 'bar'; var barHeight = Math.max(5, (array[k] / maxValue) * effectiveHeight); bar.style.height = barHeight + 'px'; bar.style.width = currentBarWidth + 'px'; bar.style.marginLeft = currentBarMargin + 'px'; bar.style.marginRight = currentBarMargin + 'px'; bar.setAttribute('data-value', array[k]); var valueSpan = document.createElement('span'); valueSpan.className = 'bar-value'; valueSpan.textContent = array[k]; bar.appendChild(valueSpan); var indexLabel = document.createElement('span'); indexLabel.className = 'index-label'; indexLabel.textContent = k; indexLabel.style.width = currentBarWidth + 'px'; indexLabel.style.marginLeft = currentBarMargin + 'px'; indexLabel.style.marginRight = currentBarMargin + 'px'; const infoType = highlightInfo ? highlightInfo.type : null; if (sortedStatus[k]) { bar.classList.add('bar-fully-sorted'); } else if (isSorting || isPaused) { const currentIzqB = highlightInfo?.izq ?? -1; const currentDerB = highlightInfo?.der ?? -1; const currentPivotB = highlightInfo?.pivot ?? -1; const isInActiveRange = k >= currentIzqB && k <= currentDerB; if (infoType === 'show_subarray' && isInActiveRange) { bar.classList.add('bar-active-subarray'); } else if (infoType === 'partition_done' && isInActiveRange) { if (k === currentPivotB) bar.classList.add('bar-pivot-final'); else if (k < currentPivotB) bar.classList.add('bar-partitioned-lt'); else bar.classList.add('bar-partitioned-gt'); } } visualizationContainer.appendChild(bar); indicesContainer.appendChild(indexLabel); } }
        function drawTree() { treeSvg.innerHTML = ''; const svgWidth = treeSvg.clientWidth || 600; const nodesAtDepth = {}; let maxDepth = 0; for (const id in treeNodes) { const node = treeNodes[id]; node.y = (node.depth + 0.5) * LEVEL_HEIGHT; maxDepth = Math.max(maxDepth, node.depth); if (!nodesAtDepth[node.depth]) { nodesAtDepth[node.depth] = []; } nodesAtDepth[node.depth].push(node); } for (let depth = 0; depth <= maxDepth; depth++) { if (!nodesAtDepth[depth]) continue; const levelNodes = nodesAtDepth[depth]; const levelWidth = levelNodes.length * NODE_WIDTH * HORIZ_SPACING_FACTOR; const startX = (svgWidth - levelWidth) / 2; levelNodes.sort((a,b) => a.izq - b.izq); for(let i = 0; i < levelNodes.length; i++) { const node = levelNodes[i]; node.x = startX + (i + 0.5) * NODE_WIDTH * HORIZ_SPACING_FACTOR; } } for (const id in treeNodes) { const node = treeNodes[id]; if (node.parentId !== null && treeNodes[node.parentId]) { const parent = treeNodes[node.parentId]; drawTreeEdge(parent.x, parent.y + NODE_HEIGHT / 2, node.x, node.y - NODE_HEIGHT / 2); } } for (const id in treeNodes) { drawTreeNode(treeNodes[id]); } const requiredHeight = (maxDepth + 1.5) * LEVEL_HEIGHT; treeSvg.setAttribute('viewBox', `0 0 ${svgWidth} ${Math.max(treeSvg.clientHeight || 250, requiredHeight)}`); }
        function drawTreeNode(node) { const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); rect.setAttribute('x', node.x - NODE_WIDTH / 2); rect.setAttribute('y', node.y - NODE_HEIGHT / 2); rect.setAttribute('width', NODE_WIDTH); rect.setAttribute('height', NODE_HEIGHT); rect.setAttribute('rx', 3); rect.setAttribute('ry', 3); rect.classList.add('tree-node'); rect.classList.add(`tree-node-${node.status}`); rect.id = `node-${node.id}`; treeSvg.appendChild(rect); const text = document.createElementNS('http://www.w3.org/2000/svg', 'text'); text.setAttribute('x', node.x); text.setAttribute('y', node.y); text.classList.add('node-text'); if (node.status === 'completed') { text.textContent = '✓'; text.style.fontSize = '16px'; text.style.fill = 'darkgreen'; } else { text.textContent = `[${node.izq}, ${node.der}]`; } treeSvg.appendChild(text); }
        function drawTreeEdge(x1, y1, x2, y2) { const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2); line.classList.add('tree-edge'); treeSvg.appendChild(line); }
        function highlightState(highlightInfo) { drawArray(highlightInfo); }
        function highlightFinalSortedState() { drawArray({ type: 'final' }); }
        function highlightCodeLine(lineId) { /* Sin cambios */ if (currentHighlightedLine) { var prevLine = document.getElementById(currentHighlightedLine); if (prevLine) prevLine.classList.remove('highlight-line'); } if (lineId !== null) { var currentLine = document.getElementById(lineId); if (currentLine) { currentLine.classList.add('highlight-line'); currentHighlightedLine = lineId; } else { console.warn("highlightCodeLine: Línea no encontrada -", lineId); currentHighlightedLine = null; } } else { currentHighlightedLine = null; } }

        // --- Funciones de Control General (sin cambios) ---
        function generateArray() { console.log("generateArray"); if (!arraySizeInput) return; var size = parseInt(arraySizeInput.value, 10); if (isNaN(size) || size < 5 || size > 40) { alert("Tamaño entre 5 y 40."); size = 15; arraySizeInput.value = size; } array = []; for (let k = 0; k < size; k++) { array.push(Math.floor(Math.random() * 100) + 1); } sortedStatus = new Array(array.length).fill(false); resetQuickSortState(); drawArray(null); drawTree(); if (statusDiv) statusDiv.textContent = "Nuevo array. Pulsa Iniciar."; if (explanationDiv) explanationDiv.textContent = "Visualización de Quicksort."; highlightCodeLine(null); }
        function promptForManualArray() { if (isSorting && !isPaused) { alert("Detén o pausa la animación."); return; } const userInput = prompt("Valores separados por comas:", array.join(', ')); if (userInput === null) return; const parsedInput = userInput.split(/[\s,]+/).filter(s => s.trim() !== '').map(s => parseInt(s.trim(), 10)); if (parsedInput.length === 0 || parsedInput.some(isNaN)) { alert("Entrada inválida."); return; } if (parsedInput.length < 5 || parsedInput.length > 40) { alert(`Tamaño entre 5 y 40. Introducidos: ${parsedInput.length}.`); return; } array = parsedInput; sortedStatus = new Array(array.length).fill(false); resetQuickSortState(); drawArray(null); drawTree(); if (statusDiv) statusDiv.textContent = "Array manual cargado."; if (explanationDiv) explanationDiv.textContent = "Visualización de Quicksort."; highlightCodeLine(null); if(arraySizeInput) arraySizeInput.value = array.length; }
        function resetQuickSortState() { console.log("resetQuickSortState"); callStack = []; treeNodes = {}; nextNodeId = 0; currentIzq = -1; currentDer = -1; currentNodeId = -1; currentPivot = -1; isSorting = false; isPaused = false; isStepMode = false; currentStepAction = null; lastHighlightInfo = null; if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; } highlightCodeLine(null); updateButtonStates(); treeSvg.innerHTML = ''; }
        function startAlgorithm() { console.log("startAlgorithm"); if (isSorting && !isPaused) return; if (!array || array.length === 0) { if(statusDiv) statusDiv.textContent="Genera un array."; return; } isSorting = true; isPaused = false; isStepMode = false; if (currentStepAction === null) { currentStepAction = startQuickSortTree; } if (statusDiv) statusDiv.textContent = "Iniciando Quicksort..."; updateButtonStates(); quickSortStep(); }
        function pauseAlgorithm() { console.log("pauseAlgorithm"); if (!isSorting || isPaused) return; isPaused = true; isStepMode = false; if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; } if (statusDiv) statusDiv.textContent = "Pausado."; updateButtonStates(); }
        function stepForward() { console.log("stepForward"); if (!array || array.length === 0) { if(statusDiv) statusDiv.textContent="Genera un array."; return; } if (!isSorting && currentStepAction === null && callStack.length === 0) { console.log("Reiniciando para paso a paso."); resetQuickSortState(); drawArray(null); drawTree(); sortedStatus = new Array(array.length).fill(false); } if (!isSorting || isPaused) { if (!isSorting || (currentStepAction === null && callStack.length === 0)) { resetQuickSortState(); sortedStatus = new Array(array.length).fill(false); currentStepAction = startQuickSortTree; } isSorting = true; isPaused = true; isStepMode = true; if(statusDiv) statusDiv.textContent = "Ejecutando paso..."; updateButtonStates(); quickSortStep(); } }
        function finishSort() { console.log("finishSort"); isSorting = false; isPaused = false; isStepMode = false; currentStepAction = null; lastHighlightInfo = { type: 'final' }; if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; } sortedStatus = new Array(array.length).fill(true); highlightFinalSortedState(); for(const id in treeNodes) { treeNodes[id].status = 'completed'; } drawTree(); if (statusDiv) statusDiv.textContent = "¡Array Ordenado con Quicksort!"; if (explanationDiv) explanationDiv.textContent = ""; highlightCodeLine(null); updateButtonStates(); }
        function updateButtonStates() { try { const running = isSorting && !isPaused; if(btnStart) btnStart.disabled = running; if(btnPause) btnPause.disabled = !isSorting || isPaused; if(btnStep) btnStep.disabled = running; if(btnReset) btnReset.disabled = running; if(btnManualInput) btnManualInput.disabled = running; if(speedSlider) speedSlider.disabled = running; } catch (e) { console.error("Error actualizando botones:", e); } }

        // --- Event Listeners & Inicialización ---
        if (btnReset) btnReset.addEventListener('click', generateArray); else console.warn("Botón Reset no encontrado.");
        if (btnManualInput) btnManualInput.addEventListener('click', promptForManualArray); else console.warn("Botón Manual Input no encontrado.");
        if (btnStart) btnStart.addEventListener('click', startAlgorithm); else console.warn("Botón Start no encontrado.");
        if (btnPause) btnPause.addEventListener('click', pauseAlgorithm); else console.warn("Botón Pause no encontrado.");
        if (btnStep) btnStep.addEventListener('click', stepForward); else console.warn("Botón Step no encontrado.");
        if (speedSlider) { speedSlider.addEventListener('input', function() { delay = 1050 - parseInt(this.value, 10); /* animationDuration es casi irrelevante */ }); } else { console.warn("Slider velocidad no encontrado."); }
        // 2. Reactivar listener para input de tamaño
        if (arraySizeInput) { arraySizeInput.addEventListener('change', generateArray); } else { console.warn("Input tamaño no encontrado."); }

        window.onload = function() { console.log("window.onload"); try { if (speedSlider) { delay = 1050 - parseInt(speedSlider.value, 10); } else { delay = 500; } setTimeout(generateArray, 100); } catch (e) { console.error("Error onload:", e); if(statusDiv) statusDiv.textContent = "Error inicializar."; } };
        var resizeTimeout; window.addEventListener('resize', function() { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(function() { console.log("window.resize"); drawArray(isSorting || isPaused ? lastHighlightInfo : null); drawTree(); }, 250); });
        console.log("Script Quicksort árbol cargado.");

    </script>

</body>
</html>
