<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación: Problema Cajas de Cerillas de Banach</title>
    <!-- Incluimos la librería Chart.js para los gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Estilos similares al ejemplo anterior (Binomial), puedes copiarlos */
        body {
            font-family: sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f4;
        }
        .container {
            max-width: 1200px; margin: auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #controles {
            margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; background-color: #f0f0f0; border-radius: 5px; display: grid; grid-template-columns: auto 1fr; gap: 10px 15px; align-items: center;
        }
        #controles label { font-weight: bold; text-align: right; }
        #controles input[type="number"] {
            padding: 8px; border: 1px solid #ccc; border-radius: 4px; max-width: 150px; justify-self: start;
        }
        #controles button {
            grid-column: 1 / -1; padding: 10px 15px; background-color: #007bff; /* Azul */ color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1.1em; margin-top: 10px;
        }
        #controles button:hover { background-color: #0056b3; }
        #resultadosInfo {
             margin-bottom: 25px; padding: 15px; border: 1px solid #e3e3e3; background-color: #f9f9f9; border-radius: 5px;
        }
         #resultadosInfo h2 { margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
         #resultadosInfo p { margin: 8px 0; line-height: 1.4; }
         #resultadosInfo code { background-color: #e9e9e9; padding: 2px 5px; border-radius: 3px; font-family: monospace; font-size: 0.95em; }
        .graficos-container { display: flex; flex-wrap: wrap; gap: 25px; margin-top: 20px; justify-content: space-between; }
        .grafico-wrapper { flex: 1 1 30%; min-width: 300px; border: 1px solid #ccc; padding: 15px; border-radius: 5px; background-color: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .grafico-wrapper h3 { text-align: center; margin-top: 0; margin-bottom: 15px; color: #333; }
         canvas { max-width: 100%; }
        .estado { font-style: italic; color: #555; min-height: 1.2em; margin-top: 10px; text-align: center; grid-column: 1 / -1; }
        .error { color: #d9534f; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <h1>Simulación: Problema de las Cajas de Cerillas de Banach</h1>
    <p>Se simula el 
        <a href="https://en.wikipedia.org/wiki/Banach%27s_matchbox_problem#">problema clásico</a>: dos cajas con <strong>n</strong> cerillas iniciales cada una. Se elige una caja al azar y se consume la cerilla. Se repite este proceso hasta que se elige una caja vacía. Se registra el número de cerillas <strong>k</strong> restantes en la otra caja.</p>
    <p>Se repite el experimento completo <strong>N</strong> veces.</p>

    <div id="controles">
        <label for="cerillasInput">Nº inicial de cerillas (n):</label>
        <input type="number" id="cerillasInput" value="20" min="1" max="500"> <!-- Limitar n por cálculo combinaciones -->

        <label for="experimentosInput">Nº de experimentos (N):</label>
        <input type="number" id="experimentosInput" value="10000" min="1" max="5000000">

        <button id="btnSimular">Ejecutar Simulación</button>
        <p id="estado" class="estado">Introduce los parámetros y haz clic en el botón.</p>
    </div>

     <div id="resultadosInfo">
        <h2>Resultados de la Simulación</h2>
        <p><strong>Parámetros usados:</strong> <span id="paramsUsados">---</span></p>
        <p><strong>Media Experimental (k promedio):</strong> <span id="mediaExperimental">---</span></p>
        <p><strong>Media Teórica (E[k]):</strong> <span id="mediaTeorica">---</span></p>
        <!-- La varianza es menos estándar de mostrar aquí, pero se podría calcular si se desea -->
    </div>

    <div class="graficos-container">
        <div class="grafico-wrapper">
            <h3>Distribución Experimental (Frec. Relativa)</h3>
            <canvas id="graficoExperimental"></canvas>
        </div>
        <div class="grafico-wrapper">
            <h3>Distribución Teórica (Probabilidad)</h3>
            <canvas id="graficoTeorico"></canvas>
        </div>
         <div class="grafico-wrapper">
            <h3>Diferencias (Teórica - Experimental)</h3>
            <canvas id="graficoDiferencias"></canvas>
        </div>
    </div>
</div>

<script>
    // --- Elementos del DOM ---
    const nInput = document.getElementById('cerillasInput');
    const NInput = document.getElementById('experimentosInput');
    const btnSimular = document.getElementById('btnSimular');
    const estadoEl = document.getElementById('estado');
    const paramsUsadosEl = document.getElementById('paramsUsados');
    const mediaExperimentalEl = document.getElementById('mediaExperimental');
    const mediaTeoricaEl = document.getElementById('mediaTeorica');
    const canvasExp = document.getElementById('graficoExperimental');
    const canvasTeo = document.getElementById('graficoTeorico');
    const canvasDif = document.getElementById('graficoDiferencias');
    const ctxExp = canvasExp.getContext('2d');
    const ctxTeo = canvasTeo.getContext('2d');
    const ctxDif = canvasDif.getContext('2d');

    // --- Variables Globales para los Gráficos ---
    let graficoExperimental = null;
    let graficoTeorico = null;
    let graficoDiferencias = null;

    // --- Funciones Auxiliares ---

    /**
     * Calcula el coeficiente binomial C(n, k) = n! / (k! * (n-k)!).
     * Reutilizada de ejemplos anteriores.
     */
     function combinaciones(n, k) {
        if (k < 0 || k > n) { return 0; }
        if (k === 0 || k === n) { return 1; }
        if (k > n / 2) { k = n - k; }
        let res = 1;
        for (let i = 1; i <= k; i++) {
            // Usar división antes de multiplicar cuando sea posible para mantener números más pequeños
            res = res * (n - i + 1) / i;
             if (!Number.isFinite(res)) {
                 console.warn(`Combinaciones(${n}, ${k}) resultó en infinito/NaN.`);
                 return Infinity; // O manejar como error
             }
        }
        // Redondeo crucial por posibles errores de punto flotante
         return Math.round(res);
    }

    /**
     * Simula un experimento completo del problema de Banach.
     * @param {number} n Número inicial de cerillas en cada caja.
     * @returns {number} El número de cerillas restantes en la otra caja (k).
     */
    function simularUnExperimentoBanach(n) {
        let cajaIzquierda = n;
        let cajaDerecha = n;
        let cerillasRestantes = -1; // Valor inicial inválido

        while (cerillasRestantes === -1) {
            const eligeIzquierda = Math.random() < 0.5;

            if (eligeIzquierda) {
                if (cajaIzquierda > 0) {
                    cajaIzquierda--;
                } else {
                    // ¡Caja izquierda vacía! El experimento termina.
                    cerillasRestantes = cajaDerecha;
                    // break; // Salir del bucle (implícito por la condición while)
                }
            } else { // Elige Derecha
                if (cajaDerecha > 0) {
                    cajaDerecha--;
                } else {
                    // ¡Caja derecha vacía! El experimento termina.
                    cerillasRestantes = cajaIzquierda;
                    // break; // Salir del bucle
                }
            }
             // Seguridad: Evitar bucles infinitos si algo va mal (ej. n=0 inicial)
            if (cajaIzquierda < 0 || cajaDerecha < 0) {
                 console.error("Error en simulación: cerillas negativas encontradas.");
                 return -1; // Indicar error
             }
        }
        return cerillasRestantes;
    }

    /**
     * Calcula la probabilidad teórica P(k) para el problema de Banach.
     * P(k | n) = C(2n - k, n) * (1/2)^(2n - k)
     * donde k es el número de cerillas restantes (0 <= k <= n).
     * @param {number} k Número de cerillas restantes.
     * @param {number} n Número inicial de cerillas.
     * @returns {number} La probabilidad teórica P(k).
     */
    function probabilidadBanach(k, n) {
        if (k < 0 || k > n) return 0;

        const m = 2 * n - k; // Número total de selecciones menos las k restantes
        const Cnk = combinaciones(m, n); // C(2n-k, n)

        if (!Number.isFinite(Cnk) || Cnk === 0) {
             // console.warn(`C(${m}, ${n}) no es finito o es cero para k=${k}, n=${n}`);
             return 0;
        }

        // Calcular (1/2)^m. Usar Math.pow es generalmente seguro aquí.
        // Podríamos usar base 2 logaritmos para precisión extrema, pero suele ser overkill.
        const probFactor = Math.pow(0.5, m);

        let prob = Cnk * probFactor;

        // Asegurar que la probabilidad no sea negativa debido a errores numéricos
        return Math.max(0, prob);
    }

    // --- Función para Dibujar Gráficos (reutilizada y adaptada) ---
    function dibujarGrafico(ctx, chartInstanceRef, labels, data, label, backgroundColor, borderColor, yAxisLabel) {
        if (chartInstanceRef.current) {
            chartInstanceRef.current.destroy();
            chartInstanceRef.current = null;
        }

        chartInstanceRef.current = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels, // k = 0, 1, ..., n
                datasets: [{
                    label: label, // Para tooltip
                    data: data,
                    backgroundColor: backgroundColor,
                    borderColor: borderColor,
                    borderWidth: 1
                }]
            },
            options: {
                 indexAxis: 'x', responsive: true, maintainAspectRatio: true,
                 plugins: {
                    title: { display: false },
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let lbl = context.dataset.label || '';
                                if (lbl) lbl += ': ';
                                if (context.parsed.y !== null) {
                                    if (Math.abs(context.parsed.y) < 0.0001 && context.parsed.y !== 0) {
                                       lbl += context.parsed.y.toExponential(3);
                                    } else {
                                       lbl += context.parsed.y.toFixed(5);
                                    }
                                }
                                return lbl;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        title: { display: true, text: yAxisLabel },
                         ticks: {
                             callback: function(value) {
                                 if (Math.abs(value) < 0.001 && value !== 0) return value.toExponential(1);
                                 const factor = Math.pow(10, 3); // 3 decimales en eje
                                 return Math.round(value * factor) / factor;
                             }
                         }
                    },
                    x: {
                        title: { display: true, text: 'Cerillas Restantes en la Otra Caja (k)' } // Label Eje X específico
                    }
                }
            }
        });
    }

    // --- Función Principal de Simulación ---
    function iniciarSimulacion() {
        // --- Validación de Entradas ---
        const n = parseInt(nInput.value, 10);
        const N = parseInt(NInput.value, 10);

        estadoEl.className = 'estado';
        estadoEl.textContent = 'Validando parámetros...';
        // Limpiar resultados previos
        paramsUsadosEl.textContent = '---';
        mediaExperimentalEl.textContent = '---';
        mediaTeoricaEl.textContent = '---';

        // Limpiar gráficos
        const chartExpRef = { current: graficoExperimental };
        const chartTeoRef = { current: graficoTeorico };
        const chartDifRef = { current: graficoDiferencias };
        [chartExpRef, chartTeoRef, chartDifRef].forEach(ref => {
            if (ref.current) { ref.current.destroy(); }
        });
        graficoExperimental = graficoTeorico = graficoDiferencias = null;


        if (isNaN(n) || n <= 0 || n > 500) { // Limite n por combinaciones
            estadoEl.textContent = 'Error: Nº inicial de cerillas (n) debe ser entero positivo (máx 500).';
             estadoEl.className = 'estado error'; return;
        }
         if (isNaN(N) || N <= 0 || N > 5000000) {
            estadoEl.textContent = 'Error: Nº experimentos (N) debe ser entero positivo (máx 5,000,000).';
             estadoEl.className = 'estado error'; return;
        }

        console.log(`Iniciando simulación Banach: n=${n}, N=${N}`);
        estadoEl.textContent = `Simulando ${N.toLocaleString()} experimentos de Banach (n=${n})...`;
        paramsUsadosEl.textContent = `n=${n}, N=${N.toLocaleString()}`;
        mediaExperimentalEl.textContent = 'Calculando...';
        mediaTeoricaEl.textContent = 'Calculando...';


        // Usar setTimeout para permitir la actualización de la UI
        setTimeout(() => {
            try {
                // --- Simulación Experimental ---
                const resultadosK = []; // Almacena los k de cada experimento
                let sumaK = 0;
                console.time("SimulacionBanach");
                for (let i = 0; i < N; i++) {
                    const k_resultante = simularUnExperimentoBanach(n);
                     if (k_resultante === -1) throw new Error("Error detectado en la simulación de un experimento.");
                    resultadosK.push(k_resultante);
                    sumaK += k_resultante;
                }
                 console.timeEnd("SimulacionBanach");
                console.log("Simulación experimental completada.");

                // --- Cálculo de Frecuencias Experimentales ---
                // k puede ir de 0 a n
                const frecuenciasAbsolutas = new Array(n + 1).fill(0);
                resultadosK.forEach(k => {
                    if (k >= 0 && k <= n) {
                        frecuenciasAbsolutas[k]++;
                    } else {
                         console.warn(`Resultado k inválido (${k}) encontrado en simulación.`);
                    }
                });
                const frecuenciasRelativas = frecuenciasAbsolutas.map(count => count / N);
                const labelsGrafico = Array.from({ length: n + 1 }, (_, i) => i); // [0, 1, ..., n]

                // --- Cálculo de Probabilidades Teóricas ---
                console.log("Calculando probabilidades teóricas...");
                console.time("CalculoTeoricoBanach");
                const probabilidadesTeoricas = [];
                let sumaProbTeorica = 0;
                let mediaTeoCalculada = 0;
                for (let k = 0; k <= n; k++) {
                    const prob_k = probabilidadBanach(k, n);
                    probabilidadesTeoricas.push(prob_k);
                    sumaProbTeorica += prob_k;
                    mediaTeoCalculada += k * prob_k; // Suma para E[k] = Σ k*P(k)
                }
                console.timeEnd("CalculoTeoricoBanach");
                console.log("Suma teórica P(k):", sumaProbTeorica.toFixed(6)); // Debe ser cercano a 1

                // --- Cálculo de Diferencias ---
                const diferencias = probabilidadesTeoricas.map((pTeo, k) => pTeo - frecuenciasRelativas[k]);

                // --- Actualizar Estadísticas ---
                const mediaExp = sumaK / N;

                mediaExperimentalEl.textContent = mediaExp.toFixed(5);
                mediaTeoricaEl.textContent = mediaTeoCalculada.toFixed(5);

                // --- Dibujar Gráficos ---
                console.log("Dibujando gráficos...");
                console.time("DibujarGraficosBanach");
                const refExp = { current: graficoExperimental };
                const refTeo = { current: graficoTeorico };
                const refDif = { current: graficoDiferencias };

                dibujarGrafico(ctxExp, refExp, labelsGrafico, frecuenciasRelativas, 'Frec. Relativa', 'rgba(54, 162, 235, 0.7)', 'rgba(54, 162, 235, 1)', 'Frecuencia Relativa');
                graficoExperimental = refExp.current;

                dibujarGrafico(ctxTeo, refTeo, labelsGrafico, probabilidadesTeoricas, 'Prob. Teórica', 'rgba(255, 99, 132, 0.7)', 'rgba(255, 99, 132, 1)', 'Probabilidad Teórica');
                graficoTeorico = refTeo.current;

                dibujarGrafico(ctxDif, refDif, labelsGrafico, diferencias, 'Diferencia', 'rgba(75, 192, 192, 0.7)', 'rgba(75, 192, 192, 1)', 'Diferencia (Teórica - Exp.)');
                graficoDiferencias = refDif.current;
                console.timeEnd("DibujarGraficosBanach");

                estadoEl.textContent = 'Simulación completada.';
                estadoEl.className = 'estado';
                console.log("Proceso completo.");

            } catch (error) {
                console.error("Error durante la simulación o el cálculo:", error);
                estadoEl.textContent = `Error: ${error.message}. Revisa la consola (F12).`;
                estadoEl.className = 'estado error';
                paramsUsadosEl.textContent = 'Error';
                mediaExperimentalEl.textContent = '---';
                mediaTeoricaEl.textContent = '---';
                 // Asegurarse de limpiar los gráficos también en caso de error
                if (graficoExperimental) graficoExperimental.destroy();
                if (graficoTeorico) graficoTeorico.destroy();
                if (graficoDiferencias) graficoDiferencias.destroy();
                graficoExperimental = graficoTeorico = graficoDiferencias = null;
            }
        }, 50); // Retraso
    }

    // --- Event Listener para el Botón ---
    btnSimular.addEventListener('click', iniciarSimulacion);

    // Mensaje inicial
    console.log("Interfaz lista para la simulación del problema de Banach.");

</script>

</body>
</html>